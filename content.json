[
  {
    "title": "Docker 指令速查表",
    "url": "https://caocharles.github.io/dcka-class-notes/appendix/docker_cheatsheet/",
    "content": "# Docker 指令速查表\n\n快速參考 Docker 常用指令，適合日常操作與考試複習。\n\n---\n\n## 容器管理\n\n### 執行容器\n\n| 指令 | 說明 |\n|------|------|\n| `docker run <image>` | 執行容器 |\n| `docker run -d <image>` | 背景執行 |\n| `docker run -it <image> /bin/bash` | 互動模式 |\n| `docker run --name <name> <image>` | 指定名稱 |\n| `docker run -p 8080:80 <image>` | Port 對應 |\n| `docker run -v /host:/container <image>` | 掛載目錄 |\n| `docker run -e VAR=value <image>` | 設定環境變數 |\n| `docker run --rm <image>` | 結束後自動刪除 |\n| `docker run --restart=always <image>` | 自動重啟 |\n| `docker run --network <network> <image>` | 指定網路 |\n\n### 容器操作\n\n| 指令 | 說明 |\n|------|------|\n| `docker ps` | 列出運行中的容器 |\n| `docker ps -a` | 列出所有容器 |\n| `docker start <container>` | 啟動容器 |\n| `docker stop <container>` | 停止容器 |\n| `docker restart <container>` | 重啟容器 |\n| `docker pause <container>` | 暫停容器 |\n| `docker unpause <container>` | 繼續容器 |\n| `docker rm <container>` | 刪除容器 |\n| `docker rm -f <container>` | 強制刪除運行中的容器 |\n| `docker container prune` | 刪除所有已停止的容器 |\n\n### 容器操作與除錯\n\n| 指令 | 說明 |\n|------|------|\n| `docker exec -it <container> /bin/bash` | 進入容器 |\n| `docker exec <container> <command>` | 執行指令 |\n| `docker logs <container>` | 查看日誌 |\n| `docker logs -f <container>` | 追蹤日誌 |\n| `docker logs --tail 100 <container>` | 最後 100 行 |\n| `docker inspect <container>` | 詳細資訊 |\n| `docker stats` | 資源使用統計 |\n| `docker top <container>` | 容器內程序 |\n| `docker cp <src> <container>:<dest>` | 複製檔案到容器 |\n| `docker cp <container>:<src> <dest>` | 從容器複製檔案 |\n\n---\n\n## Image 管理\n\n### 基本操作\n\n| 指令 | 說明 |\n|------|------|\n| `docker images` | 列出本地 Image |\n| `docker pull <image>` | 拉取 Image |\n| `docker push <image>` | 推送 Image |\n| `docker rmi <image>` | 刪除 Image |\n| `docker image prune` | 刪除未使用的 Image |\n| `docker image prune -a` | 刪除所有未使用的 Image |\n\n### 建置與標籤\n\n| 指令 | 說明 |\n|------|------|\n| `docker build -t <name>:<tag> .` | 建置 Image |\n| `docker build -f Dockerfile.prod .` | 指定 Dockerfile |\n| `docker build --no-cache .` | 不使用快取 |\n| `docker tag <image> <new-tag>` | 加上標籤 |\n| `docker history <image>` | 查看 Image 歷史 |\n| `docker save -o image.tar <image>` | 匯出 Image |\n| `docker load -i image.tar` | 匯入 Image |\n\n### 搜尋\n\n| 指令 | 說明 |\n|------|------|\n| `docker search <keyword>` | 搜尋 Docker Hub |\n| `docker search --filter is-official=true <keyword>` | 只搜尋官方 Image |\n| `docker search --limit 5 <keyword>` | 限制結果數量 |\n\n---\n\n## Volume 管理\n\n| 指令 | 說明 |\n|------|------|\n| `docker volume ls` | 列出所有 Volume |\n| `docker volume create <name>` | 建立 Volume |\n| `docker volume inspect <name>` | 查看詳細資訊 |\n| `docker volume rm <name>` | 刪除 Volume |\n| `docker volume prune` | 刪除未使用的 Volume |\n\n### 掛載方式\n\n```bash\n# Volume 掛載\ndocker run -v my-volume:/app/data nginx\n\n# Bind Mount\ndocker run -v /host/path:/container/path nginx\n\n# 唯讀掛載\ndocker run -v /host/path:/container/path:ro nginx\n\n# --mount 語法（推薦）\ndocker run --mount type=volume,source=my-volume,target=/app/data nginx\ndocker run --mount type=bind,source=/host/path,target=/container/path nginx\n```\n\n---\n\n## 網路管理\n\n| 指令 | 說明 |\n|------|------|\n| `docker network ls` | 列出所有網路 |\n| `docker network create <name>` | 建立網路 |\n| `docker network connect <network> <container>` | 連接網路 |\n| `docker network disconnect <network> <container>` | 斷開網路 |\n| `docker network rm <name>` | 刪除網路 |\n| `docker network prune` | 刪除未使用的網路 |\n| `docker network inspect <name>` | 查看詳細資訊 |\n\n### 網路類型\n\n| 類型 | 說明 |\n|------|------|\n| `bridge` | 預設，容器透過虛擬橋接器連接 |\n| `host` | 直接使用主機網路 |\n| `none` | 無網路 |\n| `overlay` | 跨主機通訊（Swarm） |\n\n---\n\n## 系統管理\n\n| 指令 | 說明 |\n|------|------|\n| `docker info` | 系統資訊 |\n| `docker version` | 版本資訊 |\n| `docker system df` | 磁碟使用量 |\n| `docker system prune` | 清理未使用資源 |\n| `docker system prune -a --volumes` | 完整清理 |\n| `docker events` | 即時事件 |\n\n---\n\n## Docker Compose\n\n| 指令 | 說明 |\n|------|------|\n| `docker compose up` | 啟動服務 |\n| `docker compose up -d` | 背景啟動 |\n| `docker compose down` | 停止並移除 |\n| `docker compose down -v` | 同時移除 Volume |\n| `docker compose ps` | 列出服務 |\n| `docker compose logs` | 查看日誌 |\n| `docker compose logs -f` | 追蹤日誌 |\n| `docker compose exec <service> <command>` | 執行指令 |\n| `docker compose build` | 建置服務 |\n| `docker compose pull` | 拉取 Image |\n\n---\n\n## Registry 登入\n\n| 指令 | 說明 |\n|------|------|\n| `docker login` | 登入 Docker Hub |\n| `docker login <registry>` | 登入私有 Registry |\n| `docker logout` | 登出 |\n\n---\n\n## 常用組合指令\n\n```bash title=\"常用操作\"\n# 停止所有容器\ndocker stop $(docker ps -q)\n\n# 刪除所有容器\ndocker rm $(docker ps -aq)\n\n# 刪除所有 Image\ndocker rmi $(docker images -q)\n\n# 刪除 dangling Image\ndocker rmi $(docker images -f \"dangling=true\" -q)\n\n# 取得容器 IP\ndocker inspect -f '{{range.NetworkSettings.Networks}}{{.IPAddress}}{{end}}' <container>\n\n# 進入運行中的容器\ndocker exec -it $(docker ps -q -f name=nginx) /bin/sh\n```\n\n---\n\n## Dockerfile 指令\n\n| 指令 | 說明 |\n|------|------|\n| `FROM` | 基礎 Image |\n| `RUN` | 執行指令 |\n| `COPY` | 複製檔案 |\n| `ADD` | 複製檔案（支援 URL、解壓縮） |\n| `WORKDIR` | 工作目錄 |\n| `ENV` | 環境變數 |\n| `EXPOSE` | 暴露 Port |\n| `CMD` | 預設執行指令 |\n| `ENTRYPOINT` | 入口點 |\n| `VOLUME` | 掛載點 |\n| `USER` | 執行身份 |\n| `ARG` | 建置參數 |\n| `LABEL` | 標籤 |\n| `HEALTHCHECK` | 健康檢查 |\n\n---\n\n## 環境變數\n\n| 變數 | 說明 |\n|------|------|\n| `DOCKER_HOST` | Docker 主機位址 |\n| `DOCKER_TLS_VERIFY` | 啟用 TLS 驗證 |\n| `DOCKER_CERT_PATH` | TLS 憑證路徑 |\n| `DOCKER_CONFIG` | 設定檔目錄 |\n"
  },
  {
    "title": "Kubernetes 指令速查表",
    "url": "https://caocharles.github.io/dcka-class-notes/appendix/k8s_cheatsheet/",
    "content": "# Kubernetes 指令速查表\n\n快速參考 kubectl 常用指令，適合日常操作與考試複習。\n\n---\n\n## 基本操作\n\n### 叢集資訊\n\n| 指令 | 說明 |\n|------|------|\n| `kubectl cluster-info` | 叢集資訊 |\n| `kubectl version` | 版本資訊 |\n| `kubectl config view` | 查看設定 |\n| `kubectl config get-contexts` | 列出 Context |\n| `kubectl config use-context <name>` | 切換 Context |\n| `kubectl api-resources` | 列出 API 資源 |\n| `kubectl api-versions` | 列出 API 版本 |\n\n### 資源查詢\n\n| 指令 | 說明 |\n|------|------|\n| `kubectl get <resource>` | 列出資源 |\n| `kubectl get pods` | 列出 Pod |\n| `kubectl get pods -o wide` | 詳細資訊（含 IP、Node） |\n| `kubectl get pods -o yaml` | YAML 格式輸出 |\n| `kubectl get pods -o json` | JSON 格式輸出 |\n| `kubectl get pods -w` | 持續監看 |\n| `kubectl get pods -l app=nginx` | 依標籤過濾 |\n| `kubectl get pods -n <namespace>` | 指定 Namespace |\n| `kubectl get pods --all-namespaces` | 所有 Namespace |\n| `kubectl get all` | 列出常見資源 |\n\n---\n\n## 資源管理\n\n### 建立與套用\n\n| 指令 | 說明 |\n|------|------|\n| `kubectl apply -f <file.yaml>` | 套用設定 |\n| `kubectl apply -f <directory>/` | 套用目錄下所有設定 |\n| `kubectl create -f <file.yaml>` | 建立資源 |\n| `kubectl create deployment <name> --image=<image>` | 建立 Deployment |\n| `kubectl create service clusterip <name> --tcp=80:80` | 建立 Service |\n| `kubectl create configmap <name> --from-literal=key=value` | 建立 ConfigMap |\n| `kubectl create secret generic <name> --from-literal=key=value` | 建立 Secret |\n\n### 編輯與刪除\n\n| 指令 | 說明 |\n|------|------|\n| `kubectl edit <resource> <name>` | 編輯資源 |\n| `kubectl delete <resource> <name>` | 刪除資源 |\n| `kubectl delete -f <file.yaml>` | 依設定檔刪除 |\n| `kubectl delete pods --all` | 刪除所有 Pod |\n| `kubectl delete pods -l app=nginx` | 依標籤刪除 |\n\n### 詳細資訊\n\n| 指令 | 說明 |\n|------|------|\n| `kubectl describe <resource> <name>` | 詳細描述 |\n| `kubectl describe pod <pod-name>` | 描述 Pod |\n| `kubectl describe node <node-name>` | 描述 Node |\n\n---\n\n## Pod 操作\n\n### 執行與存取\n\n| 指令 | 說明 |\n|------|------|\n| `kubectl run <name> --image=<image>` | 建立 Pod |\n| `kubectl exec -it <pod> -- /bin/sh` | 進入 Pod |\n| `kubectl exec <pod> -- <command>` | 執行指令 |\n| `kubectl logs <pod>` | 查看日誌 |\n| `kubectl logs -f <pod>` | 追蹤日誌 |\n| `kubectl logs <pod> -c <container>` | 多容器指定 |\n| `kubectl logs <pod> --previous` | 前一個容器的日誌 |\n| `kubectl logs <pod> --tail=100` | 最後 100 行 |\n| `kubectl port-forward <pod> 8080:80` | Port 轉發 |\n| `kubectl cp <pod>:<path> <local-path>` | 複製檔案 |\n\n---\n\n## Deployment 管理\n\n### 基本操作\n\n| 指令 | 說明 |\n|------|------|\n| `kubectl get deployments` | 列出 Deployment |\n| `kubectl describe deployment <name>` | 詳細描述 |\n| `kubectl scale deployment <name> --replicas=3` | 調整副本 |\n| `kubectl set image deployment/<name> <container>=<image>` | 更新 Image |\n\n### 滾動更新\n\n| 指令 | 說明 |\n|------|------|\n| `kubectl rollout status deployment/<name>` | 查看更新狀態 |\n| `kubectl rollout history deployment/<name>` | 查看歷史 |\n| `kubectl rollout undo deployment/<name>` | 回滾 |\n| `kubectl rollout undo deployment/<name> --to-revision=2` | 回滾到特定版本 |\n| `kubectl rollout restart deployment/<name>` | 重啟 |\n| `kubectl rollout pause deployment/<name>` | 暫停更新 |\n| `kubectl rollout resume deployment/<name>` | 繼續更新 |\n\n---\n\n## Service 管理\n\n| 指令 | 說明 |\n|------|------|\n| `kubectl get services` | 列出 Service |\n| `kubectl get endpoints` | 列出 Endpoints |\n| `kubectl expose deployment <name> --port=80` | 建立 Service |\n| `kubectl expose deployment <name> --type=NodePort --port=80` | NodePort |\n| `kubectl expose deployment <name> --type=LoadBalancer --port=80` | LoadBalancer |\n\n---\n\n## Namespace 管理\n\n| 指令 | 說明 |\n|------|------|\n| `kubectl get namespaces` | 列出 Namespace |\n| `kubectl create namespace <name>` | 建立 Namespace |\n| `kubectl delete namespace <name>` | 刪除 Namespace |\n| `kubectl config set-context --current --namespace=<name>` | 切換預設 Namespace |\n\n---\n\n## ConfigMap & Secret\n\n### ConfigMap\n\n| 指令 | 說明 |\n|------|------|\n| `kubectl get configmaps` | 列出 ConfigMap |\n| `kubectl create configmap <name> --from-literal=key=value` | 從字面值建立 |\n| `kubectl create configmap <name> --from-file=<file>` | 從檔案建立 |\n| `kubectl describe configmap <name>` | 檢視內容 |\n\n### Secret\n\n| 指令 | 說明 |\n|------|------|\n| `kubectl get secrets` | 列出 Secret |\n| `kubectl create secret generic <name> --from-literal=key=value` | 建立 Secret |\n| `kubectl get secret <name> -o jsonpath='{.data.key}' \\| base64 -d` | 解碼 Secret |\n\n---\n\n## PV & PVC\n\n| 指令 | 說明 |\n|------|------|\n| `kubectl get pv` | 列出 PersistentVolume |\n| `kubectl get pvc` | 列出 PersistentVolumeClaim |\n| `kubectl describe pv <name>` | 描述 PV |\n| `kubectl describe pvc <name>` | 描述 PVC |\n\n---\n\n## Node 管理\n\n| 指令 | 說明 |\n|------|------|\n| `kubectl get nodes` | 列出節點 |\n| `kubectl describe node <name>` | 描述節點 |\n| `kubectl top nodes` | 節點資源使用 |\n| `kubectl cordon <node>` | 標記節點不可調度 |\n| `kubectl uncordon <node>` | 取消標記 |\n| `kubectl drain <node>` | 排空節點 |\n| `kubectl taint nodes <node> key=value:NoSchedule` | 加上 Taint |\n\n---\n\n## RBAC\n\n| 指令 | 說明 |\n|------|------|\n| `kubectl get roles` | 列出 Role |\n| `kubectl get clusterroles` | 列出 ClusterRole |\n| `kubectl get rolebindings` | 列出 RoleBinding |\n| `kubectl get clusterrolebindings` | 列出 ClusterRoleBinding |\n| `kubectl auth can-i <verb> <resource>` | 檢查權限 |\n| `kubectl auth can-i <verb> <resource> --as=<user>` | 模擬使用者檢查 |\n\n---\n\n## 疑難排解\n\n| 指令 | 說明 |\n|------|------|\n| `kubectl get events` | 查看事件 |\n| `kubectl get events --sort-by='.lastTimestamp'` | 依時間排序 |\n| `kubectl top pods` | Pod 資源使用 |\n| `kubectl top nodes` | Node 資源使用 |\n| `kubectl describe pod <name>` | 詳細描述 |\n| `kubectl logs <pod> --previous` | 前一個容器日誌 |\n\n---\n\n## 輸出格式\n\n| 格式 | 說明 |\n|------|------|\n| `-o wide` | 額外欄位 |\n| `-o yaml` | YAML 格式 |\n| `-o json` | JSON 格式 |\n| `-o name` | 只顯示名稱 |\n| `-o jsonpath='{...}'` | JSONPath 查詢 |\n| `-o custom-columns=...` | 自訂欄位 |\n\n### JSONPath 範例\n\n```bash\n# 取得 Pod IP\nkubectl get pod <name> -o jsonpath='{.status.podIP}'\n\n# 取得所有 Pod 名稱\nkubectl get pods -o jsonpath='{.items[*].metadata.name}'\n\n# 取得所有 Container Image\nkubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'\n```\n\n---\n\n## 常用組合指令\n\n```bash title=\"實用指令\"\n# 刪除所有 Evicted Pod\nkubectl delete pods --field-selector=status.phase=Failed --all-namespaces\n\n# 取得所有 Pod 的 Image\nkubectl get pods -o jsonpath=\"{.items[*].spec.containers[*].image}\" | tr -s '[[:space:]]' '\\n' | sort | uniq\n\n# 依記憶體使用量排序 Pod\nkubectl top pods --sort-by=memory\n\n# 快速建立測試 Pod\nkubectl run test --image=busybox --rm -it -- /bin/sh\n\n# 產生 YAML 但不執行\nkubectl create deployment nginx --image=nginx --dry-run=client -o yaml\n\n# 匯出現有資源\nkubectl get deployment nginx -o yaml > nginx-deployment.yaml\n```\n\n---\n\n## minikube 指令\n\n| 指令 | 說明 |\n|------|------|\n| `minikube start` | 啟動 |\n| `minikube stop` | 停止 |\n| `minikube delete` | 刪除 |\n| `minikube status` | 狀態 |\n| `minikube dashboard` | 開啟 Dashboard |\n| `minikube ip` | 取得 IP |\n| `minikube ssh` | SSH 連線 |\n| `minikube service <name>` | 開啟 Service |\n| `minikube addons list` | 列出插件 |\n| `minikube addons enable <name>` | 啟用插件 |\n\n---\n\n## 快捷別名\n\n```bash title=\"建議加入 ~/.bashrc 或 ~/.zshrc\"\nalias k='kubectl'\nalias kgp='kubectl get pods'\nalias kgs='kubectl get services'\nalias kgd='kubectl get deployments'\nalias kgn='kubectl get nodes'\nalias kd='kubectl describe'\nalias kl='kubectl logs'\nalias ke='kubectl exec -it'\nalias ka='kubectl apply -f'\nalias kd='kubectl delete -f'\n\n# 自動補全\nsource <(kubectl completion bash)\nsource <(kubectl completion zsh)\n```\n"
  },
  {
    "title": "疑難排解指南",
    "url": "https://caocharles.github.io/dcka-class-notes/appendix/troubleshooting/",
    "content": "# 疑難排解指南\n\n本章節整理 Docker 與 Kubernetes 常見問題的診斷與解決方法。\n\n---\n\n## Docker 疑難排解\n\n### 1. Docker 服務無法啟動\n\n!!! warning \"症狀\"\n    ```\n    Cannot connect to the Docker daemon at unix:///var/run/docker.sock\n    ```\n\n**診斷步驟**：\n\n```bash title=\"檢查 Docker 服務\"\n# 檢查服務狀態\nsudo systemctl status docker\n\n# 查看服務日誌\nsudo journalctl -u docker -f\n\n# 檢查 socket 檔案\nls -la /var/run/docker.sock\n```\n\n**解決方案**：\n\n```bash\n# 啟動 Docker 服務\nsudo systemctl start docker\n\n# 設定開機自動啟動\nsudo systemctl enable docker\n\n# 如果 socket 問題，重新建立\nsudo rm /var/run/docker.sock\nsudo systemctl restart docker\n```\n\n---\n\n### 2. Permission Denied\n\n!!! warning \"症狀\"\n    ```\n    permission denied while trying to connect to the Docker daemon socket\n    ```\n\n**解決方案**：\n\n```bash\n# 將使用者加入 docker 群組\nsudo usermod -aG docker $USER\n\n# 重新登入或執行\nnewgrp docker\n\n# 驗證群組\ngroups\n```\n\n---\n\n### 3. 容器啟動後立即退出\n\n**診斷步驟**：\n\n```bash title=\"診斷容器退出\"\n# 檢視容器狀態\ndocker ps -a\n\n# 查看退出碼\ndocker inspect <container> --format='{{.State.ExitCode}}'\n\n# 查看日誌\ndocker logs <container>\n\n# 查看最後輸出\ndocker logs --tail 50 <container>\n```\n\n**常見原因與解決**：\n\n| 退出碼 | 原因 | 解決方案 |\n|--------|------|----------|\n| 0 | 正常結束 | 確認 CMD 指令是否為前景程序 |\n| 1 | 應用程式錯誤 | 查看日誌找出錯誤 |\n| 137 | OOM Killed | 增加記憶體限制 |\n| 139 | Segmentation Fault | 檢查應用程式相容性 |\n| 143 | SIGTERM | 正常終止信號 |\n\n```bash title=\"保持容器運行（測試用）\"\n# 使用 sleep 保持運行\ndocker run -d --name test ubuntu sleep infinity\n\n# 或使用 tail\ndocker run -d --name test ubuntu tail -f /dev/null\n```\n\n---\n\n### 4. Image 拉取失敗\n\n!!! warning \"症狀\"\n    ```\n    Error response from daemon: pull access denied\n    Error response from daemon: Get https://registry-1.docker.io/v2/: net/http: request canceled\n    ```\n\n**診斷步驟**：\n\n```bash\n# 確認 Image 名稱\ndocker search <image-name>\n\n# 確認網路連線\nping registry-1.docker.io\n\n# 確認 DNS\nnslookup registry-1.docker.io\n```\n\n**解決方案**：\n\n```bash\n# 如需登入\ndocker login\n\n# 設定 Registry Mirror（國內加速）\n# 編輯 /etc/docker/daemon.json\n{\n  \"registry-mirrors\": [\"https://mirror.example.com\"]\n}\n\n# 重啟 Docker\nsudo systemctl restart docker\n```\n\n---\n\n### 5. 磁碟空間不足\n\n!!! warning \"症狀\"\n    ```\n    no space left on device\n    ```\n\n**診斷步驟**：\n\n```bash title=\"檢查磁碟使用\"\n# 檢視 Docker 磁碟使用\ndocker system df\n\n# 詳細資訊\ndocker system df -v\n\n# 檢查系統磁碟\ndf -h\n```\n\n**解決方案**：\n\n```bash title=\"清理資源\"\n# 清理未使用的資源\ndocker system prune\n\n# 完整清理（包含未使用的 Image 和 Volume）\ndocker system prune -a --volumes\n\n# 刪除 dangling Image\ndocker image prune\n\n# 刪除未使用的 Volume\ndocker volume prune\n\n# 刪除已停止的容器\ndocker container prune\n```\n\n---\n\n### 6. Port 已被佔用\n\n!!! warning \"症狀\"\n    ```\n    Bind for 0.0.0.0:8080 failed: port is already allocated\n    ```\n\n**診斷步驟**：\n\n```bash\n# 查看 Port 使用情況\nsudo lsof -i :8080\n\n# 或使用 netstat\nsudo netstat -tlnp | grep 8080\n\n# 查看 Docker 容器使用的 Port\ndocker ps --format \"table {{.Names}}\\t{{.Ports}}\"\n```\n\n**解決方案**：\n\n```bash\n# 停止佔用 Port 的程序\nsudo kill <PID>\n\n# 或使用其他 Port\ndocker run -d -p 8081:80 nginx\n```\n\n---\n\n### 7. Volume 權限問題\n\n!!! warning \"症狀\"\n    容器內無法寫入掛載的目錄\n\n**解決方案**：\n\n```bash\n# 方法 1：調整主機目錄權限\nsudo chown -R 1000:1000 /path/to/host/dir\n\n# 方法 2：使用特定 UID 執行容器\ndocker run -u $(id -u):$(id -g) -v /host:/container image\n\n# 方法 3：使用 SELinux 標籤（RHEL/CentOS）\ndocker run -v /host:/container:Z image\n```\n\n---\n\n## Kubernetes 疑難排解\n\n### 1. Pod 處於 Pending 狀態\n\n**診斷步驟**：\n\n```bash title=\"診斷 Pending Pod\"\n# 查看 Pod 事件\nkubectl describe pod <pod-name>\n\n# 查看 Events\nkubectl get events --field-selector involvedObject.name=<pod-name>\n\n# 檢查節點資源\nkubectl describe nodes | grep -A 5 \"Allocated resources\"\n```\n\n**常見原因與解決**：\n\n| 原因 | 說明 | 解決方案 |\n|------|------|----------|\n| 資源不足 | CPU/Memory 不夠 | 增加節點或減少 requests |\n| nodeSelector 不符 | 沒有符合的節點 | 調整 selector 或加 label |\n| PVC 未綁定 | PV 不存在或不符合 | 建立符合的 PV |\n| Taint/Toleration | 節點有 Taint | 加上 Toleration |\n\n---\n\n### 2. Pod 處於 CrashLoopBackOff\n\n**診斷步驟**：\n\n```bash title=\"診斷 CrashLoopBackOff\"\n# 查看日誌\nkubectl logs <pod-name>\n\n# 查看前一個容器的日誌\nkubectl logs <pod-name> --previous\n\n# 查看詳細狀態\nkubectl describe pod <pod-name>\n\n# 檢查退出碼\nkubectl get pod <pod-name> -o jsonpath='{.status.containerStatuses[0].lastState.terminated.exitCode}'\n```\n\n**常見原因與解決**：\n\n| 原因 | 解決方案 |\n|------|----------|\n| 應用程式錯誤 | 查看日誌，修復程式 |\n| 設定錯誤 | 檢查 ConfigMap/Secret |\n| 資源不足 | 增加 memory/cpu limits |\n| 健康檢查失敗 | 調整 probe 參數 |\n| 依賴服務未就緒 | 使用 initContainer |\n\n---\n\n### 3. Pod 處於 ImagePullBackOff\n\n**診斷步驟**：\n\n```bash\n# 查看錯誤訊息\nkubectl describe pod <pod-name> | grep -A 10 Events\n\n# 驗證 Image 存在\ndocker pull <image-name>\n```\n\n**解決方案**：\n\n```bash\n# 確認 Image 名稱正確\n# 確認 Registry 存取權限\n\n# 如果是私有 Registry，建立 Secret\nkubectl create secret docker-registry regcred \\\n  --docker-server=<registry> \\\n  --docker-username=<username> \\\n  --docker-password=<password>\n\n# 在 Pod spec 加入 imagePullSecrets\nspec:\n  imagePullSecrets:\n    - name: regcred\n```\n\n---\n\n### 4. Service 無法連接\n\n**診斷步驟**：\n\n```bash title=\"診斷 Service 連線\"\n# 確認 Service 存在\nkubectl get svc <service-name>\n\n# 確認 Endpoints\nkubectl get endpoints <service-name>\n\n# 確認 Pod 運行中\nkubectl get pods -l <selector>\n\n# 從 Pod 內測試連線\nkubectl exec -it <pod> -- curl <service-name>:<port>\n\n# 檢查 DNS\nkubectl exec -it <pod> -- nslookup <service-name>\n```\n\n**常見原因與解決**：\n\n| 原因 | 解決方案 |\n|------|----------|\n| Selector 不符 | 確認 Service selector 與 Pod label 一致 |\n| Pod 未就緒 | 等待 Pod Ready 或檢查 readinessProbe |\n| Port 錯誤 | 確認 port 和 targetPort |\n| NetworkPolicy 阻擋 | 檢查 NetworkPolicy 規則 |\n\n---\n\n### 5. ConfigMap/Secret 更新後 Pod 沒有變化\n\n**原因**：Pod 不會自動重新載入 ConfigMap/Secret\n\n**解決方案**：\n\n```bash\n# 方法 1：重啟 Deployment\nkubectl rollout restart deployment/<name>\n\n# 方法 2：使用 annotation 觸發更新\nkubectl patch deployment <name> -p \\\n  '{\"spec\":{\"template\":{\"metadata\":{\"annotations\":{\"date\":\"'$(date +%s)'\"}}}}}'\n\n# 方法 3：使用 Reloader 工具\n# https://github.com/stakater/Reloader\n```\n\n---\n\n### 6. PVC 處於 Pending 狀態\n\n**診斷步驟**：\n\n```bash\n# 查看 PVC 狀態\nkubectl get pvc <pvc-name>\n\n# 查看詳細資訊\nkubectl describe pvc <pvc-name>\n\n# 查看可用的 PV\nkubectl get pv\n```\n\n**常見原因與解決**：\n\n| 原因 | 解決方案 |\n|------|----------|\n| 無符合的 PV | 建立符合規格的 PV |\n| StorageClass 不存在 | 建立 StorageClass 或指定正確名稱 |\n| 容量不足 | 減少 PVC 請求或增加 PV 容量 |\n| accessModes 不符 | 確認 PV/PVC accessModes 一致 |\n\n---\n\n### 7. Node 處於 NotReady\n\n**診斷步驟**：\n\n```bash\n# 查看節點狀態\nkubectl describe node <node-name>\n\n# 檢查 kubelet 狀態\nssh <node> \"sudo systemctl status kubelet\"\n\n# 查看 kubelet 日誌\nssh <node> \"sudo journalctl -u kubelet -f\"\n```\n\n**常見原因與解決**：\n\n| 原因 | 解決方案 |\n|------|----------|\n| kubelet 停止 | 重啟 kubelet |\n| 網路問題 | 檢查節點網路連線 |\n| 磁碟壓力 | 清理磁碟空間 |\n| 記憶體壓力 | 增加記憶體或減少 Pod |\n\n---\n\n### 8. RBAC 權限問題\n\n!!! warning \"症狀\"\n    ```\n    Error from server (Forbidden): pods is forbidden: User \"xxx\" cannot list resource \"pods\"\n    ```\n\n**診斷步驟**：\n\n```bash\n# 檢查權限\nkubectl auth can-i list pods --as=<user>\n\n# 檢查角色綁定\nkubectl get rolebindings,clusterrolebindings -A | grep <user>\n\n# 詳細檢查\nkubectl describe rolebinding <name> -n <namespace>\n```\n\n**解決方案**：\n\n```bash\n# 建立適當的 Role 和 RoleBinding\nkubectl create role pod-reader --verb=get,list,watch --resource=pods\nkubectl create rolebinding pod-reader-binding --role=pod-reader --user=<user>\n```\n\n---\n\n## 診斷工具\n\n### kubectl debug\n\n```bash\n# 建立除錯 Pod\nkubectl debug node/<node-name> -it --image=busybox\n\n# 為 Pod 建立除錯容器\nkubectl debug <pod-name> -it --image=busybox --target=<container>\n```\n\n### 常用診斷指令\n\n```bash title=\"綜合診斷\"\n# 快速檢查叢集狀態\nkubectl get nodes\nkubectl get pods --all-namespaces | grep -v Running\n\n# 檢查系統 Pod\nkubectl get pods -n kube-system\n\n# 檢查最近事件\nkubectl get events --sort-by='.lastTimestamp' | tail -20\n\n# 檢查資源使用\nkubectl top nodes\nkubectl top pods --all-namespaces\n```\n\n---\n\n## 日誌收集\n\n### 收集診斷資訊\n\n```bash title=\"收集診斷資訊腳本\"\n#!/bin/bash\nOUTPUT_DIR=\"k8s-debug-$(date +%Y%m%d-%H%M%S)\"\nmkdir -p $OUTPUT_DIR\n\n# 節點資訊\nkubectl get nodes -o wide > $OUTPUT_DIR/nodes.txt\nkubectl describe nodes > $OUTPUT_DIR/nodes-describe.txt\n\n# Pod 資訊\nkubectl get pods --all-namespaces -o wide > $OUTPUT_DIR/pods.txt\n\n# Service 資訊\nkubectl get svc --all-namespaces > $OUTPUT_DIR/services.txt\n\n# Events\nkubectl get events --all-namespaces --sort-by='.lastTimestamp' > $OUTPUT_DIR/events.txt\n\n# 壓縮\ntar -czvf $OUTPUT_DIR.tar.gz $OUTPUT_DIR\necho \"診斷資訊已儲存至 $OUTPUT_DIR.tar.gz\"\n```\n"
  },
  {
    "title": "Docker Containers 與 Kubernetes 系統管理",
    "url": "https://caocharles.github.io/dcka-class-notes/",
    "content": "# Docker Containers 與 Kubernetes 系統管理\n\n歡迎來到 **恆逸教育訓練中心 DCKA 課程** 學習筆記！\n\n!!! info \"課程資訊\"\n    - **課程名稱**：Docker Containers 與 Kubernetes 系統管理\n    - **課程代號**：DCKA\n    - **總時數**：21 小時（3 天）\n    - **適合對象**：網路工程師、雲端運算工程師\n\n---\n\n## 課程簡介\n\n本課程旨在幫助學員掌握 Docker Container（容器）技術與 Kubernetes（簡稱 K8S）容器編排平台的核心概念與實務操作。透過理論講解與動手實作，你將學會如何建立、管理和部署容器化應用程式。\n\n```mermaid\ngraph LR\n    A[傳統部署] --> B[虛擬化部署]\n    B --> C[容器化部署]\n    C --> D[容器編排 K8S]\n    \n    style A fill:#f9f,stroke:#333\n    style B fill:#bbf,stroke:#333\n    style C fill:#bfb,stroke:#333\n    style D fill:#ff9,stroke:#333\n```\n\n---\n\n## 學習目標\n\n完成本課程後，你將能夠：\n\n- [x] 理解容器化技術的優勢與應用場景\n- [x] 熟練操作 Docker 容器的建立、啟動、停止與刪除\n- [x] 客製化 Docker Image（映像檔）\n- [x] 使用 Kubernetes 部署與管理容器化應用\n- [x] 實作 WordPress + MySQL 的容器化部署\n\n---\n\n## 課程大綱\n\n### 1. Docker 基礎與管理 (LAB 01-08)\n\n- 環境初始化與基本操作\n- Docker 安裝 (Docker/Podman)\n- Private Registry 建置\n- Persistent Storage 與 WordPress 實作\n\n[:octicons-arrow-right-24: 開始學習](lab01_environment_setup.md)\n\n---\n\n### 2. Docker 進階應用 (LAB 09-10)\n\n- 客製化 Docker Images (commit & Dockerfile)\n- Dockerfile 指令與最佳實踐\n\n[:octicons-arrow-right-24: 開始學習](lab09_commit.md)\n\n---\n\n### 3. Kubernetes 基礎 (LAB 11-15)\n\n- Kubernetes 安裝 (Standalone & Cluster)\n- 常用指令與 Namespaces\n- Rolling Update 與 Service 負載均衡\n\n[:octicons-arrow-right-24: 開始學習](lab11_standalone_k8s.md)\n\n---\n\n### 4. Kubernetes 進階管理 (LAB 16-20)\n\n- 儲存管理 (PV/PVC)\n- 設定管理 (Secret/ConfigMap)\n- 權限控制 (RBAC)\n- 實作：WordPress + MySQL 完整部署\n- Kubernetes Dashboard\n\n[:octicons-arrow-right-24: 開始學習](lab16_pv_pvc.md)\n\n---\n\n## 預備知識\n\n開始本課程之前，建議你具備：\n\n!!! note \"必備知識\"\n    - Linux 基礎指令操作（cd、ls、cat、vim 等）\n    - Linux 基本系統管理概念\n    - 建議具備 RHCE 認證能力或同等經驗\n\n---\n\n## 附錄資源\n\n| 資源 | 說明 |\n|------|------|\n| [Docker 指令速查表](appendix/docker_cheatsheet.md) | 常用 Docker 指令快速參考 |\n| [Kubernetes 指令速查表](appendix/k8s_cheatsheet.md) | 常用 kubectl 指令快速參考 |\n| [疑難排解指南](appendix/troubleshooting.md) | 常見問題與解決方案 |\n\n---\n\n## 相關資源\n\n- :fontawesome-brands-docker: [Docker 官方文件](https://docs.docker.com/)\n- :material-kubernetes: [Kubernetes 官方文件](https://kubernetes.io/docs/)\n- :fontawesome-brands-docker: [Docker Hub](https://hub.docker.com/)\n- :material-podman: [Podman 官方文件](https://podman.io/)\n- :material-school: [恆逸 DCKA 課程頁面](https://www.uuu.com.tw/Course/Show/1552/Docker-Containers與Kubernetes系統管理)\n\n---\n\n!!! tip \"學習建議\"\n    1. 建議按章節順序學習\n    2. 每個章節的 Lab 實作務必親自動手操作\n    3. 遇到問題先查閱 FAQ，再參考疑難排解指南\n    4. 善用指令速查表加速學習\n"
  },
  {
    "title": "LAB 01 LAB 環境初始化",
    "url": "https://caocharles.github.io/dcka-class-notes/lab01_environment_setup/",
    "content": "# LAB 01 LAB 環境初始化\n\n## 學習目標\n\n完成本章節後，你將能夠：\n\n- [ ] 安裝並設定 VMware Workstation\n- [ ] 設定虛擬網路（Virtual Network Editor）\n- [ ] 啟動並驗證六台 Rocky Linux 虛擬機\n\n## 前置知識\n\n開始之前，請確保你已經：\n\n- 準備好 Windows 主機（建議 16GB+ RAM）\n- 下載 DCKA 課程虛擬機映像檔\n- 下載 VMware Workstation 安裝程式\n\n---\n\n## 0.1 安裝 VMware Workstation\n\n### 取得安裝程式\n\n課程提供的 VMware Workstation 17.6.4 安裝檔案位於：\n\n```\nC:\\DCKA-v8 (C:)\\VMware\\VMwareWorkstation_17.6.4\\\n```\n\n![VMware 安裝檔案位置](images/00_environment/vmware_installer.png)\n\n資料夾內包含：\n\n| 檔案 | 說明 |\n|------|------|\n| `VMware-workstation-full-17.6.4-2483....exe` | VMware Workstation 安裝程式 |\n| `md5sum.txt` | MD5 校驗碼 |\n| `md5sum.png` | 校驗碼截圖 |\n\n### 安裝步驟\n\n1. 執行 `VMware-workstation-full-17.6.4-2483....exe`\n2. 依照安裝精靈完成安裝\n3. 安裝完成後重新啟動電腦\n\n!!! tip \"安裝提示\"\n    安裝過程中建議選擇「典型安裝」，使用預設設定即可。\n\n---\n\n## 0.2 設定虛擬網路\n\n### 開啟 Virtual Network Editor\n\n1. 開啟 VMware Workstation\n2. 選擇 **Edit** → **Virtual Network Editor**\n3. 點選 **Change Settings** 取得管理員權限\n\n![Virtual Network Editor](images/00_environment/virtual_network_editor.png)\n\n### 設定 VMnet8 (NAT)\n\n選擇 **VMnet8**（NAT 模式），進行以下設定：\n\n#### 步驟 1：設定 Subnet IP\n\n將 **Subnet IP** 修改為：\n\n```\n192.168.66.0\n```\n\n#### 步驟 2：設定 NAT Settings\n\n點選 **NAT Settings...**，將 **Gateway IP** 設定為：\n\n```\n192.168.66.2\n```\n\n#### 步驟 3：設定 DHCP Settings\n\n點選 **DHCP Settings...**，確認以下設定：\n\n| 設定項目 | 值 |\n|----------|-----|\n| Starting IP address | `192.168.66.128` |\n| Ending IP address | `192.168.66.254` |\n\n!!! warning \"重要\"\n    請確保 Subnet IP 為 `192.168.66.0`，Gateway 為 `192.168.66.2`，否則後續實作可能無法正常連線。\n\n點選 **OK** 儲存設定。\n\n---\n\n## 0.3 網路拓樸與虛擬機\n\n### 網路架構\n\n課程環境使用 VMware Workstation 的 NAT 網路（VMnet8），網段為 `192.168.66.0/24`：\n\n![網路拓樸](images/00_environment/network_topology.jpg)\n\n```mermaid\ngraph TB\n    subgraph \"外部網路\"\n        Internet((Internet))\n        ExtNet[10.0.1.0/24]\n    end\n    \n    subgraph \"VMware NAT Gateway\"\n        NAT[\".254\"]\n    end\n    \n    subgraph \"VMnet8 - 192.168.66.0/24\"\n        Host[\".xxx<br/>VMware Workstation\"]\n        D1[\"docker1<br/>.51\"]\n        D2[\"docker2<br/>.52\"]\n        KS[\"k8s-standalone<br/>.61\"]\n        KM[\"k8s-master1<br/>.71\"]\n        KN1[\"k8s-node1<br/>.81\"]\n        KN2[\"k8s-node2<br/>.82\"]\n    end\n    \n    Internet --> ExtNet --> NAT\n    NAT --> Host\n    Host --> D1\n    Host --> D2\n    Host --> KS\n    Host --> KM\n    Host --> KN1\n    Host --> KN2\n```\n\n### 虛擬機清單與 IP 配置\n\n課程提供六台已預先設定好的 Rocky Linux 9 虛擬機：\n\n![虛擬機資料夾](images/00_environment/vmware_folder.png)\n\n| 虛擬機名稱 | IP 位址 | 用途 |\n|------------|---------|------|\n| `docker1` | 192.168.66.**51** | Docker 實作主機 1 |\n| `docker2` | 192.168.66.**52** | Docker 實作主機 2 |\n| `k8s-standalone` | 192.168.66.**61** | 獨立 Kubernetes 環境（單節點） |\n| `k8s-master1` | 192.168.66.**71** | Kubernetes Master（控制平面）節點 |\n| `k8s-node1` | 192.168.66.**81** | Kubernetes Worker 節點 1 |\n| `k8s-node2` | 192.168.66.**82** | Kubernetes Worker 節點 2 |\n| `mirror` | - | 本地 Mirror 伺服器（套件庫映射） |\n\n!!! info \"IP 配置規則\"\n    - **Docker 環境**：192.168.66.5x\n    - **K8s Standalone**：192.168.66.6x\n    - **K8s Master**：192.168.66.7x\n    - **K8s Worker**：192.168.66.8x\n    - **NAT Gateway**：192.168.66.254\n\n### 啟動所有虛擬機\n\n#### 方法 1：使用批次檔（推薦）\n\n執行 `PowerON-allVM.bat` 一次啟動所有虛擬機：\n\n```batch title=\"PowerON-allVM.bat\"\n\"C:\\Program Files (x86)\\VMware\\VMware Workstation\\vmrun\" -T ws start \"C:\\VMware\\DCKA-Rocky9\\mirror\\mirror.vmx\"\n\"C:\\Program Files (x86)\\VMware\\VMware Workstation\\vmrun\" -T ws start \"C:\\VMware\\DCKA-Rocky9\\docker1\\docker1.vmx\"\n\"C:\\Program Files (x86)\\VMware\\VMware Workstation\\vmrun\" -T ws start \"C:\\VMware\\DCKA-Rocky9\\docker2\\docker2.vmx\"\n\"C:\\Program Files (x86)\\VMware\\VMware Workstation\\vmrun\" -T ws start \"C:\\VMware\\DCKA-Rocky9\\k8s-standalone\\k8s-standalone.vmx\"\n\"C:\\Program Files (x86)\\VMware\\VMware Workstation\\vmrun\" -T ws start \"C:\\VMware\\DCKA-Rocky9\\k8s-master1\\k8s-master1.vmx\"\n\"C:\\Program Files (x86)\\VMware\\VMware Workstation\\vmrun\" -T ws start \"C:\\VMware\\DCKA-Rocky9\\k8s-node1\\k8s-node1.vmx\"\n\"C:\\Program Files (x86)\\VMware\\VMware Workstation\\vmrun\" -T ws start \"C:\\VMware\\DCKA-Rocky9\\k8s-node2\\k8s-node2.vmx\"\n```\n\n!!! tip \"批次檔使用說明\"\n    - 此批次檔使用 VMware 的 `vmrun` 命令列工具\n    - `-T ws` 指定使用 VMware Workstation\n    - `start` 參數表示啟動虛擬機\n\n#### 方法 2：手動啟動\n\n1. 在 VMware Workstation 中依序開啟每台虛擬機的 `.vmx` 檔案\n2. 點選 **Power on this virtual machine**\n\n### 關閉所有虛擬機\n\n課程結束後，可使用 `Shutdown-allVM.bat` 一次關閉所有虛擬機：\n\n```batch title=\"Shutdown-allVM.bat\"\n\"C:\\Program Files (x86)\\VMware\\VMware Workstation\\vmrun\" -T ws stop \"C:\\VMware\\DCKA-Rocky9\\mirror\\mirror.vmx\"\n\"C:\\Program Files (x86)\\VMware\\VMware Workstation\\vmrun\" -T ws stop \"C:\\VMware\\DCKA-Rocky9\\docker1\\docker1.vmx\"\n\"C:\\Program Files (x86)\\VMware\\VMware Workstation\\vmrun\" -T ws stop \"C:\\VMware\\DCKA-Rocky9\\docker2\\docker2.vmx\"\n\"C:\\Program Files (x86)\\VMware\\VMware Workstation\\vmrun\" -T ws stop \"C:\\VMware\\DCKA-Rocky9\\k8s-standalone\\k8s-standalone.vmx\"\n\"C:\\Program Files (x86)\\VMware\\VMware Workstation\\vmrun\" -T ws stop \"C:\\VMware\\DCKA-Rocky9\\k8s-master1\\k8s-master1.vmx\"\n\"C:\\Program Files (x86)\\VMware\\VMware Workstation\\vmrun\" -T ws stop \"C:\\VMware\\DCKA-Rocky9\\k8s-node1\\k8s-node1.vmx\"\n\"C:\\Program Files (x86)\\VMware\\VMware Workstation\\vmrun\" -T ws stop \"C:\\VMware\\DCKA-Rocky9\\k8s-node2\\k8s-node2.vmx\"\n```\n\n!!! warning \"正確關機\"\n    使用 `stop` 命令會執行正常關機程序（相當於按下電源按鈕）。如需強制關機，可改用 `stop hard` 參數，但不建議經常使用。\n\n### 驗證虛擬機狀態\n\n啟動完成後，應該可以看到所有虛擬機都在運行中，並顯示 Rocky Linux 登入畫面：\n\n![虛擬機執行中](images/00_environment/vms_running.png)\n\n### 登入資訊\n\n| 帳號 | 密碼 |\n|------|------|\n| `root` | `container` |\n\n!!! success \"環境準備完成\"\n    當所有虛擬機都成功啟動並可以登入後，即可開始進行 Docker 與 Kubernetes 實作練習。\n\n---\n\n## 0.4 Mirror 伺服器\n\n課程提供本地 Mirror 伺服器，加速套件下載並支援離線環境。\n\n### Mirror 網址\n\n| 網路環境 | 網址 |\n|----------|------|\n| **內部網路**（VMnet8） | `http://192.168.66.248/k8s/` |\n| **外部網路**（教室網路） | `http://10.0.1.249/k8s/` |\n\n![內部 Mirror 伺服器](images/00_environment/mirror_internal.png)\n\n![外部 Mirror 伺服器](images/00_environment/mirror_external.png)\n\n### Mirror 資源內容\n\n| 資料夾/檔案 | 用途 |\n|-------------|------|\n| `248.repo` | YUM/DNF 套件庫設定檔 |\n| `ContainerImages/` | Docker/Container 映像檔 |\n| `Packages/` | RPM 套件 |\n| `command.txt` | 指令參考 |\n| `docs/` | 課程文件 |\n| `scripts/` | 自動化腳本 |\n| `yaml/` | Kubernetes YAML 設定檔 |\n| `VMwareWorkstation_17.6.4/` | VMware 安裝程式（外部網路） |\n\n!!! tip \"為什麼需要 Mirror？\"\n    - **加速下載**：從本地伺服器下載比網際網路快很多\n    - **離線環境**：教室可能沒有對外網路\n    - **版本一致**：確保所有學員使用相同版本的套件。\n\n---\n\n## 常見問題\n\n??? question \"Q1：虛擬機無法開機，顯示 VT-x 錯誤\"\n    **原因**：BIOS 未啟用虛擬化技術\n    \n    **解決方案**：\n    1. 重新啟動電腦，進入 BIOS 設定\n    2. 找到 Intel VT-x 或 AMD-V 選項\n    3. 將其設定為 Enabled\n    4. 儲存並重新啟動\n\n??? question \"Q2：網路無法連線\"\n    **原因**：Virtual Network Editor 設定錯誤\n    \n    **解決方案**：\n    1. 確認 VMnet8 的 Subnet IP 為 `192.168.66.0`\n    2. 確認 Gateway IP 為 `192.168.66.2`\n    3. 確認虛擬機網路介面設定為 NAT 模式\n\n??? question \"Q3：記憶體不足\"\n    **原因**：主機記憶體不足以運行所有虛擬機\n    \n    **解決方案**：\n    - 依序啟動需要的虛擬機，不要一次全部啟動\n    - 或升級主機記憶體至 16GB 以上\n\n---\n\n## 小結\n\n本章節重點回顧：\n\n- ✅ **VMware 安裝**：安裝 VMware Workstation 17.6.4\n- ✅ **網路設定**：VMnet8 設定為 192.168.66.0/24 網段\n- ✅ **虛擬機啟動**：六台 Rocky Linux 虛擬機全部啟動\n- ✅ **環境驗證**：確認可以正常登入虛擬機\n\n## 下一步\n\n環境準備完成後，請繼續前往 [LAB 02 安裝 DOCKER/DOCKER-CE](lab02_docker_install.md)\n"
  },
  {
    "title": "LAB 02 安裝 DOCKER/DOCKER-CE",
    "url": "https://caocharles.github.io/dcka-class-notes/lab02_docker_install/",
    "content": "# LAB 02 安裝 DOCKER/DOCKER-CE\n\n## 學習目標\n\n完成本 Lab 後，你將能夠：\n\n- [ ] 理解 RHEL/Rocky Linux 預設 `docker` 指令的行為 (Podman Emulation)\n- [ ] 移除預設的 `podman-docker` 套件\n- [ ] 設定 Docker CE 官方 Repository\n- [ ] 安裝並啟動 Docker CE (Community Edition)\n- [ ] 使用 `docker pull` 下載 Image 並備份\n\n---\n\n## 1.1 核心概念與比較\n\n在 RHEL/CentOS 9 環境中，套件名稱與背後的技術可能會讓人混淆。以下是三者的主要差異：\n\n| 項目 | **docker (Red Hat 套件)** | **docker-ce (Docker Inc. 套件)** | **podman** |\n|------|---------------------------|----------------------------------|------------|\n| **來源** | Red Hat 官方 Repository | Docker 官方 Repository | Red Hat 官方 Repository |\n| **本質** | 其實是 **podman-docker** | 原生 **Docker Engine** | 下一代容器工具 |\n| **守護行程 (Daemon)** | 無 (Daemonless) | **dockerd** (必須啟動服務) | 無 (Daemonless) |\n| **架構** | 模擬 Docker CLI 指令 | Client-Server 架構 | Fork/Exec 模型 |\n| **Root 權限** | 支援 Rootless | 預設需要 Root (Rootless 需設定) | 原生支援 Rootless |\n| **指令相容性** | 高度相容 | 原生指令 | 高度相容 Docker |\n\n!!! warning \"為什麼 `dnf install docker` 裝的是 Podman？\"\n    Red Hat 為了推廣自己的容器技術 (Podman/Buildah/Skopeo)，在 RHEL 8/9 的套件庫中，將 `docker` 套件指向了 `podman-docker`。這個套件主要提供一個 shell script，將 `docker` 指令轉導給 `podman` 執行。\n    \n    若你習慣使用原本的 Docker Daemon (例如需要與舊有的 Docker Compose 流程整合)，則必須移除此套件，並安裝 `docker-ce`。\n\n---\n\n## 實作步驟\n\n### 步驟 1：觀察預設的 Docker 套件 (Podman)\n\n在 RHEL 9 / Rocky Linux 9 中，官方預設的 `docker` 指令其實是 `podman` 的模擬器。\n\n1.  **安裝預設 docker 套件**\n    ```bash\n    dnf install docker -y\n    ```\n    > **指令說明**：\n    > - `dnf`: (Dandified YUM) 是 RHEL 8/9 與 Rocky Linux 的預設套件管理工具，用來取代舊的 `yum`。\n    > - `install`: 安裝套件。\n    > - `-y`: 自動回答 \"Yes\" 確認安裝，不需人工介入。\n\n    ![安裝預設 docker 套件](images/lab02/dnf_install_podman.png)\n\n2.  **檢查 docker 指令來源**\n    ```bash\n    ls -l /usr/bin/docker\n    file /usr/bin/docker\n    cat /usr/bin/docker\n    ```\n    > 你會發現 `/usr/bin/docker` 其實是一個 Shell Script，內容是執行 `/usr/bin/podman`。\n    > ```bash\n    > exec /usr/bin/podman \"$@\"\n    > ```\n\n3.  **嘗試啟動 Docker 服務**\n    ```bash\n    systemctl start docker\n    ```\n    > ❌ **失敗**：因為根本沒有安裝真正的 Docker Daemon，顯示 `Unit docker.service not found`。\n\n4.  **檢查版本**\n    ```bash\n    docker version\n    ```\n    > 輸出顯示 `Client: Podman Engine`，並提示 `Emulate Docker CLI using podman`。\n\n---\n\n### 步驟 2：移除 Podman-Docker 並安裝 Docker CE\n\n為了使用原生的 Docker Engine，我們需要移除模擬套件並安裝官方版本。\n\n1.  **移除預設套件**\n    ```bash\n    dnf remove docker -y\n    ```\n    > 這會移除 `podman-docker` 套件。\n\n2.  **新增 Docker CE Repository**\n    ```bash\n    dnf config-manager --add-repo=https://download.docker.com/linux/centos/docker-ce.repo\n    ```\n    > **指令說明**：\n    > - `config-manager`: `dnf` 的外掛模組，用於管理設定。\n    > - `--add-repo`: 新增一個外部的套件來源 (Repository)。這裡我們指向 Docker 官方為 CentOS 維護的 Repo。\n\n    > 驗證 Repo 是否加入成功：\n    > ```bash\n    > cat /etc/yum.repos.d/docker-ce.repo\n    > ```\n\n3.  **安裝 Docker CE**\n    ```bash\n    dnf install docker-ce -y\n    ```\n    > 安裝過程中會下載 `docker-ce` (Daemon), `docker-ce-cli` (指令工具), `containerd.io` (Runtime) 等套件。\n\n---\n\n### 步驟 3：啟動 Docker 服務\n\n安裝完成後，真正的 Docker Daemon (`dockerd`) 就已經就緒了。\n\n1.  **啟動並設定開機自動啟動**\n    ```bash\n    systemctl start docker\n    systemctl enable docker\n    ```\n    > **指令說明**：\n    > - `systemctl`: 用於管理系統服務 (Systemd)。\n    > - `start`: 立即啟動服務。\n    > - `enable`: 設定服務在開機時自動啟動。\n\n2.  **檢查服務狀態**\n    ```bash\n    systemctl status docker\n    ```\n    > ✅ 應顯示 `Active: active (running)`。\n\n3.  **檢查版本**\n    ```bash\n    docker version\n    ```\n    > 現在應該顯示 `Client: Docker Engine - Community` 和 `Server: Docker Engine - Community`。\n\n---\n\n### 步驟 4：下載與管理 Container Image\n\n1.  **下載映像檔**\n    ```bash\n    docker pull rockylinux:9\n    ```\n\n2.  **查看映像檔列表**\n    ```bash\n    docker images\n    ```\n\n3.  **查看映像檔歷史**\n    ```bash\n    docker history rockylinux:9\n    ```\n\n4.  **備份映像檔 (Docker Save)**\n    將映像檔匯出為 tar 檔案。\n    ```bash\n    docker save --output=/root/rockylinux-9.tar rockylinux:9\n    ls -lh /root/rockylinux-9.tar\n    ```\n\n---\n\n## 小結\n\n在本 Lab 中，我們發現 Linux 發行版可能會用 Podman 來模擬 Docker。若要使用標準 Docker Engine，必須手動設定 Docker 官方 Repository 並安裝 `docker-ce`。\n"
  },
  {
    "title": "Lab03 Podman",
    "url": "https://caocharles.github.io/dcka-class-notes/lab03_podman/",
    "content": "﻿# LAB 03 安裝 Podman\n\n## 學習目標\n\n完成本 Lab 後，你將能夠：\n\n- [ ] 理解 Podman 的核心架構 (Daemonless & Rootless)\n- [ ] 在 Linux 上安裝 Podman\n- [ ] 驗證 Podman 無需守護行程 (Daemon) 即可運作\n- [ ] 處理 Image Registry 搜尋順序與驗證問題\n\n---\n\n## 1.1 Podman 簡介\n\n**Podman** (Pod Manager) 是一個由 Red Hat 開發的開源容器引擎，用於在 Linux 系統上開發、管理和執行 OCI (Open Container Initiative) 容器。\n\n- **官方網站**：[https://podman.io/](https://podman.io/)\n- **最新文件**：[Podman Documentation](https://docs.podman.io/en/latest/)\n\n### Podman 與 Docker 的關鍵差異\n\n| 特性 | Docker | Podman |\n|------|--------|--------|\n| **架構** | **Client-Server** (依賴 dockerd 守護行程) | **Daemonless** (直接 Fork/Exec 程序) |\n| **執行權限** | 預設需要 **Root** | 原生支援 **Rootless** (一般使用者可執行) |\n| **Pod 支援** | 需透過 Docker Compose 或 K8S | **原生支援 Pod** (可在一個 Pod 跑多個容器) |\n| **服務相依** | 若 Daemon 掛掉，所有容器都受影響 | 容器是獨立程序，互不影響 |\n| **Systemd** | 整合較弱 | 原生整合，容易將容器作成系統服務 |\n\n!!! quote \"Podman 的設計理念\"\n    \"Alias docker=podman\" —— Podman 的 CLI 指令與 Docker 高度相容，絕大多數情況下，你可以直接把 `docker` 指令換成 `podman` 執行。\n\n---\n\n## 實作步驟\n\n### 步驟 1：安裝 Podman 套件\n\n在 RHEL 9 / Rocky Linux 9 中，Podman 通常已經預裝。如果沒有，可以使用 `dnf` 安裝。\n\n1.  **安裝 Podman**\n    ```bash\n    dnf install podman -y\n    ```\n    > **指令說明**：\n    > - 套件名稱就是 `podman`，不需要像 Docker 還要去找 `docker-ce`。\n    > - 如果系統顯示 `Nothing to do`，表示已經安裝過了。\n\n    ![安裝 podman](images/lab03/podman_install.png)\n\n2.  **檢查版本與環境資訊**\n    ```bash\n    podman version\n    podman info\n    ```\n    > - `podman version`: 顯示 Client/Server 版本（注意：Podman 的 Client 和 Server 通常是同一個 binary，除非是遠端操作）。\n    > - `podman info`: 顯示詳細的系統設定，包括 Storage Driver (通常是 overlay)、cgroup version (v2) 以及預設的 Registry。\n\n---\n\n### 步驟 2：驗證 Daemonless 架構（無需啟動服務）\n\n這是 Podman 最特別的地方：**你不需要啟動任何服務**。\n\n1.  **嘗試尋找 podman 服務**\n    在你安裝完 Docker 時，通常下一步是 `systemctl start docker`。但在 Podman：\n    \n    > 你**不需要**執行 `systemctl start podman`。\n    \n    Podman 是一個單純的 binary執行檔。當你執行 `podman run` 時，它會直接在當前使用者的權限下產生容器程序。\n\n2.  **為什麼會有 `podman.socket`？**\n    如果你檢查 systemd，可能會看到 `podman.socket` 或 `podman.service`。這主要是為了提供 API 給遠端工具（如 Docker Compose 或 IDE）連線使用，對於本地 CLI 操作並非必要。\n\n---\n\n### 步驟 3：使用 Podman 下載 Container Image\n\nPodman 預設會搜尋多個 Registry。\n\n1.  **查看目前的 Image**\n    ```bash\n    podman images\n    ```\n\n2.  **嘗試下載 MySQL Image**\n    執行以下指令：\n    ```bash\n    podman pull mysql\n    ```\n\n    **觀察輸出結果：**\n    \n    Podman 會依序嘗試設定檔 (`/etc/containers/registries.conf`) 中定義的 Registry：\n\n    1.  ❌ **`registry.access.redhat.com/mysql:latest`**\n        > `name unknown: Repo not found` (Red Hat 官方庫沒有這個 Image)\n    \n    2.  ❌ **`registry.redhat.io/mysql:latest`**\n        > `unauthorized: Please login` (需要 Red Hat 訂閱帳號才能存取)\n    \n    3.  ✅ **`docker.io/library/mysql:latest`**\n        > 成功從 Docker Hub 下載。\n\n3.  **驗證下載結果**\n    ```bash\n    podman images\n    ```\n    > 應該會看到來自 `docker.io/library/mysql` 的 Image。\n\n!!! tip \"Registry 搜尋順序並非隨機\"\n    RHEL/CentOS 預設的 `/etc/containers/registries.conf` 檔案定義了搜尋順序 (Search Registries)。這就是為什麼 Podman 會先去問 Red Hat，最後才問 Docker Hub。\n    而 Docker CE 預設只會找 Docker Hub (`docker.io`)。\n"
  },
  {
    "title": "使用 wget 下載腳本",
    "url": "https://caocharles.github.io/dcka-class-notes/lab04_docker_hub_rate_limit/",
    "content": "﻿# LAB 04 如何檢查 Docker Hub Rate Limiting\n\n## 學習目標\n\n完成本 Lab 後，你將能夠：\n\n- [ ] 理解 Docker Hub 的下載限制 (Rate Limiting)\n- [ ] 使用 `curl` 與 `jq` 指令檢查當前的 Rate Limit 狀態\n- [ ] 比較匿名使用者與免費帳號 (Free Account) 的限制差異\n\n---\n\n## 1.1 什麼是 Docker Hub Rate Limiting？\n\nDocker Hub 為了防止資源濫用，對 Container Image 的 `pull` (下載) 次數進行了限制：\n\n| 帳號類型 | 限制內容 |\n|----------|----------|\n| **匿名使用者 (Anonymous)** | 每 6 小時 **100** 次 pull (以 IP 為準) |\n| **免費帳號 (Free Account)** | 每 6 小時 **200** 次 pull (以帳號為準) |\n| **Pro / Team / Business** | **5000** 次 (每日) 或 無限制 |\n\n當你遇到 `Before you can look around... 429 Too Many Requests` 錯誤時，通常就是被限流了。\n\n---\n\n## 實作步驟\n\n### 步驟 1：安裝必要工具 jq\n\n為了方便解析 Docker Hub API 回傳的 JSON 格式 Token，我們需要安裝 `jq` 工具。\n\n1.  **安裝 jq**\n    ```bash\n    yum install jq -y\n    ```\n    > **指令說明**：`jq` 是一個輕量級且靈活的 command-line JSON 處理器。\n\n    ![安裝 jq 與檢查 limit](images/lab04/check_limit.png)\n\n---\n\n### 步驟 2：下載檢查腳本\n\n我們使用一段 Shell Script 來簡化檢查流程。這個 Script 會向 Docker Hub 申請 Token 並查詢 Header 資訊。\n\n1.  **下載 Script** (假設課堂環境提供)\n    ```bash\n    # 使用 wget 下載腳本\n    wget http://10.0.1.248/k8s/scripts/check_docker_pull_rate_limit.sh\n    \n    # 若上述連結無法連線 (Connection refused)，請嘗試備用位置\n    wget http://10.0.1.249/k8s/scripts/check_docker_pull_rate_limit.sh\n    ```\n\n2.  **賦予執行權限**\n    ```bash\n    chmod 755 check_docker_pull_rate_limit.sh\n    ```\n\n---\n\n### 步驟 3：檢查匿名使用者限制 (Anonymous)\n\n1.  **執行 Script**\n    ```bash\n    ./check_docker_pull_rate_limit.sh\n    ```\n\n2.  **觀察輸出結果**\n    ```yaml\n    ratelimit-limit: 100;w=21600\n    ratelimit-remaining: 58;w=21600\n    docker-ratelimit-source: 118.163.116.129\n    ```\n    > **輸出解析**：\n    > - `ratelimit-limit: 100;w=21600`: 限制為每 21600 秒 (6小時) **100** 次。\n    > - `ratelimit-remaining: 58`: 目前剩餘 **58** 次額度。\n    > - `docker-ratelimit-source`: 識別來源 IP。\n\n---\n\n### 步驟 4：檢查免費帳號限制 (Free Account)\n\n若要獲得更高的額度，可以登入 Docker Hub 帳號。\n\n1.  **修改 Script 加入認證資訊**\n    編輯 `check_docker_pull_rate_limit.sh`，將你的 Docker Hub 帳號密碼填入變數 (或是透過 `docker login` 後修改 Script 以使用 Token)。\n    \n    *假設 Script 支援以變數方式帶入帳密：*\n    ```bash\n    # 編輯腳本填入 USER=\"你的帳號\" PASSWORD=\"你的密碼\"\n    vi check_docker_pull_rate_limit.sh\n    ```\n\n    !!! tip \"手動檢查指令 (參考)\"\n        如果沒有 Script，你也可以用以下指令手動檢查 (記得替換帳密)：\n        ```bash\n        # 1. 取得 Token\n        TOKEN=$(curl -s -u \"你的帳號:你的密碼\" \"https://auth.docker.io/token?service=registry.docker.io&scope=repository:ratelimitpreview/test:pull\" | jq -r .token)\n        \n        # 2. 查詢 Header\n        curl --head -H \"Authorization: Bearer $TOKEN\" https://registry-1.docker.io/v2/ratelimitpreview/test/manifests/latest\n        ```\n\n2.  **再次執行 Script**\n    ```bash\n    ./check_docker_pull_rate_limit.sh\n    ```\n\n3.  **預期結果**\n    ```yaml\n    ratelimit-limit: 200;w=21600   <-- 額度變為 200\n    ratelimit-remaining: 198;w=21600\n    docker-ratelimit-source: [你的帳號UUID]\n    ```\n    > 登入後，`ratelimit-source` 通常會變成你的 User ID，且額度會提升至 **200** 次。\n\n---\n\n## 小結\n\n- **匿名下載**：方便但限制嚴格 (100次/6hr)，多台機器共用 Public IP 時容易被鎖。\n- **登入下載**：建議在 Server 上透過 `docker login` 登入，可將額度提升至 (200次/6hr)，或購買 Pro 方案解除限制。\n"
  },
  {
    "title": "LAB 05 建置 private registry",
    "url": "https://caocharles.github.io/dcka-class-notes/lab05_private_registry/",
    "content": "# LAB 05 建置 private registry\n\n## 學習目標\n\n完成本章節後，你將能夠：\n\n- [ ] 區分 Public Registry 與 Private Registry 的用途\n- [ ] 熟練操作 Docker 基本指令（run、exec、logs、inspect 等）\n- [ ] 設定 Docker 持久化儲存（Volumes 與 Bind Mounts）\n- [ ] 理解並設定 Docker 網路\n- [ ] 從 Docker Hub 搜尋、拉取、推送 Image\n- [ ] 完成 WordPress + MySQL 容器化部署實作\n\n## 前置知識\n\n開始之前，請確保你已經：\n\n- 完成第 1 章的內容\n- Docker 已正確安裝並可執行\n- 理解 Image 與 Container 的關係\n\n---\n\n## 2.1 Public Registry 與 Private Registry\n\n### 什麼是 Registry？\n\nRegistry（倉庫）是用來儲存和分發 Docker Image 的服務。就像 GitHub 儲存程式碼一樣，Registry 儲存容器映像檔。\n\n```mermaid\ngraph LR\n    Dev[開發者] -->|push| Registry[(Registry)]\n    Registry -->|pull| Server1[伺服器 1]\n    Registry -->|pull| Server2[伺服器 2]\n    Registry -->|pull| Server3[伺服器 3]\n```\n\n### Public Registry\n\n公開的 Registry 服務，任何人都可以存取公開的 Image。\n\n| Registry | 說明 | 網址 |\n|----------|------|------|\n| **Docker Hub** | 官方預設 Registry，最大的公開 Image 倉庫 | hub.docker.com |\n| **Quay.io** | Red Hat 提供的 Registry | quay.io |\n| **GitHub Container Registry** | GitHub 提供的容器 Registry | ghcr.io |\n| **Google Container Registry** | Google Cloud 提供 | gcr.io |\n| **Amazon ECR Public** | AWS 提供的公開 Registry | public.ecr.aws |\n\n!!! tip \"Docker Hub 使用技巧\"\n    - **官方 Image**：沒有前綴，如 `nginx`、`mysql`、`redis`\n    - **社群 Image**：包含使用者名稱，如 `bitnami/nginx`\n    - **標籤**：指定版本，如 `nginx:1.25`、`nginx:alpine`\n\n### Private Registry\n\n私有 Registry 用於儲存企業內部的 Image，不對外公開。\n\n#### 常見私有 Registry 方案\n\n| 方案 | 說明 | 適用場景 |\n|------|------|----------|\n| **Docker Registry** | Docker 官方提供的輕量級 Registry | 小型團隊、測試環境 |\n| **Harbor** | VMware 開源的企業級 Registry | 大型企業、需要 RBAC |\n| **Nexus Repository** | Sonatype 的多功能倉庫 | 已使用 Nexus 管理套件 |\n| **JFrog Artifactory** | 企業級製品管理 | 大型企業 |\n| **AWS ECR** | AWS 私有 Registry | AWS 雲端環境 |\n| **Azure ACR** | Azure 私有 Registry | Azure 雲端環境 |\n| **GCP GCR** | Google 私有 Registry | GCP 雲端環境 |\n\n#### 建立簡易 Private Registry\n\n```bash title=\"使用 Docker 建立私有 Registry\"\n# 啟動 Registry Container\ndocker run -d \\\n  --name my-registry \\\n  -p 5000:5000 \\\n  -v registry-data:/var/lib/registry \\\n  registry:2\n\n# 為 Image 加上私有 Registry 標籤\ndocker tag nginx:latest localhost:5000/my-nginx:v1\n\n# 推送到私有 Registry\ndocker push localhost:5000/my-nginx:v1\n\n# 從私有 Registry 拉取\ndocker pull localhost:5000/my-nginx:v1\n```\n\n!!! warning \"生產環境注意事項\"\n    - 私有 Registry 應配置 TLS 憑證\n    - 設定適當的存取控制\n    - 定期備份 Registry 資料\n    - 考慮使用企業級方案如 Harbor\n\n---\n\n## 2.2 Docker 基本操作\n\n### Container 生命週期管理\n\n```mermaid\nstateDiagram-v2\n    [*] --> Created: docker create\n    Created --> Running: docker start\n    Running --> Paused: docker pause\n    Paused --> Running: docker unpause\n    Running --> Stopped: docker stop\n    Stopped --> Running: docker start\n    Stopped --> Removed: docker rm\n    Running --> Removed: docker rm -f\n    Removed --> [*]\n```\n\n### 核心指令詳解\n\n#### docker run - 執行容器\n\n```bash title=\"docker run 常用選項\"\n# 基本執行\ndocker run nginx\n\n# 背景執行 (detached)\ndocker run -d nginx\n\n# 指定名稱\ndocker run -d --name my-nginx nginx\n\n# Port 對應 (主機:容器)\ndocker run -d -p 8080:80 nginx\n\n# 環境變數\ndocker run -d -e MYSQL_ROOT_PASSWORD=secret mysql\n\n# 自動刪除（結束後自動移除）\ndocker run --rm nginx echo \"Hello\"\n\n# 互動模式\ndocker run -it ubuntu /bin/bash\n\n# 資源限制\ndocker run -d --memory=\"512m\" --cpus=\"1.0\" nginx\n\n# 重啟策略\ndocker run -d --restart=always nginx\n```\n\n!!! note \"docker run 選項說明\"\n    | 選項 | 說明 |\n    |------|------|\n    | `-d` | Detached mode，背景執行 |\n    | `-it` | 互動模式 + TTY |\n    | `-p` | Port mapping |\n    | `-v` | Volume mapping |\n    | `-e` | 環境變數 |\n    | `--name` | 指定容器名稱 |\n    | `--rm` | 結束後自動刪除 |\n    | `--restart` | 重啟策略 |\n\n#### docker exec - 執行指令\n\n```bash title=\"在運行中的容器執行指令\"\n# 執行單一指令\ndocker exec my-nginx cat /etc/nginx/nginx.conf\n\n# 進入互動式 Shell\ndocker exec -it my-nginx /bin/bash\n\n# 以特定使用者執行\ndocker exec -u root my-nginx whoami\n\n# 設定環境變數\ndocker exec -e VAR=value my-nginx printenv VAR\n```\n\n#### docker logs - 檢視日誌\n\n```bash title=\"Container 日誌操作\"\n# 檢視全部日誌\ndocker logs my-nginx\n\n# 持續追蹤日誌\ndocker logs -f my-nginx\n\n# 顯示最後 N 行\ndocker logs --tail 100 my-nginx\n\n# 顯示時間戳記\ndocker logs -t my-nginx\n\n# 指定時間範圍\ndocker logs --since 2024-01-01 my-nginx\ndocker logs --since 10m my-nginx  # 最近 10 分鐘\n```\n\n#### docker inspect - 檢視詳細資訊\n\n```bash title=\"檢視容器/映像檔詳細資訊\"\n# 檢視容器詳細資訊（JSON 格式）\ndocker inspect my-nginx\n\n# 取得特定資訊（使用 Go 模板）\ndocker inspect --format='{{.NetworkSettings.IPAddress}}' my-nginx\n\n# 取得 Port 對應\ndocker inspect --format='{{range $p, $conf := .NetworkSettings.Ports}}{{$p}} -> {{(index $conf 0).HostPort}}{{end}}' my-nginx\n\n# 取得掛載資訊\ndocker inspect --format='{{json .Mounts}}' my-nginx | jq .\n```\n\n#### 其他常用指令\n\n```bash title=\"容器管理指令\"\n# 列出運行中的容器\ndocker ps\n\n# 列出所有容器（包含已停止）\ndocker ps -a\n\n# 停止容器\ndocker stop my-nginx\n\n# 啟動已停止的容器\ndocker start my-nginx\n\n# 重啟容器\ndocker restart my-nginx\n\n# 刪除容器\ndocker rm my-nginx\n\n# 強制刪除運行中的容器\ndocker rm -f my-nginx\n\n# 刪除所有已停止的容器\ndocker container prune\n\n# 檢視容器資源使用\ndocker stats\n\n# 複製檔案到容器\ndocker cp ./index.html my-nginx:/usr/share/nginx/html/\n\n# 從容器複製檔案\ndocker cp my-nginx:/etc/nginx/nginx.conf ./nginx.conf\n```\n\n---\n\n## 2.3 Persistent Storage\n\n### 為什麼需要持久化儲存？\n\nContainer 預設的資料是短暫的（ephemeral），當 Container 被刪除時，所有資料都會消失。\n\n```mermaid\ngraph LR\n    subgraph \"沒有持久化\"\n        C1[Container] --> RW1[讀寫層]\n        RW1 -.->|刪除容器| X[資料消失]\n    end\n    \n    subgraph \"使用持久化\"\n        C2[Container] --> RW2[讀寫層]\n        C2 --> V[Volume/Bind Mount]\n        V -->|容器刪除| V\n    end\n```\n\n### 三種儲存方式\n\n| 類型 | 說明 | 適用場景 |\n|------|------|----------|\n| **Volume** | 由 Docker 管理的儲存區域 | 生產環境、資料持久化 |\n| **Bind Mount** | 將主機目錄掛載到容器 | 開發環境、程式碼同步 |\n| **tmpfs Mount** | 儲存在主機記憶體中 | 暫存敏感資料 |\n\n### Volumes\n\n```bash title=\"Volume 基本操作\"\n# 建立 Volume\ndocker volume create my-data\n\n# 列出所有 Volume\ndocker volume ls\n\n# 檢視 Volume 詳細資訊\ndocker volume inspect my-data\n\n# 使用 Volume 執行容器\ndocker run -d \\\n  --name my-nginx \\\n  -v my-data:/usr/share/nginx/html \\\n  nginx\n\n# 刪除 Volume\ndocker volume rm my-data\n\n# 清理未使用的 Volume\ndocker volume prune\n```\n\n!!! tip \"Volume 位置\"\n    Docker Volume 預設儲存在：\n    \n    - **Linux**: `/var/lib/docker/volumes/`\n    - **macOS/Windows**: Docker Desktop 管理的虛擬磁碟內\n\n### Bind Mounts\n\n```bash title=\"Bind Mount 使用方式\"\n# 使用 -v 語法\ndocker run -d \\\n  --name my-nginx \\\n  -v /path/on/host:/usr/share/nginx/html \\\n  -p 8080:80 \\\n  nginx\n\n# 使用 --mount 語法（推薦）\ndocker run -d \\\n  --name my-nginx \\\n  --mount type=bind,source=/path/on/host,target=/usr/share/nginx/html \\\n  -p 8080:80 \\\n  nginx\n\n# 唯讀掛載\ndocker run -d \\\n  --name my-nginx \\\n  -v /path/on/host:/usr/share/nginx/html:ro \\\n  nginx\n```\n\n!!! example \"開發環境範例\"\n    ```bash title=\"前端開發即時同步\"\n    # 將本地專案目錄掛載到容器\n    docker run -d \\\n      --name frontend-dev \\\n      -v $(pwd)/src:/app/src \\\n      -p 3000:3000 \\\n      node:18\n    ```\n    \n    修改本地 `src` 目錄的檔案會立即反映到容器中。\n\n### Volume vs Bind Mount 比較\n\n| 比較項目 | Volume | Bind Mount |\n|----------|--------|------------|\n| 儲存位置 | Docker 管理 | 指定主機路徑 |\n| 可移植性 | 高 | 依賴主機路徑 |\n| 效能 | 較佳 | 取決於主機檔案系統 |\n| 備份 | 容易 | 需手動處理 |\n| 適用場景 | 生產環境 | 開發環境 |\n\n---\n\n## 2.4 Docker Network\n\n### 預設網路類型\n\nDocker 提供多種網路驅動，滿足不同的使用場景。\n\n```mermaid\ngraph TB\n    subgraph \"Bridge Network（預設）\"\n        B_C1[Container 1] --- B_NET[docker0 bridge]\n        B_C2[Container 2] --- B_NET\n        B_NET --- B_HOST[Host Network Stack]\n    end\n    \n    subgraph \"Host Network\"\n        H_C[Container] --- H_HOST[Host Network Stack]\n    end\n    \n    subgraph \"None Network\"\n        N_C[Container - 無網路]\n    end\n```\n\n| 網路類型 | 說明 | 適用場景 |\n|----------|------|----------|\n| **bridge** | 預設網路，Container 透過虛擬橋接器連接 | 單機多容器通訊 |\n| **host** | Container 直接使用主機網路 | 需要最高網路效能 |\n| **none** | 無網路連接 | 安全隔離需求 |\n| **overlay** | 跨主機容器通訊 | Docker Swarm 叢集 |\n| **macvlan** | 分配真實 MAC 地址 | 需要直接連接實體網路 |\n\n### 網路基本操作\n\n```bash title=\"Docker 網路管理\"\n# 列出所有網路\ndocker network ls\n\n# 檢視網路詳細資訊\ndocker network inspect bridge\n\n# 建立自訂網路\ndocker network create my-network\n\n# 建立指定子網路的網路\ndocker network create \\\n  --driver bridge \\\n  --subnet 172.20.0.0/16 \\\n  --gateway 172.20.0.1 \\\n  my-custom-network\n\n# 刪除網路\ndocker network rm my-network\n\n# 清理未使用的網路\ndocker network prune\n```\n\n### 容器連接網路\n\n```bash title=\"容器網路連接\"\n# 執行容器時指定網路\ndocker run -d --name app1 --network my-network nginx\n\n# 將運行中的容器連接到網路\ndocker network connect my-network container-name\n\n# 將容器從網路斷開\ndocker network disconnect my-network container-name\n```\n\n### 容器間通訊\n\n!!! tip \"使用自訂網路實現容器間通訊\"\n    在同一個自訂網路中的容器，可以使用**容器名稱**作為 hostname 互相存取。\n\n```bash title=\"容器間通訊範例\"\n# 建立網路\ndocker network create app-network\n\n# 啟動 MySQL Container\ndocker run -d \\\n  --name mysql-db \\\n  --network app-network \\\n  -e MYSQL_ROOT_PASSWORD=secret \\\n  mysql:8\n\n# 啟動應用程式 Container，使用 mysql-db 作為資料庫主機\ndocker run -d \\\n  --name my-app \\\n  --network app-network \\\n  -e DB_HOST=mysql-db \\\n  -e DB_PASSWORD=secret \\\n  my-application\n\n# 測試連線\ndocker exec my-app ping mysql-db\n```\n\n### Port 對應\n\n```bash title=\"Port Mapping\"\n# 對應單一 Port\ndocker run -d -p 8080:80 nginx\n\n# 對應多個 Port\ndocker run -d -p 8080:80 -p 8443:443 nginx\n\n# 對應到所有介面的隨機 Port\ndocker run -d -P nginx\n\n# 只對應到 localhost\ndocker run -d -p 127.0.0.1:8080:80 nginx\n\n# 對應 UDP Port\ndocker run -d -p 53:53/udp dns-server\n```\n\n---\n\n## 2.5 Docker Search\n\n### 搜尋 Image\n\n```bash title=\"搜尋 Docker Hub\"\n# 基本搜尋\ndocker search nginx\n\n# 限制結果數量\ndocker search --limit 5 nginx\n\n# 只顯示官方 Image\ndocker search --filter is-official=true nginx\n\n# 只顯示自動建置的 Image\ndocker search --filter is-automated=true nginx\n\n# 根據星星數過濾\ndocker search --filter stars=100 nginx\n```\n\n**搜尋結果說明**：\n\n| 欄位 | 說明 |\n|------|------|\n| NAME | Image 名稱 |\n| DESCRIPTION | 描述 |\n| STARS | 星星數（人氣指標） |\n| OFFICIAL | 是否為官方 Image |\n| AUTOMATED | 是否自動建置 |\n\n!!! tip \"選擇 Image 的建議\"\n    1. 優先選擇**官方 Image**（OFFICIAL = [OK]）\n    2. 查看**星星數**和**下載次數**\n    3. 到 Docker Hub 網站查看**文件**和**更新頻率**\n    4. 檢查 Image 的**安全掃描結果**\n\n---\n\n## 2.6 Docker Pull\n\n### 拉取 Image\n\n```bash title=\"拉取 Image\"\n# 拉取最新版本（預設 latest tag）\ndocker pull nginx\n\n# 拉取特定版本\ndocker pull nginx:1.25\n\n# 拉取特定版本（alpine 輕量版）\ndocker pull nginx:alpine\n\n# 從其他 Registry 拉取\ndocker pull quay.io/bitnami/nginx\n\n# 拉取特定平台的 Image\ndocker pull --platform linux/amd64 nginx\n```\n\n### Image 標籤（Tag）\n\n```mermaid\ngraph LR\n    N[nginx] --> L[latest]\n    N --> V1[1.25]\n    N --> V2[1.25.3]\n    N --> A[alpine]\n    N --> VA[1.25-alpine]\n```\n\n!!! warning \"避免使用 latest\"\n    - `latest` 標籤會隨時間變化\n    - 生產環境應使用**明確版本號**\n    - 例如：`nginx:1.25.3` 而非 `nginx:latest`\n\n### 管理本地 Image\n\n```bash title=\"Image 管理指令\"\n# 列出本地 Image\ndocker images\n\n# 列出所有 Image（包含中間層）\ndocker images -a\n\n# 檢視 Image 詳細資訊\ndocker image inspect nginx\n\n# 檢視 Image 歷史（分層）\ndocker history nginx\n\n# 刪除 Image\ndocker rmi nginx\n\n# 刪除未使用的 Image\ndocker image prune\n\n# 刪除所有未使用的 Image（包含未標記的）\ndocker image prune -a\n```\n\n---\n\n## 2.7 Docker Push\n\n### 推送 Image 到 Registry\n\n#### 推送到 Docker Hub\n\n```bash title=\"推送到 Docker Hub\"\n# 1. 登入 Docker Hub\ndocker login\n\n# 2. 為 Image 加上標籤（必須包含使用者名稱）\ndocker tag my-app:v1 username/my-app:v1\n\n# 3. 推送 Image\ndocker push username/my-app:v1\n\n# 4. 登出（選用）\ndocker logout\n```\n\n#### 推送到私有 Registry\n\n```bash title=\"推送到私有 Registry\"\n# 1. 登入私有 Registry\ndocker login my-registry.example.com\n\n# 2. 為 Image 加上私有 Registry 標籤\ndocker tag my-app:v1 my-registry.example.com/my-app:v1\n\n# 3. 推送\ndocker push my-registry.example.com/my-app:v1\n```\n\n!!! note \"Image 命名規則\"\n    ```\n    [registry/][username/]repository[:tag]\n    ```\n    \n    例如：\n    \n    - `nginx` = `docker.io/library/nginx:latest`\n    - `bitnami/nginx` = `docker.io/bitnami/nginx:latest`\n    - `gcr.io/project/app:v1`\n\n### 標籤管理\n\n```bash title=\"Image 標籤操作\"\n# 加上新標籤\ndocker tag my-app:v1 my-app:latest\ndocker tag my-app:v1 my-app:stable\n\n# 推送多個標籤\ndocker push my-app:v1\ndocker push my-app:latest\ndocker push my-app:stable\n```\n\n---\n\n## 2.8 使用 Docker 架設 WordPress + MySQL\n\n### Lab 實作目標\n\n部署一個完整的 WordPress 網站，包含：\n\n- MySQL 資料庫容器\n- WordPress 應用程式容器\n- 使用 Docker Network 連接\n- 使用 Volume 持久化資料\n\n### 架構圖\n\n```mermaid\ngraph TB\n    subgraph \"Docker 環境\"\n        subgraph \"wp-network\"\n            WP[WordPress<br/>Port: 8080] -->|連接| DB[(MySQL<br/>Port: 3306)]\n        end\n        WP_VOL[wordpress-data<br/>Volume] --> WP\n        DB_VOL[mysql-data<br/>Volume] --> DB\n    end\n    \n    User[使用者] -->|http://localhost:8080| WP\n```\n\n### 實作步驟\n\n#### 步驟 1：建立網路\n\n```bash title=\"建立專用網路\"\ndocker network create wp-network\n```\n\n#### 步驟 2：啟動 MySQL 容器\n\n```bash title=\"啟動 MySQL\"\ndocker run -d \\\n  --name wp-mysql \\\n  --network wp-network \\\n  -v mysql-data:/var/lib/mysql \\\n  -e MYSQL_ROOT_PASSWORD=rootpassword \\\n  -e MYSQL_DATABASE=wordpress \\\n  -e MYSQL_USER=wpuser \\\n  -e MYSQL_PASSWORD=wppassword \\\n  mysql:8.0\n```\n\n!!! note \"MySQL 環境變數說明\"\n    | 環境變數 | 說明 |\n    |----------|------|\n    | `MYSQL_ROOT_PASSWORD` | root 密碼（必填） |\n    | `MYSQL_DATABASE` | 自動建立的資料庫 |\n    | `MYSQL_USER` | 自動建立的使用者 |\n    | `MYSQL_PASSWORD` | 使用者密碼 |\n\n#### 步驟 3：啟動 WordPress 容器\n\n```bash title=\"啟動 WordPress\"\ndocker run -d \\\n  --name wp-app \\\n  --network wp-network \\\n  -p 8080:80 \\\n  -v wordpress-data:/var/www/html \\\n  -e WORDPRESS_DB_HOST=wp-mysql:3306 \\\n  -e WORDPRESS_DB_NAME=wordpress \\\n  -e WORDPRESS_DB_USER=wpuser \\\n  -e WORDPRESS_DB_PASSWORD=wppassword \\\n  wordpress:latest\n```\n\n#### 步驟 4：驗證部署\n\n```bash title=\"驗證容器狀態\"\n# 檢查容器是否運行\ndocker ps\n\n# 檢查容器日誌\ndocker logs wp-mysql\ndocker logs wp-app\n\n# 測試 MySQL 連線\ndocker exec wp-mysql mysql -uwpuser -pwppassword -e \"SHOW DATABASES;\"\n```\n\n#### 步驟 5：存取 WordPress\n\n開啟瀏覽器，前往 `http://localhost:8080`，完成 WordPress 安裝精靈。\n\n### 使用 Docker Compose（額外說明）\n\n!!! tip \"更簡潔的方式\"\n    使用 Docker Compose 可以將以上所有設定集中在一個檔案中。\n\n```yaml title=\"docker-compose.yml\"\nversion: '3.8'\n\nservices:\n  db:\n    image: mysql:8.0\n    container_name: wp-mysql\n    volumes:\n      - mysql-data:/var/lib/mysql\n    environment:\n      MYSQL_ROOT_PASSWORD: rootpassword\n      MYSQL_DATABASE: wordpress\n      MYSQL_USER: wpuser\n      MYSQL_PASSWORD: wppassword\n    networks:\n      - wp-network\n\n  wordpress:\n    image: wordpress:latest\n    container_name: wp-app\n    depends_on:\n      - db\n    ports:\n      - \"8080:80\"\n    volumes:\n      - wordpress-data:/var/www/html\n    environment:\n      WORDPRESS_DB_HOST: db:3306\n      WORDPRESS_DB_NAME: wordpress\n      WORDPRESS_DB_USER: wpuser\n      WORDPRESS_DB_PASSWORD: wppassword\n    networks:\n      - wp-network\n\nnetworks:\n  wp-network:\n    driver: bridge\n\nvolumes:\n  mysql-data:\n  wordpress-data:\n```\n\n```bash title=\"使用 Docker Compose 啟動\"\n# 啟動所有服務\ndocker compose up -d\n\n# 檢視狀態\ndocker compose ps\n\n# 檢視日誌\ndocker compose logs -f\n\n# 停止並移除\ndocker compose down\n\n# 停止並移除（包含 Volume）\ndocker compose down -v\n```\n\n### 清理資源\n\n```bash title=\"清理實作環境\"\n# 停止容器\ndocker stop wp-app wp-mysql\n\n# 刪除容器\ndocker rm wp-app wp-mysql\n\n# 刪除網路\ndocker network rm wp-network\n\n# 刪除 Volume（警告：會刪除所有資料）\ndocker volume rm mysql-data wordpress-data\n```\n\n---\n\n## 常見問題\n\n??? question \"Q1：Container 啟動後立即退出怎麼辦？\"\n    **診斷步驟**：\n    ```bash\n    # 檢視容器日誌\n    docker logs container-name\n    \n    # 檢視容器詳細資訊\n    docker inspect container-name\n    \n    # 檢視最後退出狀態\n    docker ps -a --filter \"name=container-name\"\n    ```\n    \n    **常見原因**：\n    \n    - 啟動指令錯誤\n    - 環境變數缺失\n    - 依賴服務未就緒\n    - 設定檔錯誤\n\n??? question \"Q2：如何讓容器在主機重啟後自動啟動？\"\n    **解決方案**：使用 `--restart` 選項\n    ```bash\n    # always: 總是重啟\n    docker run -d --restart=always nginx\n    \n    # unless-stopped: 除非手動停止\n    docker run -d --restart=unless-stopped nginx\n    \n    # on-failure: 只在異常退出時重啟\n    docker run -d --restart=on-failure:3 nginx\n    ```\n\n??? question \"Q3：Volume 資料如何備份？\"\n    **解決方案**：\n    ```bash\n    # 方法 1：使用臨時容器備份\n    docker run --rm \\\n      -v mysql-data:/source:ro \\\n      -v $(pwd):/backup \\\n      alpine tar cvf /backup/mysql-backup.tar /source\n    \n    # 方法 2：使用 docker cp（需要先掛載到容器）\n    docker cp container-name:/var/lib/mysql ./mysql-backup\n    ```\n\n??? question \"Q4：如何查看 Docker 佔用的磁碟空間？\"\n    **解決方案**：\n    ```bash\n    # 檢視整體使用情況\n    docker system df\n    \n    # 詳細資訊\n    docker system df -v\n    \n    # 清理未使用的資源\n    docker system prune\n    \n    # 清理所有未使用資源（包含 Volume）\n    docker system prune -a --volumes\n    ```\n\n??? question \"Q5：容器間無法通訊怎麼辦？\"\n    **診斷步驟**：\n    ```bash\n    # 1. 確認容器在同一個網路\n    docker network inspect my-network\n    \n    # 2. 確認容器 IP\n    docker inspect --format='{{.NetworkSettings.IPAddress}}' container-name\n    \n    # 3. 在容器內測試連線\n    docker exec container1 ping container2\n    \n    # 4. 確認 Port 是否開放\n    docker exec container1 nc -zv container2 port\n    ```\n\n---\n\n## 小結\n\n本章節重點回顧：\n\n- ✅ **Registry 類型**：Public Registry（如 Docker Hub）與 Private Registry（如 Harbor）\n- ✅ **Container 管理**：run、exec、logs、inspect 等核心指令\n- ✅ **持久化儲存**：Volume（Docker 管理）vs Bind Mount（主機目錄）\n- ✅ **Docker 網路**：bridge、host、none 網路類型，自訂網路實現容器間通訊\n- ✅ **Image 操作**：search、pull、push、tag 完整流程\n- ✅ **實作經驗**：WordPress + MySQL 容器化部署\n\n## 延伸閱讀\n\n- [Docker 官方文件 - Storage](https://docs.docker.com/storage/)\n- [Docker 官方文件 - Networking](https://docs.docker.com/network/)\n- [Docker Hub 官方網站](https://hub.docker.com/)\n- [Harbor - 企業級 Registry](https://goharbor.io/)\n- [Docker Compose 官方文件](https://docs.docker.com/compose/)\n"
  },
  {
    "title": "Lab06 Docker Basics",
    "url": "https://caocharles.github.io/dcka-class-notes/lab06_docker_basics/",
    "content": "﻿# LAB 06 docker 基本操作\n\n## 學習目標\n\n- [ ] 待補\n\n## 實作步驟\n\n*(本章節內容待補)*\n\n"
  },
  {
    "title": "Lab07 Persistent Storage",
    "url": "https://caocharles.github.io/dcka-class-notes/lab07_persistent_storage/",
    "content": "﻿# LAB 07 Persistent Storage\n\n## 學習目標\n\n- [ ] 待補\n\n## 實作步驟\n\n*(本章節內容待補)*\n\n"
  },
  {
    "title": "Lab08 Wordpress",
    "url": "https://caocharles.github.io/dcka-class-notes/lab08_wordpress/",
    "content": "﻿# LAB 08 架設部落格 - wordpress\n\n## 學習目標\n\n- [ ] 待補\n\n## 實作步驟\n\n*(本章節內容待補)*\n\n"
  },
  {
    "title": "LAB 09 客製化 Container Images - docker commit",
    "url": "https://caocharles.github.io/dcka-class-notes/lab09_commit/",
    "content": "---\nauthors:\n  - name: 課程作者\n    email: author@example.com\ndate: 2026-01-27\nupdated: 2026-01-27\ntags:\n  - Docker\n  - Container\n  - Image\n---\n\n# LAB 09 客製化 Container Images - docker commit\n\n## 學習目標\n\n完成本章節後，你將能夠：\n\n- [ ] 使用 `docker commit` 從容器建立新的 Image\n- [ ] 使用 `docker save` 將 Image 匯出為 tar 檔\n- [ ] 使用 `docker load` 從 tar 檔載入 Image\n- [ ] 建立清理 Docker 環境的腳本\n\n## 前置知識\n\n開始之前，請確保你已經：\n\n- 完成 LAB 06 的內容\n- 熟悉 Docker 基本操作\n- 已設定 Private Registry（docker1.training.lab:5000）\n\n---\n\n## 9.1 環境準備\n\n### 切換到 docker2 虛擬機\n\n本 Lab 在 docker2 虛擬機上執行。\n\n### 確認現有環境\n\n```bash title=\"檢視現有的 Container Images\"\ndocker images\n```\n\n**預期結果**：\n\n```\nIMAGE                                   ID             DISK USAGE   CONTENT SIZE   EXTRA\n192.168.66.51:5000/nginx:1.9.1          667cfe3b0942        289MB          139MB        \ndocker1.training.lab:5000/nginx:1.7.1   b1590b02702d       1.06GB          515MB        \n```\n\n```bash title=\"檢視現有的 Container\"\ndocker ps -a\n```\n\n**預期結果**：\n\n```\nCONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES\n```\n\n### 建立清理腳本\n\n建立一個腳本來清理所有 Container 與 Image：\n\n```bash title=\"建立 docker_clean_all.sh\"\nvi docker_clean_all.sh\n```\n\n腳本內容：\n\n```bash title=\"docker_clean_all.sh\"\n#!/bin/bash\n# 停止並刪除所有 Container\ndocker stop $(docker ps -aq)\ndocker rm $(docker ps -aq)\n# 刪除所有 Image\ndocker rmi $(docker images -q)\n```\n\n!!! note \"腳本說明\"\n    - `docker ps -aq`：列出所有 Container 的 ID（`-a` 包含已停止的，`-q` 只顯示 ID）\n    - `docker images -q`：列出所有 Image 的 ID\n    - 如果沒有 Container 或 Image，指令會顯示錯誤訊息，但不影響後續操作\n\n```bash title=\"設定執行權限\"\nchmod 755 ./docker_clean_all.sh\n```\n\n```bash title=\"執行清理腳本\"\n./docker_clean_all.sh\n```\n\n**預期結果**：\n\n```\ndocker: 'docker stop' requires at least 1 argument\ndocker: 'docker rm' requires at least 1 argument\nUntagged: 192.168.66.51:5000/nginx:1.9.1\nDeleted: sha256:667cfe3b094262dcd2323f28a800d8376221b017a9dd14b6fff78e4ec96a6177\nUntagged: docker1.training.lab:5000/nginx:1.7.1\nDeleted: sha256:b1590b02702d926755e02ca8f01baa42c9789758a3fb6d40aa87bdcfe871965d\n```\n\n!!! info \"錯誤訊息說明\"\n    當沒有 Container 時，`docker stop` 和 `docker rm` 會顯示錯誤訊息，這是正常的，不影響後續操作。\n\n---\n\n## 9.2 下載 Docker Image\n\n### 從 Private Registry 下載 Alpine\n\n```bash title=\"下載 Alpine Image\"\ndocker pull docker1.training.lab:5000/alpine\n```\n\n**預期結果**：\n\n```\nUsing default tag: latest\nlatest: Pulling from alpine\n77cae8ab23bf: Pull complete \nDigest: sha256:d0a0f8e7bf9a6287c7dab568b947b6c3dd6b84e9c67ab9f1e95f79751d808641\nStatus: Downloaded newer image for docker1.training.lab:5000/alpine:latest\ndocker1.training.lab:5000/alpine:latest\n```\n\n!!! note \"docker pull 說明\"\n    - 如果沒有指定 tag，預設會使用 `latest`\n    - 從 Private Registry 下載需要指定完整的 Registry 位址\n\n```bash title=\"確認 Image 已下載\"\ndocker images\n```\n\n**預期結果**：\n\n```\nIMAGE                                     ID             DISK USAGE   CONTENT SIZE   EXTRA\ndocker1.training.lab:5000/alpine:latest   d0a0f8e7bf9a       11.6MB         5.82MB        \n```\n\n---\n\n## 9.3 進入 Alpine 執行 sh\n\n### 啟動互動式 Container\n\n```bash title=\"啟動 Alpine Container\"\ndocker run -it --name alpine-1 docker1.training.lab:5000/alpine:latest\n```\n\n!!! note \"docker run 參數說明\"\n    | 參數 | 說明 |\n    |------|------|\n    | `-i` | 保持 STDIN 開啟（interactive） |\n    | `-t` | 分配虛擬終端機（tty） |\n    | `--name alpine-1` | 指定 Container 名稱 |\n\n進入容器後會看到提示符號 `/ #`，表示已在 Container 內部。\n\n---\n\n## 9.4 在 Alpine 中安裝 Bash\n\n### 測試 Bash 是否存在\n\n```bash title=\"測試 bash（在 Container 內執行）\"\nbash\n```\n\n**預期結果**：\n\n```\n/bin/sh: bash: not found\n```\n\n!!! info \"為什麼 Alpine 沒有 Bash？\"\n    Alpine Linux 是一個極輕量的 Linux 發行版，使用 BusyBox 作為核心工具集，預設只提供 `/bin/sh`（ash shell）以維持極小的映像大小（約 5MB）。\n\n### 使用 apk 安裝 Bash\n\n```bash title=\"安裝 bash（在 Container 內執行）\"\napk add --no-cache --update-cache bash\n```\n\n**預期結果**：\n\n```\nfetch http://dl-cdn.alpinelinux.org/alpine/v3.10/main/x86_64/APKINDEX.tar.gz\nfetch http://dl-cdn.alpinelinux.org/alpine/v3.10/community/x86_64/APKINDEX.tar.gz\n(1/4) Installing ncurses-terminfo-base (6.1_p20190518-r2)\n(2/4) Installing ncurses-libs (6.1_p20190518-r2)\n(3/4) Installing readline (8.0.0-r0)\n(4/4) Installing bash (5.0.0-r0)\nExecuting bash-5.0.0-r0.post-install\nExecuting busybox-1.30.1-r2.trigger\nOK: 8 MiB in 18 packages\n```\n\n!!! tip \"apk 參數說明\"\n    | 參數 | 說明 |\n    |------|------|\n    | `add` | 安裝套件 |\n    | `--no-cache` | 不使用本地快取，減少 Image 大小 |\n    | `--update-cache` | 更新套件索引 |\n\n### 驗證安裝成功\n\n```bash title=\"切換到 bash（在 Container 內執行）\"\nbash\n```\n\n**預期結果**：\n\n成功進入 bash，提示符號變成 `bash-5.0#`\n\n```bash title=\"退出 Container\"\nexit  # 退出 bash\nexit  # 退出 Container\n```\n\n---\n\n## 9.5 Commit 新的 Container Image\n\n### 使用 docker commit 建立新 Image\n\n```bash title=\"建立新 Image\"\ndocker commit -m \"alpine + bash\" alpine-1 alpine-bash\n```\n\n**預期結果**：\n\n```\nsha256:4326afd8916bbf220fcb95d27fd5cac5096b74fa6ccba7c8929d5a70820875ec\n```\n\n!!! note \"docker commit 語法\"\n    ```\n    docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]\n    ```\n    \n    | 參數 | 說明 |\n    |------|------|\n    | `-m` | 提交訊息（描述變更內容） |\n    | `-a` | 指定作者（可選） |\n    | `alpine-1` | 來源 Container 名稱 |\n    | `alpine-bash` | 新 Image 名稱（預設 tag 為 latest） |\n\n```bash title=\"確認新 Image 已建立\"\ndocker images\n```\n\n**預期結果**：\n\n```\nIMAGE                                     ID             DISK USAGE   CONTENT SIZE   EXTRA\nalpine-bash:latest                        4326afd8916b       14.5MB          6.6MB        \ndocker1.training.lab:5000/alpine:latest   d0a0f8e7bf9a       11.6MB         5.82MB    U   \n```\n\n!!! info \"Image 大小變化\"\n    安裝 Bash 後，Image 從 5.82MB 增加到 6.6MB，增加約 0.78MB（主要是 Bash 及其相依套件）。\n\n---\n\n## 9.6 匯出並壓縮為 Tar Ball 檔案\n\n### 使用 docker save 匯出 Image\n\n```bash title=\"匯出 Image 為 tar 檔\"\ndocker save --output=alpine-bash.tar alpine-bash\n```\n\n!!! note \"docker save 語法\"\n    ```\n    docker save [OPTIONS] IMAGE [IMAGE...]\n    ```\n    \n    | 參數 | 說明 |\n    |------|------|\n    | `--output` 或 `-o` | 指定輸出檔案名稱 |\n    | 可一次匯出多個 Image | |\n\n```bash title=\"確認 tar 檔案大小\"\nls -lh alpine-bash.tar\n```\n\n**預期結果**：\n\n```\n-rw------- 1 root root 6.3M Jan 27 11:05 alpine-bash.tar\n```\n\n### 使用 gzip 壓縮\n\n```bash title=\"壓縮 tar 檔案\"\ngzip -9 alpine-bash.tar\n```\n\n!!! tip \"gzip 參數說明\"\n    - `-9`：最高壓縮比（1-9，9 為最高）\n    - 壓縮後檔案會自動加上 `.gz` 副檔名\n\n```bash title=\"確認壓縮後大小\"\nls -lh alpine-bash.tar.gz\n```\n\n**預期結果**：\n\n```\n-rw------- 1 root root 3.4M Jan 27 11:05 alpine-bash.tar.gz\n```\n\n!!! success \"壓縮效果\"\n    檔案從 6.3MB 壓縮到 3.4MB，減少約 46% 的空間。\n\n---\n\n## 9.7 測試 - 清除全部的 Container 及 Images\n\n```bash title=\"清除所有 Container 與 Image\"\n./docker_clean_all.sh\n```\n\n**預期結果**：\n\n```\n20fb31307e87\n20fb31307e87\nUntagged: alpine-bash:latest\nDeleted: sha256:4326afd8916bbf220fcb95d27fd5cac5096b74fa6ccba7c8929d5a70820875ec\nUntagged: docker1.training.lab:5000/alpine:latest\nDeleted: sha256:d0a0f8e7bf9a6287c7dab568b947b6c3dd6b84e9c67ab9f1e95f79751d808641\n```\n\n```bash title=\"確認環境已清理\"\ndocker images\n```\n\n**預期結果**：\n\n```\nIMAGE   ID             DISK USAGE   CONTENT SIZE   EXTRA\n```\n\n---\n\n## 9.8 載入 Container Image\n\n### 使用 docker load 載入壓縮檔\n\n```bash title=\"從壓縮檔載入 Image\"\ndocker load -i alpine-bash.tar.gz\n```\n\n**預期結果**：\n\n```\nLoaded image: alpine-bash:latest\n```\n\n!!! note \"docker load 語法\"\n    ```\n    docker load [OPTIONS]\n    ```\n    \n    | 參數 | 說明 |\n    |------|------|\n    | `-i` 或 `--input` | 指定輸入檔案 |\n    | 支援 `.tar` 和 `.tar.gz` 格式 | |\n\n```bash title=\"確認 Image 已載入\"\ndocker images\n```\n\n**預期結果**：\n\n```\nIMAGE                ID             DISK USAGE   CONTENT SIZE   EXTRA\nalpine-bash:latest   4326afd8916b       14.5MB          6.6MB        \n```\n\n---\n\n## 9.9 確認是否有 Bash\n\n```bash title=\"使用載入的 Image 啟動 Container\"\ndocker run -it --name alpine-2 alpine-bash /bin/bash\n```\n\n進入容器後會看到提示符號 `bash-5.0#`，表示 Bash 已成功安裝。\n\n```bash title=\"確認 bash 已安裝（在 Container 內執行）\"\nls -l /bin/bash\n```\n\n**預期結果**：\n\n```\n-rwxr-xr-x    1 root     root        735488 May  3  2019 /bin/bash\n```\n\n```bash title=\"退出 Container\"\nexit\n```\n\n---\n\n## 9.10 清除全部的 Container 及 Images\n\n```bash title=\"最終清理\"\n./docker_clean_all.sh\n```\n\n**預期結果**：\n\n```\ndb10817df336\ndb10817df336\nUntagged: alpine-bash:latest\nDeleted: sha256:4326afd8916bbf220fcb95d27fd5cac5096b74fa6ccba7c8929d5a70820875ec\n```\n\n!!! success \"Lab 完成\"\n    恭喜你已成功完成本 Lab！\n\n---\n\n## 指令參考\n\n### docker commit\n\n| 選項 | 說明 | 範例 |\n|------|------|------|\n| `-m` | 提交訊息 | `-m \"alpine + bash\"` |\n| `-a` | 指定作者 | `-a \"John Doe\"` |\n| `-c` | 套用 Dockerfile 指令 | `-c 'CMD [\"bash\"]'` |\n| `-p` | 提交前暫停容器 | `-p` |\n\n### docker save 與 docker load\n\n| 指令 | 說明 | 範例 |\n|------|------|------|\n| `docker save` | 將 Image 匯出為 tar 檔 | `docker save -o image.tar my-image` |\n| `docker load` | 從 tar 檔載入 Image | `docker load -i image.tar` |\n\n!!! warning \"docker save vs docker export\"\n    | 比較 | docker save | docker export |\n    |------|-------------|---------------|\n    | 對象 | Image | Container |\n    | 保留 | 完整 Layer 與 metadata | 單一檔案系統 |\n    | 載入指令 | docker load | docker import |\n    | 用途 | Image 備份/傳輸 | Container 檔案系統備份 |\n\n---\n\n## 小結\n\n本章節重點回顧：\n\n- ✅ **docker commit**：將執行中的 Container 狀態儲存為新 Image\n- ✅ **docker save**：將 Image 匯出為 tar 檔案\n- ✅ **docker load**：從 tar 檔載入 Image\n- ✅ **gzip 壓縮**：減少匯出檔案的大小\n- ✅ **清理腳本**：使用腳本批次清理 Container 與 Image\n"
  },
  {
    "title": "LAB 10 客製化 Container Images - Dockerfile",
    "url": "https://caocharles.github.io/dcka-class-notes/lab10_dockerfile/",
    "content": "﻿---\nauthors:\n  - name: 課程作者\n    email: author@example.com\ndate: 2026-01-27\nupdated: 2026-01-27\ntags:\n  - Docker\n  - Dockerfile\n  - Docker Hub\n---\n\n# LAB 10 客製化 Container Images - Dockerfile\n\n## 學習目標\n\n完成本章節後，你將能夠：\n\n- [ ] 撰寫 Dockerfile 建立客製化 Image\n- [ ] 使用 `docker build` 建置 Image\n- [ ] 使用 `docker login` 登入 Docker Hub\n- [ ] 使用 `docker tag` 標記 Image\n- [ ] 使用 `docker push` 上傳 Image 到 Docker Hub\n- [ ] 從 Docker Hub 下載自己上傳的 Image\n\n## 前置知識\n\n開始之前，請確保你已經：\n\n- 完成 LAB 09 的內容\n- 了解 Docker Image 的基本概念\n- 已註冊 Docker Hub 帳號（https://hub.docker.com）\n\n---\n\n## 10.1 環境準備\n\n### 切換到 docker2 虛擬機\n\n本 Lab 在 docker2 虛擬機上執行。\n\n### 確認環境已清理\n\n```bash title=\"檢視現有的 Container Images\"\ndocker images\n```\n\n**預期結果**：\n\n```\nIMAGE   ID             DISK USAGE   CONTENT SIZE   EXTRA\n```\n\n```bash title=\"檢視現有的 Container\"\ndocker ps -a\n```\n\n**預期結果**：\n\n```\nCONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES\n```\n\n### 執行清理腳本（如有需要）\n\n```bash title=\"執行清理腳本\"\n./docker_clean_all.sh\n```\n\n!!! info \"腳本說明\"\n    如果沒有 Container 或 Image，指令會顯示錯誤訊息，這是正常的，不影響後續操作。\n\n---\n\n## 10.2 建立專用目錄與 Dockerfile\n\n### 建立工作目錄\n\n```bash title=\"建立 Dockerfile 專用目錄\"\nmkdir /root/dockerfile-1\ncd /root/dockerfile-1\n```\n\n### 建立 Dockerfile\n\n```bash title=\"編輯 Dockerfile\"\nvi dockerfile\n```\n\nDockerfile 內容：\n\n```dockerfile title=\"dockerfile\"\nFROM docker1.training.lab:5000/alpine\n#FROM 192.168.66.51:5000/alpine\nRUN apk add --no-cache --update-cache bash\nCMD [\"/bin/bash\"]\n```\n\n!!! note \"Dockerfile 指令說明\"\n    | 指令 | 說明 |\n    |------|------|\n    | `FROM` | 指定基礎映像，這裡使用 Private Registry 的 Alpine |\n    | `RUN` | 在建置過程中執行指令，這裡安裝 bash |\n    | `CMD` | 指定容器啟動時預設執行的指令 |\n\n```bash title=\"確認 Dockerfile 內容\"\ncat dockerfile\n```\n\n**預期結果**：\n\n```\nFROM docker1.training.lab:5000/alpine\n#FROM 192.168.66.51:5000/alpine\nRUN apk add --no-cache --update-cache bash\nCMD [\"/bin/bash\"]\n```\n\n---\n\n## 10.3 測試基礎 Alpine Image\n\n在建置自訂 Image 之前，先確認基礎 Alpine 沒有 Bash：\n\n```bash title=\"啟動 Alpine Container 測試\"\ndocker run -it --name alpine-1 docker1.training.lab:5000/alpine /bin/sh\n```\n\n**預期結果**：\n\n```\nUnable to find image 'docker1.training.lab:5000/alpine:latest' locally\nlatest: Pulling from alpine\n77cae8ab23bf: Pull complete \nDigest: sha256:d0a0f8e7bf9a6287c7dab568b947b6c3dd6b84e9c67ab9f1e95f79751d808641\nStatus: Downloaded newer image for docker1.training.lab:5000/alpine:latest\n```\n\n在容器內測試 Bash：\n\n```bash title=\"測試 bash（在 Container 內執行）\"\nbash\n```\n\n**預期結果**：\n\n```\n/bin/sh: bash: not found\n```\n\n```bash title=\"退出容器\"\nexit\n```\n\n---\n\n## 10.4 使用 Dockerfile 建置新的 Docker Image\n\n### 執行 docker build\n\n```bash title=\"建置 Docker Image\"\ndocker build -t alpine-bash-2 .\n```\n\n**預期結果**：\n\n```\n[+] Building 2.9s (6/6) FINISHED                                                docker:default\n => [internal] load build definition from dockerfile                                      0.0s\n => => transferring dockerfile: 171B                                                      0.0s\n => [internal] load metadata for docker1.training.lab:5000/alpine:latest                  0.0s\n => [internal] load .dockerignore                                                         0.0s\n => => transferring context: 2B                                                           0.0s\n => [1/2] FROM docker1.training.lab:5000/alpine:latest                                    0.0s\n => [2/2] RUN apk add --no-cache --update-cache bash                                      2.7s\n => exporting to image                                                                    0.2s\n => => exporting layers                                                                   0.1s\n => => naming to docker.io/library/alpine-bash-2:latest                                   0.0s\n => => unpacking to docker.io/library/alpine-bash-2:latest                                0.0s\n```\n\n!!! note \"docker build 語法\"\n    ```\n    docker build -t <image_name>:<tag> <path>\n    ```\n    \n    | 參數 | 說明 |\n    |------|------|\n    | `-t` | 指定 Image 名稱和標籤 |\n    | `.` | 指定 Dockerfile 所在目錄（當前目錄） |\n\n!!! info \"建置過程說明\"\n    - `[1/2] FROM`：載入基礎映像\n    - `[2/2] RUN`：執行 Dockerfile 中的 RUN 指令（安裝 bash）\n    - `exporting to image`：匯出為新的 Image\n\n---\n\n## 10.5 測試新的 Container Image\n\n### 使用新 Image 啟動容器\n\n```bash title=\"使用新 Image 啟動 Container\"\ndocker run -it --name alpine-3 alpine-bash-2 /bin/bash\n```\n\n進入容器後會看到 `bash-5.0#` 提示符號，表示 Bash 已成功安裝。\n\n### 確認 Bash 已安裝\n\n```bash title=\"確認 bash（在 Container 內執行）\"\nls -l /bin/bash\n```\n\n**預期結果**：\n\n```\n-rwxr-xr-x    1 root     root        735488 May  3  2019 /bin/bash\n```\n\n```bash title=\"退出容器\"\nexit\n```\n\n!!! success \"建置成功\"\n    使用 Dockerfile 建置的 Image 已包含 Bash，與 LAB 09 使用 `docker commit` 的結果相同，但 Dockerfile 方式更具可重現性。\n\n---\n\n## 10.6 清理環境\n\n```bash title=\"切換到家目錄並清理\"\ncd\n./docker_clean_all.sh\n```\n\n**預期結果**：\n\n```\n254f09eaadac\n9ae97d52cd65\n254f09eaadac\n9ae97d52cd65\nUntagged: alpine-bash-2:latest\nDeleted: sha256:fe1c0340426860bdd7792a7e560d3dfbb1c6a4d0bf4caadd5e987a4b71fbd169\nUntagged: docker1.training.lab:5000/alpine:latest\nDeleted: sha256:d0a0f8e7bf9a6287c7dab568b947b6c3dd6b84e9c67ab9f1e95f79751d808641\n```\n\n---\n\n## 10.7 上傳 Docker Image 到 Docker Hub\n\n### 註冊 Docker Hub 帳號\n\n!!! tip \"事前準備\"\n    請先到 [https://hub.docker.com](https://hub.docker.com) 註冊帳號。\n\n### 使用 docker login 登入\n\n```bash title=\"登入 Docker Hub\"\ndocker login -u <你的帳號>\n```\n\n**範例**：\n\n```bash\ndocker login -u caocharles\n```\n\n**預期結果**：\n\n```\nPassword: \nWARNING! Your credentials are stored unencrypted in '/root/.docker/config.json'.\nConfigure a credential helper to remove this warning. See\nhttps://docs.docker.com/go/credential-store/\n\nLogin Succeeded\n```\n\n!!! warning \"密碼儲存警告\"\n    登入後，Docker 會將認證資訊儲存在 `/root/.docker/config.json`，這是 Base64 編碼（非加密），請注意安全。\n\n### 重新建置 Docker Image\n\n```bash title=\"切換到 Dockerfile 目錄\"\ncd /root/dockerfile-1\n```\n\n```bash title=\"建置要上傳的 Image\"\ndocker build -t alpine-bash-charles .\n```\n\n**預期結果**：\n\n```\n[+] Building 0.1s (6/6) FINISHED                                                docker:default\n => [internal] load build definition from dockerfile                                      0.0s\n => CACHED [2/2] RUN apk add --no-cache --update-cache bash                               0.0s\n => exporting to image                                                                    0.0s\n => => naming to docker.io/library/alpine-bash-charles:latest                             0.0s\n```\n\n!!! info \"CACHED 說明\"\n    如果之前已建置過相同的層，Docker 會使用快取，加快建置速度。\n\n### 為 Image 加上 Tag\n\n要上傳到 Docker Hub，Image 名稱必須包含你的 Docker Hub 帳號名稱：\n\n```bash title=\"為 Image 加上 Tag\"\ndocker tag alpine-bash-charles:latest <你的帳號>/alpine-bash-charles:latest\n```\n\n**範例**：\n\n```bash\ndocker tag alpine-bash-charles:latest caocharles/alpine-bash-charles:latest\n```\n\n!!! note \"docker tag 語法\"\n    ```\n    docker tag <source_image>:<tag> <target_image>:<tag>\n    ```\n    \n    - Target image 格式：`<Docker Hub 帳號>/<Image 名稱>:<tag>`\n\n```bash title=\"確認 Tag 已建立\"\ndocker images\n```\n\n**預期結果**：\n\n```\nIMAGE                                   ID             DISK USAGE   CONTENT SIZE   EXTRA\nalpine-bash-charles:latest              28024b3ae76e       14.5MB          6.6MB        \ncaocharles/alpine-bash-charles:latest   28024b3ae76e       14.5MB          6.6MB        \n```\n\n!!! info \"兩個 Image 使用相同 ID\"\n    `docker tag` 只是建立一個新的標籤指向同一個 Image，不會佔用額外空間。\n\n---\n\n## 10.8 上傳 Docker Image\n\n### 執行 docker push\n\n```bash title=\"上傳 Image 到 Docker Hub\"\ndocker push <你的帳號>/alpine-bash-charles:latest\n```\n\n**範例**：\n\n```bash\ndocker push caocharles/alpine-bash-charles:latest\n```\n\n**預期結果**：\n\n```\nThe push refers to repository [docker.io/caocharles/alpine-bash-charles]\n77cae8ab23bf: Pushed \n34b2f2a4fe94: Pushed \n01bc7f934740: Pushed \nlatest: digest: sha256:28024b3ae76eb1a9400407051085821a6f0a76b1b96cb2f4a92cec35f350d29f size: 855\n```\n\n!!! warning \"常見錯誤：push access denied\"\n    如果出現以下錯誤：\n    ```\n    push access denied, repository does not exist or may require authorization\n    ```\n    \n    **可能原因**：\n    \n    1. Image 標籤的帳號名稱與登入帳號不符\n    2. 尚未登入或登入憑證過期\n    \n    **解決方案**：\n    ```bash\n    # 確認使用正確的帳號名稱\n    docker tag alpine-bash-charles:latest <正確帳號>/alpine-bash-charles:latest\n    \n    # 重新登入\n    docker logout\n    docker login -u <你的帳號>\n    ```\n\n---\n\n## 10.9 驗證上傳結果\n\n### 在 Docker Hub 網站確認\n\n1. 開啟 [https://hub.docker.com](https://hub.docker.com)\n2. 登入你的帳號\n3. 進入 Repositories\n4. 確認可以看到剛上傳的 Image\n\n### 清理本地環境並從 Docker Hub 下載\n\n```bash title=\"清理本地環境\"\ncd\n./docker_clean_all.sh\n```\n\n```bash title=\"確認已清理\"\ndocker images\n```\n\n**預期結果**：\n\n```\nIMAGE   ID             DISK USAGE   CONTENT SIZE   EXTRA\n```\n\n```bash title=\"從 Docker Hub 下載 Image\"\ndocker pull <你的帳號>/alpine-bash-charles\n```\n\n**範例**：\n\n```bash\ndocker pull caocharles/alpine-bash-charles\n```\n\n**預期結果**：\n\n```\nUsing default tag: latest\nlatest: Pulling from caocharles/alpine-bash-charles\n01bc7f934740: Pull complete \n34b2f2a4fe94: Download complete \nDigest: sha256:28024b3ae76eb1a9400407051085821a6f0a76b1b96cb2f4a92cec35f350d29f\nStatus: Downloaded newer image for caocharles/alpine-bash-charles:latest\ndocker.io/caocharles/alpine-bash-charles:latest\n```\n\n```bash title=\"確認下載成功\"\ndocker images\n```\n\n**預期結果**：\n\n```\nIMAGE                                   ID             DISK USAGE   CONTENT SIZE   EXTRA\ncaocharles/alpine-bash-charles:latest   28024b3ae76e       14.5MB          6.6MB    \n```\n\n!!! success \"完成確認\"\n    成功從 Docker Hub 下載剛才上傳的 Image！\n\n---\n\n## 指令參考\n\n### Dockerfile 基本指令\n\n| 指令 | 說明 | 範例 |\n|------|------|------|\n| `FROM` | 指定基礎映像 | `FROM alpine:latest` |\n| `RUN` | 建置時執行指令 | `RUN apk add bash` |\n| `CMD` | 容器啟動時預設指令 | `CMD [\"/bin/bash\"]` |\n| `COPY` | 複製檔案到 Image | `COPY ./src /app` |\n| `WORKDIR` | 設定工作目錄 | `WORKDIR /app` |\n| `EXPOSE` | 宣告開放的 Port | `EXPOSE 80` |\n| `ENV` | 設定環境變數 | `ENV APP_HOME=/app` |\n\n### Docker Hub 相關指令\n\n| 指令 | 說明 | 範例 |\n|------|------|------|\n| `docker login` | 登入 Docker Registry | `docker login -u username` |\n| `docker logout` | 登出 Docker Registry | `docker logout` |\n| `docker tag` | 為 Image 加上標籤 | `docker tag image:tag user/image:tag` |\n| `docker push` | 上傳 Image | `docker push user/image:tag` |\n| `docker pull` | 下載 Image | `docker pull user/image:tag` |\n\n---\n\n## 常見問題\n\n??? question \"Q1：docker build 時出現 'no such file or directory' 錯誤？\"\n    **可能原因**：\n    \n    1. Dockerfile 檔名不正確（注意大小寫）\n    2. 不在正確的目錄\n    \n    **解決方案**：\n    ```bash\n    # 確認檔案存在\n    ls -la dockerfile\n    \n    # 使用 -f 指定 Dockerfile 路徑\n    docker build -f ./dockerfile -t my-image .\n    ```\n\n??? question \"Q2：docker push 失敗，顯示 'access denied'？\"\n    **解決方案**：\n    \n    1. 確認已登入：`docker login`\n    2. 確認 Image 標籤包含正確的帳號名稱\n    3. 標籤格式必須是：`<帳號>/<image名稱>:<tag>`\n\n??? question \"Q3：Dockerfile 與 docker commit 有什麼差別？\"\n    | 比較 | docker commit | Dockerfile |\n    |------|---------------|------------|\n    | 可追蹤性 | 無法追蹤變更 | 可版本控制 |\n    | 可重現性 | 難以重現 | 可重複建置 |\n    | 自動化 | 手動操作 | 可自動化 |\n    | 建議用途 | 測試/除錯 | 生產環境 |\n\n---\n\n## 小結\n\n本章節重點回顧：\n\n- ✅ **Dockerfile**：使用 FROM、RUN、CMD 指令建立客製化 Image\n- ✅ **docker build**：根據 Dockerfile 建置 Image\n- ✅ **docker login**：登入 Docker Hub\n- ✅ **docker tag**：為 Image 加上符合 Docker Hub 格式的標籤\n- ✅ **docker push**：上傳 Image 到 Docker Hub\n- ✅ **docker pull**：從 Docker Hub 下載 Image\n"
  },
  {
    "title": "LAB 11 Standalone Kubernetes 安裝",
    "url": "https://caocharles.github.io/dcka-class-notes/lab11_standalone_k8s/",
    "content": "﻿---\nauthors:\n  - name: 課程作者\n    email: author@example.com\ndate: 2026-01-27\nupdated: 2026-01-27\ntags:\n  - Kubernetes\n  - Installation\n  - Standalone\n---\n\n# LAB 11 Standalone Kubernetes 安裝\n\n## 學習目標\n\n完成本章節後，你將能夠：\n\n- [ ] 使用 Shell Script 自動化安裝 Kubernetes\n- [ ] 了解 Standalone Kubernetes 的架構\n- [ ] 監控 Kubernetes 叢集狀態\n- [ ] 在 Standalone Master 節點上部署 Pod\n- [ ] 建立虛擬機快照保留狀態\n\n## 前置知識\n\n開始之前，請確保你已經：\n\n- 完成 Docker 相關章節\n- 了解基本的 Linux 指令操作\n- 了解容器化的基本概念\n\n---\n\n## 11.1 環境說明\n\n### 什麼是 Standalone Kubernetes？\n\nStandalone Kubernetes 是一個單節點的 Kubernetes 叢集，Master 節點同時也作為 Worker 節點使用。這種架構適合：\n\n- 學習與測試環境\n- 開發環境\n- 小型專案\n\n```mermaid\ngraph TB\n    subgraph \"Standalone Kubernetes\"\n        M[k8s-standalone<br/>Master + Worker<br/>192.168.66.61]\n        subgraph \"Control Plane\"\n            API[API Server]\n            ETCD[etcd]\n            SCHED[Scheduler]\n            CM[Controller Manager]\n        end\n        subgraph \"Node Components\"\n            KL[Kubelet]\n            KP[Kube-Proxy]\n            CR[CRI-O]\n        end\n        subgraph \"Pods\"\n            P1[Pod 1]\n            P2[Pod 2]\n        end\n    end\n```\n\n### 虛擬機資訊\n\n| 項目 | 值 |\n|------|------|\n| 主機名稱 | k8s-standalone.training.lab |\n| IP 位址 | 192.168.66.61 |\n| 作業系統 | Rocky Linux 9 |\n| Kubernetes 版本 | 1.32 |\n\n---\n\n## 11.2 切換到 k8s-standalone 虛擬機\n\n### 確認網路設定\n\n```bash title=\"檢視網路介面\"\nifconfig ens160\n```\n\n**預期結果**：\n\n```\nens160: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500\n        inet 192.168.66.61  netmask 255.255.255.0  broadcast 192.168.66.255\n        inet6 fe80::20c:29ff:fe91:c3  prefixlen 64  scopeid 0x20<link>\n        ether 00:0c:29:91:00:c3  txqueuelen 1000  (Ethernet)\n        RX packets 41897  bytes 25015527 (23.8 MiB)\n        RX errors 0  dropped 0  overruns 0  frame 0\n        TX packets 672  bytes 55461 (54.1 KiB)\n        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\n```\n\n### 確認主機名稱\n\n```bash title=\"檢視主機名稱\"\nhostname\n```\n\n**預期結果**：\n\n```\nk8s-standalone.training.lab\n```\n\n### 確認 hosts 檔案\n\n```bash title=\"檢視 /etc/hosts\"\ncat /etc/hosts\n```\n\n**預期結果**：\n\n```\n127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4\n::1         localhost localhost.localdomain localhost6 localhost6.localdomain6\n\n192.168.66.10\tmaster.training.lab\tmaster\n192.168.66.11\tnode1.training.lab\tnode1\n192.168.66.12\tnode2.training.lab\tnode2\n192.168.66.21\tdocker.training.lab\tdocker\n192.168.66.22\tminikube.training.lab\tminikube\n\n192.168.66.51\t\tdocker1.training.lab\t\tdocker1\n192.168.66.52\t\tdocker2.training.lab\t\tdocker2\n192.168.66.61\t\tk8s-standalone.training.lab\tk8s-standalone\n192.168.66.71\t\tk8s-master1.training.lab\tk8s-master1\n192.168.66.81\t\tk8s-node1.training.lab\t\tk8s-node1\n192.168.66.82\t\tk8s-node2.training.lab\t\tk8s-node2\n```\n\n---\n\n## 11.3 下載安裝 Script\n\n### 使用 wget 下載\n\n```bash title=\"下載安裝腳本\"\nwget http://10.0.1.249/k8s/scripts/install_k8s-latest.sh\n```\n\n**預期結果**：\n\n```\n--2026-01-27 11:21:14--  http://10.0.1.249/k8s/scripts/install_k8s-latest.sh\nConnecting to 10.0.1.249:80... connected.\nHTTP request sent, awaiting response... 200 OK\nLength: 22517 (22K) [application/x-sh]\nSaving to: 'install_k8s-latest.sh'\n\ninstall_k8s-latest.sh       100%[========================================>]  21.99K  --.-KB/s    in 0s      \n\n2026-01-27 11:21:14 (61.0 MB/s) - 'install_k8s-latest.sh' saved [22517/22517]\n```\n\n### 設定執行權限\n\n```bash title=\"設定執行權限\"\nchmod 755 install_k8s-latest.sh\n```\n\n---\n\n## 11.4 使用 Shell Script 自動化安裝 Kubernetes\n\n### 查看安裝選項\n\n```bash title=\"執行腳本查看使用說明\"\n./install_k8s-latest.sh\n```\n\n**預期結果**：\n\n```\n請輸入 完整安裝(full) 或是 standalone\n./install_k8s-latest.sh -full\n或 \n./install_k8s-latest.sh -standalone\n```\n\n!!! note \"安裝模式說明\"\n    | 模式 | 說明 |\n    |------|------|\n    | `-full` | 完整安裝，包含 Master 與 Worker 節點設定 |\n    | `-standalone` | 單機安裝，Master 節點同時作為 Worker 節點 |\n\n### 執行 Standalone 安裝\n\n```bash title=\"執行 Standalone 安裝\"\n./install_k8s-latest.sh -standalone\n```\n\n!!! info \"安裝過程說明\"\n    腳本會自動執行以下步驟：\n    \n    1. **安裝必要套件**：sshpass、bash-completion\n    2. **安裝 Docker CE**：包含 containerd.io、docker-ce-cli\n    3. **關閉 Swap**：Kubernetes 要求關閉 Swap\n    4. **設定核心參數**：啟用 IP 轉發、設定網路參數\n    5. **安裝 Kubernetes 套件**：kubelet、kubeadm、kubectl\n    6. **安裝 CRI-O**：Container Runtime Interface\n    7. **關閉防火牆**：停用 firewalld\n    8. **執行 kubeadm init**：初始化 Kubernetes 叢集\n    9. **安裝 CNI**：安裝 Antrea 網路套件\n    10. **移除 Taint**：允許在 Master 節點上部署 Pod\n\n### 安裝過程輸出（部分）\n\n安裝 Docker CE：\n\n```\nInstalling:\n docker-ce                    x86_64    3:29.2.0-1.el9    docker-ce-stable     24 M\n containerd.io                x86_64    2.2.1-1.el9       docker-ce-stable     35 M\n docker-ce-cli                x86_64    1:29.2.0-1.el9    docker-ce-stable    8.4 M\n docker-buildx-plugin         x86_64    0.30.1-1.el9      docker-ce-stable     17 M\n docker-compose-plugin        x86_64    5.0.2-1.el9       docker-ce-stable    8.1 M\n\nComplete!\n```\n\n安裝 Kubernetes 套件：\n\n```\nInstalling:\n kubeadm       x86_64    1.32.11-150500.1.1    kubernetes    12 M\n kubectl       x86_64    1.32.11-150500.1.1    kubernetes    11 M\n kubelet       x86_64    1.32.11-150500.1.1    kubernetes    15 M\n cri-tools     x86_64    1.32.0-150500.1.1     kubernetes   7.1 M\n kubernetes-cni x86_64   1.6.0-150500.1.1      kubernetes   8.0 M\n\nComplete!\n```\n\n安裝 CRI-O：\n\n```\nInstalling:\n cri-o         x86_64    1.32.1-150500.1.1     cri-o         20 M\n\nComplete!\n```\n\n### kubeadm init 輸出\n\n```\n[init] Using Kubernetes version: v1.32.11\n[preflight] Running pre-flight checks\n[preflight] Pulling images required for setting up a Kubernetes cluster\n[certs] Using certificateDir folder \"/etc/kubernetes/pki\"\n[certs] Generating \"ca\" certificate and key\n[certs] Generating \"apiserver\" certificate and key\n[certs] apiserver serving cert is signed for DNS names [k8s-standalone.training.lab kubernetes kubernetes.default kubernetes.default.svc kubernetes.default.svc.cluster.local] and IPs [172.30.0.1 192.168.66.61]\n...\n[kubelet-start] Starting the kubelet\n[kubelet-check] The kubelet is healthy after 515.21134ms\n[api-check] The API server is healthy after 3.001460102s\n...\n[addons] Applied essential addon: CoreDNS\n[addons] Applied essential addon: kube-proxy\n\nYour Kubernetes control-plane has initialized successfully!\n```\n\n!!! success \"初始化成功\"\n    看到 `Your Kubernetes control-plane has initialized successfully!` 表示 Kubernetes 控制平面已成功初始化。\n\n### 安裝 Antrea CNI\n\n腳本會自動安裝 Antrea 作為 CNI（Container Network Interface）：\n\n```\ncustomresourcedefinition.apiextensions.k8s.io/antreaagentinfos.crd.antrea.io created\nserviceaccount/antrea-agent created\nserviceaccount/antrea-controller created\nclusterrole.rbac.authorization.k8s.io/antrea-agent created\nclusterrole.rbac.authorization.k8s.io/antrea-controller created\n...\ndeployment.apps/antrea-controller created\ndaemonset.apps/antrea-agent created\n```\n\n### 移除 Master 節點的 Taint\n\n預設情況下，Kubernetes 不允許在 Master 節點上部署 Pod。腳本會自動移除這個限制：\n\n```\nnode/k8s-standalone.training.lab untainted\n```\n\n!!! note \"Taint 說明\"\n    Taint（汙點）是 Kubernetes 用來限制 Pod 調度的機制。Master 節點預設有 `node-role.kubernetes.io/control-plane:NoSchedule` 的 Taint，表示不接受一般 Pod 的調度。\n\n---\n\n## 11.5 監控 Kubernetes 狀態\n\n### 檢視節點狀態\n\n```bash title=\"檢視節點狀態\"\nkubectl get nodes\n```\n\n**預期結果**（初始狀態）：\n\n```\nNAME                          STATUS     ROLES           AGE   VERSION\nk8s-standalone.training.lab   NotReady   control-plane   35s   v1.32.11\n```\n\n!!! warning \"NotReady 狀態\"\n    節點剛初始化時會顯示 `NotReady`，等待 CNI 套件完全啟動後會變成 `Ready`。\n\n等待約 30 秒後再次檢查：\n\n```bash title=\"再次檢視節點狀態\"\nkubectl get nodes\n```\n\n**預期結果**：\n\n```\nNAME                          STATUS   ROLES           AGE   VERSION\nk8s-standalone.training.lab   Ready    control-plane   2m    v1.32.11\n```\n\n### 檢視系統 Pod 狀態\n\n```bash title=\"檢視 kube-system namespace 的 Pod\"\nkubectl get pods -n kube-system\n```\n\n**預期結果**：\n\n```\nNAME                                                  READY   STATUS    RESTARTS   AGE\nantrea-agent-xxxxx                                    2/2     Running   0          2m\nantrea-controller-xxxxx                               1/1     Running   0          2m\ncoredns-xxxxx                                         1/1     Running   0          2m\ncoredns-xxxxx                                         1/1     Running   0          2m\netcd-k8s-standalone.training.lab                      1/1     Running   0          2m\nkube-apiserver-k8s-standalone.training.lab            1/1     Running   0          2m\nkube-controller-manager-k8s-standalone.training.lab   1/1     Running   0          2m\nkube-proxy-xxxxx                                      1/1     Running   0          2m\nkube-scheduler-k8s-standalone.training.lab            1/1     Running   0          2m\n```\n\n### 持續監控節點狀態\n\n```bash title=\"使用 watch 持續監控\"\nwatch kubectl get nodes\n```\n\n!!! tip \"watch 指令\"\n    `watch` 指令會每 2 秒重新執行一次指令，按 `Ctrl+C` 可以退出。\n\n---\n\n## 11.6 部署測試\n\n### 建立測試 Deployment\n\n```bash title=\"建立 nginx Deployment\"\nkubectl create deployment test1 --image=nginx\n```\n\n**預期結果**：\n\n```\ndeployment.apps/test1 created\n```\n\n!!! note \"kubectl create deployment 語法\"\n    ```\n    kubectl create deployment <name> --image=<image>\n    ```\n    \n    | 參數 | 說明 |\n    |------|------|\n    | `<name>` | Deployment 名稱 |\n    | `--image` | 使用的容器映像 |\n\n### 檢視 Deployment 狀態\n\n```bash title=\"檢視 Deployment\"\nkubectl get deployments.apps\n```\n\n**預期結果**：\n\n```\nNAME    READY   UP-TO-DATE   AVAILABLE   AGE\ntest1   0/1     1            0           15s\n```\n\n!!! info \"Deployment 欄位說明\"\n    | 欄位 | 說明 |\n    |------|------|\n    | `READY` | 就緒的 Pod 數量 / 預期數量 |\n    | `UP-TO-DATE` | 已更新到最新版本的 Pod 數量 |\n    | `AVAILABLE` | 可用的 Pod 數量 |\n\n### 檢視 Pod 狀態\n\n```bash title=\"檢視 Pod 狀態\"\nkubectl get pods\n```\n\n**預期結果**：\n\n```\nNAME                     READY   STATUS    RESTARTS   AGE\ntest1-7d9bdc56f4-mbtc5   0/1     Pending   0          27s\n```\n\n### 檢視 Pod 詳細資訊\n\n```bash title=\"檢視 Pod 詳細資訊（含節點資訊）\"\nkubectl get pods -o wide\n```\n\n**預期結果**：\n\n```\nNAME                     READY   STATUS    RESTARTS   AGE   IP       NODE     NOMINATED NODE   READINESS GATES\ntest1-7d9bdc56f4-mbtc5   0/1     Pending   0          33s   <none>   <none>   <none>           <none>\n```\n\n!!! warning \"Pod 處於 Pending 狀態\"\n    如果 Pod 持續處於 `Pending` 狀態且 `NODE` 顯示 `<none>`，可能是因為：\n    \n    1. 節點尚未就緒（NotReady）\n    2. 節點仍有 Taint 限制\n    \n    需要等待節點變成 Ready 狀態，或確認 Taint 已移除。\n\n### 等待節點就緒後確認\n\n等待節點變成 Ready 後，Pod 會自動調度並啟動：\n\n```bash title=\"確認節點狀態\"\nkubectl get nodes\n```\n\n當節點顯示 `Ready` 後：\n\n```bash title=\"再次檢視 Pod 狀態\"\nkubectl get pods -o wide\n```\n\n**預期結果**（節點就緒後）：\n\n```\nNAME                     READY   STATUS    RESTARTS   AGE   IP            NODE                          NOMINATED NODE   READINESS GATES\ntest1-7d9bdc56f4-mbtc5   1/1     Running   0          2m    10.244.0.5    k8s-standalone.training.lab   <none>           <none>\n```\n\n!!! success \"部署成功\"\n    當 Pod 狀態變成 `Running` 且 `NODE` 顯示 `k8s-standalone.training.lab`，表示已成功在 Standalone Master 節點上部署 Pod。\n\n### 清理測試 Deployment\n\n```bash title=\"刪除測試 Deployment\"\nkubectl delete deployment test1\n```\n\n**預期結果**：\n\n```\ndeployment.apps \"test1\" deleted\n```\n\n---\n\n## 11.7 建立快照 Snapshot\n\n!!! tip \"建議\"\n    完成安裝後，建議在 VMware 中建立虛擬機快照，以便日後需要時可以快速還原到乾淨的 Kubernetes 環境。\n\n### 建立快照步驟\n\n1. 在 VMware vSphere Client 或 VMware Workstation 中\n2. 選擇 k8s-standalone 虛擬機\n3. 右鍵選擇 **快照** > **拍攝快照**\n4. 輸入快照名稱，例如：`K8s 1.32 安裝完成`\n5. 點擊確定\n\n---\n\n## 指令參考\n\n### kubectl 基本指令\n\n| 指令 | 說明 |\n|------|------|\n| `kubectl get nodes` | 檢視節點狀態 |\n| `kubectl get pods` | 檢視 Pod 列表 |\n| `kubectl get pods -n kube-system` | 檢視系統 Pod |\n| `kubectl describe node <name>` | 檢視節點詳細資訊 |\n| `kubectl describe pod <name>` | 檢視 Pod 詳細資訊 |\n| `kubectl run <name> --image=<image>` | 建立 Pod |\n| `kubectl delete pod <name>` | 刪除 Pod |\n| `kubectl exec -it <name> -- <cmd>` | 在 Pod 中執行指令 |\n\n### 安裝相關元件版本\n\n| 元件 | 版本 |\n|------|------|\n| Kubernetes | 1.32.11 |\n| Docker CE | 29.2.0 |\n| containerd.io | 2.2.1 |\n| CRI-O | 1.32.1 |\n| Antrea CNI | 最新版 |\n\n---\n\n## 常見問題\n\n??? question \"Q1：節點一直顯示 NotReady？\"\n    **可能原因**：\n    \n    1. CNI 套件尚未完全啟動\n    2. kubelet 服務異常\n    \n    **解決方案**：\n    ```bash\n    # 檢視 kubelet 狀態\n    systemctl status kubelet\n    \n    # 檢視 kubelet 日誌\n    journalctl -u kubelet -f\n    \n    # 檢視系統 Pod 狀態\n    kubectl get pods -n kube-system\n    ```\n\n??? question \"Q2：Pod 無法在 Master 節點上執行？\"\n    **可能原因**：Master 節點有 Taint 限制\n    \n    **解決方案**：\n    ```bash\n    # 檢視節點 Taint\n    kubectl describe node k8s-standalone.training.lab | grep Taint\n    \n    # 移除 control-plane Taint\n    kubectl taint nodes k8s-standalone.training.lab node-role.kubernetes.io/control-plane:NoSchedule-\n    ```\n\n??? question \"Q3：如何重新安裝 Kubernetes？\"\n    **解決方案**：\n    ```bash\n    # 重置 kubeadm\n    kubeadm reset -f\n    \n    # 清理 iptables\n    iptables -F && iptables -t nat -F && iptables -t mangle -F && iptables -X\n    \n    # 重新執行安裝腳本\n    ./install_k8s-latest.sh -standalone\n    ```\n\n---\n\n## 小結\n\n本章節重點回顧：\n\n- ✅ **環境準備**：切換到 k8s-standalone 虛擬機，確認網路設定\n- ✅ **下載安裝腳本**：使用 wget 下載自動化安裝腳本\n- ✅ **自動化安裝**：使用 `-standalone` 參數執行單機安裝\n- ✅ **監控狀態**：使用 `kubectl get nodes` 確認節點 Ready\n- ✅ **部署測試**：成功在 Standalone Master 上部署 Pod\n- ✅ **建立快照**：保留乾淨的 Kubernetes 環境\n"
  },
  {
    "title": "LAB 12 kubernetes 安裝",
    "url": "https://caocharles.github.io/dcka-class-notes/lab12_k8s_install/",
    "content": "# LAB 12 kubernetes 安裝\n\n## 學習目標\n\n完成本章節後，你將能夠：\n\n- [ ] 理解 Kubernetes 與 OpenShift/OKD 的關係與差異\n- [ ] 安裝並設定 Kubernetes 環境（minikube）\n- [ ] 理解 Kubernetes 架構與核心元件\n- [ ] 撰寫 YAML 設定檔定義資源\n- [ ] 管理 Deployment、Service、Pod 等資源\n- [ ] 實作 RollingUpdate、Recreate、Canary、Blue/Green 部署策略\n- [ ] 設定 Persistent Volumes、ConfigMaps、Secrets\n- [ ] 配置 RBAC 權限控制\n- [ ] 完成 WordPress + MySQL 的 Kubernetes 部署實作\n- [ ] 使用 kubectl 進行日誌查看與疑難排解\n\n## 前置知識\n\n開始之前，請確保你已經：\n\n- 完成第 1-3 章的內容\n- 熟悉 Docker 基本操作\n- 理解容器化的基本概念\n- 具備基本的 YAML 語法知識\n\n---\n\n## 4.1 Kubernetes 與 OpenShift/OKD\n\n### Kubernetes 簡介\n\nKubernetes（簡稱 K8S）是 Google 開源的容器編排平台，用於自動化部署、擴展和管理容器化應用程式。\n\n!!! info \"名稱由來\"\n    Kubernetes 源自希臘語，意為「舵手」或「領航員」。\n    K8S 是因為 K 和 S 之間有 8 個字母而得名。\n\n### OpenShift 與 OKD\n\n| 項目 | Kubernetes | OpenShift | OKD |\n|------|------------|-----------|-----|\n| **開發者** | CNCF | Red Hat | 社群 |\n| **授權** | 開源免費 | 商業版（需授權） | 開源免費 |\n| **定位** | 容器編排平台 | 企業級 K8S 發行版 | OpenShift 社群版 |\n| **支援** | 社群支援 | 商業支援 | 社群支援 |\n| **額外功能** | 基礎功能 | 開發者工具、CI/CD、Web Console | 類似 OpenShift |\n\n```mermaid\ngraph TB\n    subgraph \"關係圖\"\n        K8S[Kubernetes] --> OKD[OKD<br/>社群版]\n        OKD --> OS[OpenShift<br/>企業版]\n        K8S --> Other[其他發行版<br/>Rancher, EKS, AKS, GKE]\n    end\n```\n\n### OpenShift 額外功能\n\n!!! tip \"OpenShift 相較於原生 K8S 的優勢\"\n    - **Web Console**：功能完整的管理介面\n    - **Source-to-Image (S2I)**：原始碼直接部署\n    - **內建 CI/CD**：整合 Jenkins、Tekton\n    - **開發者工具**：odo CLI 簡化開發流程\n    - **安全強化**：預設 Security Context Constraints\n    - **商業支援**：Red Hat 企業級支援\n\n---\n\n## 4.2 minikube vs minishift\n\n### 本地開發環境比較\n\n| 比較項目 | minikube | minishift |\n|----------|----------|-----------|\n| **平台** | Kubernetes | OpenShift (OKD) |\n| **用途** | K8S 本地開發測試 | OpenShift 本地開發測試 |\n| **資源需求** | 較低 | 較高 |\n| **維護狀態** | 活躍維護 | 已停止維護 |\n| **替代方案** | - | CodeReady Containers (CRC) |\n\n### 安裝 minikube\n\n=== \"macOS\"\n    ```bash title=\"macOS 安裝 minikube\"\n    # 使用 Homebrew 安裝\n    brew install minikube\n    \n    # 安裝 kubectl\n    brew install kubectl\n    ```\n\n=== \"Linux\"\n    ```bash title=\"Linux 安裝 minikube\"\n    # 下載 minikube\n    curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64\n    sudo install minikube-linux-amd64 /usr/local/bin/minikube\n    \n    # 安裝 kubectl\n    curl -LO \"https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl\"\n    sudo install kubectl /usr/local/bin/kubectl\n    ```\n\n=== \"Windows\"\n    ```powershell title=\"Windows 安裝 minikube\"\n    # 使用 Chocolatey 安裝\n    choco install minikube\n    choco install kubernetes-cli\n    ```\n\n### 啟動 minikube\n\n```bash title=\"minikube 基本操作\"\n# 啟動 minikube（使用 Docker 驅動）\nminikube start --driver=docker\n\n# 指定資源\nminikube start --cpus=4 --memory=8192 --driver=docker\n\n# 檢查狀態\nminikube status\n\n# 存取 Dashboard\nminikube dashboard\n\n# 停止\nminikube stop\n\n# 刪除\nminikube delete\n```\n\n---\n\n## 4.3 Kubernetes 架構\n\n### 整體架構\n\n```mermaid\ngraph TB\n    subgraph \"Control Plane（控制平面）\"\n        API[API Server]\n        ETCD[(etcd)]\n        Sched[Scheduler]\n        CM[Controller Manager]\n        API --> ETCD\n        API --> Sched\n        API --> CM\n    end\n    \n    subgraph \"Worker Node 1\"\n        Kubelet1[Kubelet]\n        Proxy1[kube-proxy]\n        CR1[Container Runtime]\n        Pod1[Pod]\n        Pod2[Pod]\n        Kubelet1 --> CR1\n        CR1 --> Pod1\n        CR1 --> Pod2\n    end\n    \n    subgraph \"Worker Node 2\"\n        Kubelet2[Kubelet]\n        Proxy2[kube-proxy]\n        CR2[Container Runtime]\n        Pod3[Pod]\n        Pod4[Pod]\n        Kubelet2 --> CR2\n        CR2 --> Pod3\n        CR2 --> Pod4\n    end\n    \n    API --> Kubelet1\n    API --> Kubelet2\n```\n\n### Control Plane 元件\n\n| 元件 | 說明 |\n|------|------|\n| **API Server** | K8S 的入口，處理所有 REST API 請求 |\n| **etcd** | 分散式鍵值儲存，保存叢集狀態 |\n| **Scheduler** | 決定 Pod 要在哪個 Node 執行 |\n| **Controller Manager** | 管理各種控制器（Deployment、ReplicaSet 等） |\n\n### Worker Node 元件\n\n| 元件 | 說明 |\n|------|------|\n| **Kubelet** | Node 的代理程式，管理 Pod 生命週期 |\n| **kube-proxy** | 網路代理，實現 Service 的負載均衡 |\n| **Container Runtime** | 容器執行環境（containerd、CRI-O） |\n\n---\n\n## 4.4 安裝 Kubernetes\n\n### 使用 minikube 安裝\n\n```bash title=\"完整安裝流程\"\n# 1. 確認 Docker 已安裝並運行\ndocker version\n\n# 2. 啟動 minikube\nminikube start --driver=docker --cpus=2 --memory=4096\n\n# 3. 驗證安裝\nkubectl cluster-info\n\n# 4. 檢查 Node 狀態\nkubectl get nodes\n\n# 5. 檢查系統 Pod\nkubectl get pods -n kube-system\n```\n\n### 其他安裝選項\n\n!!! note \"生產環境安裝選項\"\n    | 方案 | 適用場景 |\n    |------|----------|\n    | **kubeadm** | 自建叢集 |\n    | **k3s** | 輕量級，適合邊緣運算 |\n    | **Amazon EKS** | AWS 雲端 |\n    | **Azure AKS** | Azure 雲端 |\n    | **Google GKE** | GCP 雲端 |\n\n---\n\n## 4.5 YAML 與 JSON 檔\n\n### YAML 基礎語法\n\n```yaml title=\"YAML 基本結構\"\n# 這是註解\napiVersion: v1          # 純量（Scalar）\nkind: Pod\nmetadata:\n  name: my-pod          # 縮排表示層級\n  labels:               # 對應（Mapping）\n    app: web\n    tier: frontend\nspec:\n  containers:           # 列表（Sequence）\n    - name: nginx\n      image: nginx:1.25\n      ports:\n        - containerPort: 80\n    - name: sidecar\n      image: busybox\n```\n\n### YAML vs JSON\n\n=== \"YAML\"\n    ```yaml title=\"Pod 定義 (YAML)\"\n    apiVersion: v1\n    kind: Pod\n    metadata:\n      name: my-pod\n    spec:\n      containers:\n        - name: nginx\n          image: nginx\n    ```\n\n=== \"JSON\"\n    ```json title=\"Pod 定義 (JSON)\"\n    {\n      \"apiVersion\": \"v1\",\n      \"kind\": \"Pod\",\n      \"metadata\": {\n        \"name\": \"my-pod\"\n      },\n      \"spec\": {\n        \"containers\": [\n          {\n            \"name\": \"nginx\",\n            \"image\": \"nginx\"\n          }\n        ]\n      }\n    }\n    ```\n\n!!! tip \"建議使用 YAML\"\n    - 更易讀\n    - 支援註解\n    - 較簡潔\n\n---\n\n## 4.6 Kubernetes Resource Type\n\n### 常見資源類型\n\n```mermaid\ngraph TB\n    subgraph \"工作負載 Workloads\"\n        Pod[Pod]\n        Deploy[Deployment]\n        RS[ReplicaSet]\n        DS[DaemonSet]\n        SS[StatefulSet]\n        Job[Job]\n        CJ[CronJob]\n    end\n    \n    subgraph \"網路 Networking\"\n        Svc[Service]\n        Ing[Ingress]\n        NP[NetworkPolicy]\n    end\n    \n    subgraph \"儲存 Storage\"\n        PV[PersistentVolume]\n        PVC[PersistentVolumeClaim]\n        SC[StorageClass]\n    end\n    \n    subgraph \"設定 Configuration\"\n        CM[ConfigMap]\n        Sec[Secret]\n    end\n```\n\n### 資源說明\n\n| 資源 | 用途 | 常用程度 |\n|------|------|----------|\n| **Pod** | 最小部署單位，包含一或多個容器 | ⭐⭐⭐ |\n| **Deployment** | 管理 Pod 的部署與更新 | ⭐⭐⭐ |\n| **Service** | 提供穩定的網路端點 | ⭐⭐⭐ |\n| **ConfigMap** | 儲存非機密設定 | ⭐⭐⭐ |\n| **Secret** | 儲存機密資訊 | ⭐⭐⭐ |\n| **Ingress** | HTTP/HTTPS 路由 | ⭐⭐ |\n| **PersistentVolume** | 持久化儲存 | ⭐⭐ |\n| **StatefulSet** | 有狀態應用程式 | ⭐⭐ |\n\n---\n\n## 4.7 Kubernetes 管理\n\n### 4.7.1 Deployment\n\nDeployment（部署）是管理 Pod 副本的控制器，提供聲明式更新。\n\n```yaml title=\"deployment.yaml\"\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\n  labels:\n    app: nginx\nspec:\n  replicas: 3                    # 副本數量\n  selector:\n    matchLabels:\n      app: nginx\n  template:                      # Pod 模板\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n        - name: nginx\n          image: nginx:1.25\n          ports:\n            - containerPort: 80\n          resources:\n            requests:\n              memory: \"64Mi\"\n              cpu: \"250m\"\n            limits:\n              memory: \"128Mi\"\n              cpu: \"500m\"\n```\n\n```bash title=\"Deployment 操作\"\n# 建立 Deployment\nkubectl apply -f deployment.yaml\n\n# 查看 Deployment\nkubectl get deployments\n\n# 查看詳細資訊\nkubectl describe deployment nginx-deployment\n\n# 調整副本數\nkubectl scale deployment nginx-deployment --replicas=5\n\n# 刪除 Deployment\nkubectl delete deployment nginx-deployment\n```\n\n### 4.7.2 Service\n\nService（服務）提供穩定的網路端點，實現負載均衡。\n\n```mermaid\ngraph TB\n    Client[Client] --> Svc[Service<br/>ClusterIP: 10.96.0.1]\n    Svc --> Pod1[Pod 1<br/>10.244.0.5]\n    Svc --> Pod2[Pod 2<br/>10.244.0.6]\n    Svc --> Pod3[Pod 3<br/>10.244.0.7]\n```\n\n#### Service 類型\n\n| 類型 | 說明 | 用途 |\n|------|------|------|\n| **ClusterIP** | 僅叢集內部存取（預設） | 內部服務通訊 |\n| **NodePort** | 透過 Node IP + Port 存取 | 開發測試 |\n| **LoadBalancer** | 雲端負載均衡器 | 生產環境對外服務 |\n| **ExternalName** | 對應外部 DNS | 連接外部服務 |\n\n```yaml title=\"service.yaml\"\napiVersion: v1\nkind: Service\nmetadata:\n  name: nginx-service\nspec:\n  type: ClusterIP            # 或 NodePort、LoadBalancer\n  selector:\n    app: nginx               # 選擇 label 為 app=nginx 的 Pod\n  ports:\n    - protocol: TCP\n      port: 80               # Service Port\n      targetPort: 80         # Container Port\n      # nodePort: 30080      # NodePort 類型使用\n```\n\n```bash title=\"Service 操作\"\n# 建立 Service\nkubectl apply -f service.yaml\n\n# 查看 Service\nkubectl get services\n\n# 查看端點\nkubectl get endpoints nginx-service\n\n# 測試連線（在 Pod 內）\nkubectl exec -it pod-name -- curl nginx-service\n```\n\n### 4.7.3 RollingUpdate 與 Recreate\n\n#### 更新策略比較\n\n```mermaid\ngraph LR\n    subgraph \"RollingUpdate（滾動更新）\"\n        R1[v1 v1 v1] --> R2[v2 v1 v1] --> R3[v2 v2 v1] --> R4[v2 v2 v2]\n    end\n    \n    subgraph \"Recreate（重建）\"\n        C1[v1 v1 v1] --> C2[停機] --> C3[v2 v2 v2]\n    end\n```\n\n| 策略 | 優點 | 缺點 | 適用場景 |\n|------|------|------|----------|\n| **RollingUpdate** | 零停機 | 新舊版本共存 | 一般應用 |\n| **Recreate** | 簡單、無版本混用 | 有停機時間 | 無法多版本共存 |\n\n```yaml title=\"更新策略設定\"\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: my-app\nspec:\n  replicas: 3\n  strategy:\n    type: RollingUpdate        # 或 Recreate\n    rollingUpdate:\n      maxSurge: 1              # 最多額外 Pod 數\n      maxUnavailable: 0        # 最多不可用 Pod 數\n  # ... 其他設定\n```\n\n```bash title=\"更新操作\"\n# 更新 Image\nkubectl set image deployment/nginx-deployment nginx=nginx:1.26\n\n# 查看更新狀態\nkubectl rollout status deployment/nginx-deployment\n\n# 查看更新歷史\nkubectl rollout history deployment/nginx-deployment\n\n# 回滾到前一版本\nkubectl rollout undo deployment/nginx-deployment\n\n# 回滾到特定版本\nkubectl rollout undo deployment/nginx-deployment --to-revision=2\n```\n\n### 4.7.4 Canary 與 Blue/Green\n\n#### Canary 部署（金絲雀部署）\n\n將新版本部署給少量使用者測試。\n\n```mermaid\ngraph LR\n    User[使用者流量] --> LB[負載均衡]\n    LB -->|90%| V1[v1 Pod x 9]\n    LB -->|10%| V2[v2 Pod x 1]\n```\n\n```yaml title=\"Canary Deployment 範例\"\n# 穩定版本 Deployment\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: app-stable\nspec:\n  replicas: 9\n  selector:\n    matchLabels:\n      app: myapp\n      version: stable\n  template:\n    metadata:\n      labels:\n        app: myapp\n        version: stable\n    spec:\n      containers:\n        - name: app\n          image: myapp:v1\n---\n# Canary 版本 Deployment\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: app-canary\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: myapp\n      version: canary\n  template:\n    metadata:\n      labels:\n        app: myapp\n        version: canary\n    spec:\n      containers:\n        - name: app\n          image: myapp:v2\n---\n# Service 同時選擇兩個版本\napiVersion: v1\nkind: Service\nmetadata:\n  name: myapp-service\nspec:\n  selector:\n    app: myapp          # 不指定 version，同時包含兩個版本\n  ports:\n    - port: 80\n```\n\n#### Blue/Green 部署（藍綠部署）\n\n同時維護兩個環境，快速切換。\n\n```mermaid\ngraph LR\n    subgraph \"切換前\"\n        User1[使用者] --> Blue1[Blue 環境<br/>v1 - 運行中]\n        Green1[Green 環境<br/>v2 - 待命]\n    end\n    \n    subgraph \"切換後\"\n        User2[使用者] --> Green2[Green 環境<br/>v2 - 運行中]\n        Blue2[Blue 環境<br/>v1 - 待命]\n    end\n```\n\n```bash title=\"Blue/Green 部署切換\"\n# 假設目前 Service 指向 blue\n# 切換到 green\nkubectl patch service myapp-service -p '{\"spec\":{\"selector\":{\"version\":\"green\"}}}'\n\n# 確認切換\nkubectl describe service myapp-service\n```\n\n### 4.7.5 可用資源管理\n\n#### 資源請求與限制\n\n```yaml title=\"資源設定\"\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: resource-demo\nspec:\n  template:\n    spec:\n      containers:\n        - name: app\n          image: nginx\n          resources:\n            requests:              # 最小需求\n              memory: \"64Mi\"\n              cpu: \"250m\"         # 0.25 CPU\n            limits:               # 最大限制\n              memory: \"128Mi\"\n              cpu: \"500m\"         # 0.5 CPU\n```\n\n!!! note \"CPU 單位說明\"\n    - `1` = 1 CPU 核心\n    - `500m` = 0.5 CPU = 500 millicores\n    - `250m` = 0.25 CPU\n\n#### Resource Quota\n\n```yaml title=\"ResourceQuota 範例\"\napiVersion: v1\nkind: ResourceQuota\nmetadata:\n  name: compute-quota\n  namespace: dev\nspec:\n  hard:\n    requests.cpu: \"4\"\n    requests.memory: 8Gi\n    limits.cpu: \"8\"\n    limits.memory: 16Gi\n    pods: \"10\"\n```\n\n#### LimitRange\n\n```yaml title=\"LimitRange 範例\"\napiVersion: v1\nkind: LimitRange\nmetadata:\n  name: limit-range\n  namespace: dev\nspec:\n  limits:\n    - type: Container\n      default:\n        cpu: \"500m\"\n        memory: \"256Mi\"\n      defaultRequest:\n        cpu: \"100m\"\n        memory: \"64Mi\"\n      max:\n        cpu: \"2\"\n        memory: \"1Gi\"\n      min:\n        cpu: \"50m\"\n        memory: \"32Mi\"\n```\n\n---\n\n## 4.8 Kubernetes 網路\n\n### Pod 網路\n\n```mermaid\ngraph TB\n    subgraph \"Node 1\"\n        subgraph \"Pod A\"\n            C1[Container 1]\n            C2[Container 2]\n        end\n        subgraph \"Pod B\"\n            C3[Container 3]\n        end\n    end\n    \n    subgraph \"Node 2\"\n        subgraph \"Pod C\"\n            C4[Container 4]\n        end\n    end\n    \n    C1 <-->|localhost| C2\n    C1 <-->|Pod IP| C3\n    C3 <-->|CNI| C4\n```\n\n### 網路模型原則\n\n!!! info \"Kubernetes 網路原則\"\n    1. 所有 Pod 可以直接通訊（不需 NAT）\n    2. Node 上的代理可以與所有 Pod 通訊\n    3. Pod 看到的 IP 與其他 Pod 看到的相同\n\n### CNI 插件\n\n| CNI 插件 | 說明 |\n|----------|------|\n| **Calico** | 最常用，支援 Network Policy |\n| **Flannel** | 簡單易用 |\n| **Weave** | 自動發現，易於設定 |\n| **Cilium** | eBPF 基礎，高效能 |\n\n### NetworkPolicy\n\n```yaml title=\"NetworkPolicy 範例\"\napiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: allow-nginx\n  namespace: default\nspec:\n  podSelector:\n    matchLabels:\n      app: nginx\n  policyTypes:\n    - Ingress\n    - Egress\n  ingress:\n    - from:\n        - podSelector:\n            matchLabels:\n              app: frontend\n      ports:\n        - protocol: TCP\n          port: 80\n  egress:\n    - to:\n        - podSelector:\n            matchLabels:\n              app: database\n      ports:\n        - protocol: TCP\n          port: 3306\n```\n\n---\n\n## 4.9 Persistent Volumes\n\n### 儲存架構\n\n```mermaid\ngraph LR\n    Pod[Pod] --> PVC[PersistentVolumeClaim]\n    PVC --> PV[PersistentVolume]\n    PV --> Storage[(實際儲存<br/>NFS/Cloud Disk)]\n```\n\n### PersistentVolume (PV)\n\n```yaml title=\"PersistentVolume 範例\"\napiVersion: v1\nkind: PersistentVolume\nmetadata:\n  name: pv-demo\nspec:\n  capacity:\n    storage: 10Gi\n  accessModes:\n    - ReadWriteOnce          # RWO: 單節點讀寫\n    # - ReadOnlyMany         # ROX: 多節點唯讀\n    # - ReadWriteMany        # RWX: 多節點讀寫\n  persistentVolumeReclaimPolicy: Retain\n  storageClassName: standard\n  hostPath:                  # 僅用於測試\n    path: /data/pv-demo\n```\n\n### PersistentVolumeClaim (PVC)\n\n```yaml title=\"PersistentVolumeClaim 範例\"\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: pvc-demo\nspec:\n  accessModes:\n    - ReadWriteOnce\n  resources:\n    requests:\n      storage: 5Gi\n  storageClassName: standard\n```\n\n### 在 Pod 中使用 PVC\n\n```yaml title=\"Pod 使用 PVC\"\napiVersion: v1\nkind: Pod\nmetadata:\n  name: pod-with-pvc\nspec:\n  containers:\n    - name: app\n      image: nginx\n      volumeMounts:\n        - name: data\n          mountPath: /usr/share/nginx/html\n  volumes:\n    - name: data\n      persistentVolumeClaim:\n        claimName: pvc-demo\n```\n\n---\n\n## 4.10 ConfigMaps 與 Secrets\n\n### ConfigMap\n\n用於儲存非機密的設定資料。\n\n```yaml title=\"ConfigMap 範例\"\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: app-config\ndata:\n  # 鍵值對\n  APP_ENV: production\n  LOG_LEVEL: info\n  # 設定檔\n  nginx.conf: |\n    server {\n        listen 80;\n        server_name localhost;\n        location / {\n            root /usr/share/nginx/html;\n        }\n    }\n```\n\n```bash title=\"建立 ConfigMap\"\n# 從字面值建立\nkubectl create configmap app-config --from-literal=APP_ENV=production\n\n# 從檔案建立\nkubectl create configmap nginx-config --from-file=nginx.conf\n\n# 從目錄建立\nkubectl create configmap configs --from-file=./config-dir/\n```\n\n### Secret\n\n用於儲存敏感資料（Base64 編碼）。\n\n```yaml title=\"Secret 範例\"\napiVersion: v1\nkind: Secret\nmetadata:\n  name: db-secret\ntype: Opaque\ndata:\n  # 使用 base64 編碼\n  username: YWRtaW4=           # admin\n  password: cGFzc3dvcmQxMjM=   # password123\n```\n\n```bash title=\"建立 Secret\"\n# 從字面值建立\nkubectl create secret generic db-secret \\\n  --from-literal=username=admin \\\n  --from-literal=password=password123\n\n# 檢視 Secret（會解碼）\nkubectl get secret db-secret -o jsonpath='{.data.password}' | base64 -d\n```\n\n### 在 Pod 中使用\n\n```yaml title=\"使用 ConfigMap 和 Secret\"\napiVersion: v1\nkind: Pod\nmetadata:\n  name: app-pod\nspec:\n  containers:\n    - name: app\n      image: nginx\n      # 環境變數方式\n      env:\n        - name: APP_ENV\n          valueFrom:\n            configMapKeyRef:\n              name: app-config\n              key: APP_ENV\n        - name: DB_PASSWORD\n          valueFrom:\n            secretKeyRef:\n              name: db-secret\n              key: password\n      # 掛載為檔案\n      volumeMounts:\n        - name: config\n          mountPath: /etc/nginx/conf.d\n        - name: secret\n          mountPath: /etc/secrets\n          readOnly: true\n  volumes:\n    - name: config\n      configMap:\n        name: app-config\n    - name: secret\n      secret:\n        secretName: db-secret\n```\n\n---\n\n## 4.11 RBAC (Role-Based Access Control)\n\n### RBAC 概念\n\n```mermaid\ngraph LR\n    User[User/ServiceAccount] --> RB[RoleBinding]\n    RB --> Role[Role]\n    Role --> Resources[Resources<br/>pods, services...]\n    \n    User2[User/ServiceAccount] --> CRB[ClusterRoleBinding]\n    CRB --> CR[ClusterRole]\n    CR --> Resources2[Cluster Resources]\n```\n\n### Role 與 ClusterRole\n\n| 類型 | 範圍 | 用途 |\n|------|------|------|\n| **Role** | 單一 Namespace | 限定 Namespace 的權限 |\n| **ClusterRole** | 整個叢集 | 跨 Namespace 或叢集資源 |\n\n```yaml title=\"Role 範例\"\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  namespace: dev\n  name: pod-reader\nrules:\n  - apiGroups: [\"\"]              # 核心 API 群組\n    resources: [\"pods\"]\n    verbs: [\"get\", \"watch\", \"list\"]\n  - apiGroups: [\"\"]\n    resources: [\"pods/log\"]\n    verbs: [\"get\"]\n```\n\n```yaml title=\"ClusterRole 範例\"\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: secret-reader\nrules:\n  - apiGroups: [\"\"]\n    resources: [\"secrets\"]\n    verbs: [\"get\", \"watch\", \"list\"]\n```\n\n### RoleBinding 與 ClusterRoleBinding\n\n```yaml title=\"RoleBinding 範例\"\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: read-pods\n  namespace: dev\nsubjects:\n  - kind: User\n    name: jane\n    apiGroup: rbac.authorization.k8s.io\n  - kind: ServiceAccount\n    name: default\n    namespace: dev\nroleRef:\n  kind: Role\n  name: pod-reader\n  apiGroup: rbac.authorization.k8s.io\n```\n\n```bash title=\"RBAC 操作\"\n# 查看角色\nkubectl get roles -n dev\nkubectl get clusterroles\n\n# 查看綁定\nkubectl get rolebindings -n dev\nkubectl get clusterrolebindings\n\n# 測試權限\nkubectl auth can-i get pods --as=jane -n dev\nkubectl auth can-i delete pods --as=jane -n dev\n```\n\n---\n\n## 4.12 使用 Kubernetes 架設 WordPress + MySQL\n\n### Lab 實作目標\n\n在 Kubernetes 上部署完整的 WordPress 網站，包含：\n\n- MySQL 資料庫（StatefulSet）\n- WordPress 應用程式（Deployment）\n- 持久化儲存（PVC）\n- Service 對外服務\n\n### 架構圖\n\n```mermaid\ngraph TB\n    User[使用者] --> WP_SVC[WordPress Service<br/>NodePort: 30080]\n    WP_SVC --> WP1[WordPress Pod]\n    WP_SVC --> WP2[WordPress Pod]\n    WP1 --> MySQL_SVC[MySQL Service<br/>ClusterIP]\n    WP2 --> MySQL_SVC\n    MySQL_SVC --> MySQL[MySQL Pod]\n    WP1 --> WP_PVC[WordPress PVC]\n    WP2 --> WP_PVC\n    MySQL --> MySQL_PVC[MySQL PVC]\n```\n\n### 實作步驟\n\n#### 步驟 1：建立 Namespace\n\n```yaml title=\"01-namespace.yaml\"\napiVersion: v1\nkind: Namespace\nmetadata:\n  name: wordpress\n```\n\n```bash\nkubectl apply -f 01-namespace.yaml\n```\n\n#### 步驟 2：建立 Secret\n\n```yaml title=\"02-secret.yaml\"\napiVersion: v1\nkind: Secret\nmetadata:\n  name: mysql-secret\n  namespace: wordpress\ntype: Opaque\ndata:\n  mysql-root-password: cm9vdHBhc3N3b3Jk      # rootpassword\n  mysql-password: d3BwYXNzd29yZA==           # wppassword\n```\n\n```bash\nkubectl apply -f 02-secret.yaml\n```\n\n#### 步驟 3：建立 MySQL\n\n```yaml title=\"03-mysql.yaml\"\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: mysql-pvc\n  namespace: wordpress\nspec:\n  accessModes:\n    - ReadWriteOnce\n  resources:\n    requests:\n      storage: 5Gi\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: mysql\n  namespace: wordpress\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: mysql\n  template:\n    metadata:\n      labels:\n        app: mysql\n    spec:\n      containers:\n        - name: mysql\n          image: mysql:8.0\n          ports:\n            - containerPort: 3306\n          env:\n            - name: MYSQL_ROOT_PASSWORD\n              valueFrom:\n                secretKeyRef:\n                  name: mysql-secret\n                  key: mysql-root-password\n            - name: MYSQL_DATABASE\n              value: wordpress\n            - name: MYSQL_USER\n              value: wpuser\n            - name: MYSQL_PASSWORD\n              valueFrom:\n                secretKeyRef:\n                  name: mysql-secret\n                  key: mysql-password\n          volumeMounts:\n            - name: mysql-data\n              mountPath: /var/lib/mysql\n      volumes:\n        - name: mysql-data\n          persistentVolumeClaim:\n            claimName: mysql-pvc\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: mysql\n  namespace: wordpress\nspec:\n  selector:\n    app: mysql\n  ports:\n    - port: 3306\n      targetPort: 3306\n  clusterIP: None\n```\n\n```bash\nkubectl apply -f 03-mysql.yaml\n```\n\n#### 步驟 4：建立 WordPress\n\n```yaml title=\"04-wordpress.yaml\"\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: wordpress-pvc\n  namespace: wordpress\nspec:\n  accessModes:\n    - ReadWriteOnce\n  resources:\n    requests:\n      storage: 5Gi\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: wordpress\n  namespace: wordpress\nspec:\n  replicas: 2\n  selector:\n    matchLabels:\n      app: wordpress\n  template:\n    metadata:\n      labels:\n        app: wordpress\n    spec:\n      containers:\n        - name: wordpress\n          image: wordpress:latest\n          ports:\n            - containerPort: 80\n          env:\n            - name: WORDPRESS_DB_HOST\n              value: mysql\n            - name: WORDPRESS_DB_NAME\n              value: wordpress\n            - name: WORDPRESS_DB_USER\n              value: wpuser\n            - name: WORDPRESS_DB_PASSWORD\n              valueFrom:\n                secretKeyRef:\n                  name: mysql-secret\n                  key: mysql-password\n          volumeMounts:\n            - name: wordpress-data\n              mountPath: /var/www/html\n      volumes:\n        - name: wordpress-data\n          persistentVolumeClaim:\n            claimName: wordpress-pvc\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: wordpress\n  namespace: wordpress\nspec:\n  type: NodePort\n  selector:\n    app: wordpress\n  ports:\n    - port: 80\n      targetPort: 80\n      nodePort: 30080\n```\n\n```bash\nkubectl apply -f 04-wordpress.yaml\n```\n\n#### 步驟 5：驗證部署\n\n```bash title=\"驗證指令\"\n# 檢查 Pod 狀態\nkubectl get pods -n wordpress\n\n# 檢查 Service\nkubectl get services -n wordpress\n\n# 檢查 PVC\nkubectl get pvc -n wordpress\n\n# 取得 minikube IP\nminikube ip\n\n# 存取 WordPress\n# 瀏覽器開啟 http://<minikube-ip>:30080\n```\n\n#### 使用 minikube service\n\n```bash\n# 自動開啟瀏覽器\nminikube service wordpress -n wordpress\n```\n\n---\n\n## 4.13 Logging、Monitoring 與疑難排除\n\n### 查看 Pod 日誌\n\n```bash title=\"kubectl logs\"\n# 查看日誌\nkubectl logs pod-name\n\n# 持續追蹤\nkubectl logs -f pod-name\n\n# 查看特定容器（多容器 Pod）\nkubectl logs pod-name -c container-name\n\n# 查看前一個容器的日誌（重啟後）\nkubectl logs pod-name --previous\n\n# 顯示最後 N 行\nkubectl logs pod-name --tail=100\n\n# 指定時間範圍\nkubectl logs pod-name --since=1h\n```\n\n### 疑難排除指令\n\n```bash title=\"常用診斷指令\"\n# 查看 Pod 狀態\nkubectl get pods -o wide\n\n# 查看詳細資訊\nkubectl describe pod pod-name\n\n# 進入 Pod 執行指令\nkubectl exec -it pod-name -- /bin/sh\n\n# 查看事件\nkubectl get events --sort-by='.lastTimestamp'\n\n# 查看資源使用\nkubectl top pods\nkubectl top nodes\n```\n\n### 常見問題診斷\n\n!!! tip \"Pod 狀態說明\"\n    | 狀態 | 說明 | 處理方式 |\n    |------|------|----------|\n    | **Pending** | 等待調度 | 檢查資源、Node 狀態 |\n    | **ContainerCreating** | 建立容器中 | 檢查 Image 拉取 |\n    | **Running** | 運行中 | 正常 |\n    | **CrashLoopBackOff** | 持續崩潰重啟 | 查看 logs |\n    | **ImagePullBackOff** | Image 拉取失敗 | 檢查 Image 名稱、Registry 存取 |\n    | **Error** | 錯誤 | 查看 describe、logs |\n\n```bash title=\"診斷範例\"\n# Pod Pending - 檢查原因\nkubectl describe pod pending-pod | grep -A 10 Events\n\n# CrashLoopBackOff - 查看日誌\nkubectl logs crashing-pod --previous\n\n# ImagePullBackOff - 檢查 Image\nkubectl describe pod image-error-pod | grep -A 5 \"Image:\"\n```\n\n### 監控工具\n\n!!! note \"常見監控方案\"\n    | 工具 | 用途 |\n    |------|------|\n    | **Prometheus** | 指標收集與儲存 |\n    | **Grafana** | 視覺化儀表板 |\n    | **Loki** | 日誌聚合 |\n    | **Jaeger** | 分散式追蹤 |\n    | **Kubernetes Dashboard** | 基本 UI |\n\n---\n\n## 常見問題\n\n??? question \"Q1：Pod 一直處於 Pending 狀態\"\n    **可能原因**：\n    \n    1. 資源不足（CPU/Memory）\n    2. Node 標籤不符合 nodeSelector\n    3. PVC 未綁定\n    \n    **診斷步驟**：\n    ```bash\n    kubectl describe pod pending-pod\n    kubectl get events --field-selector involvedObject.name=pending-pod\n    ```\n\n??? question \"Q2：Service 無法連接到 Pod\"\n    **檢查步驟**：\n    ```bash\n    # 1. 確認 Pod 運行中\n    kubectl get pods -l app=myapp\n    \n    # 2. 確認 Service selector 正確\n    kubectl describe service myapp-service\n    \n    # 3. 確認 Endpoints\n    kubectl get endpoints myapp-service\n    \n    # 4. 測試 Pod 內部連線\n    kubectl exec -it test-pod -- curl myapp-service\n    ```\n\n??? question \"Q3：如何回滾到前一個版本？\"\n    **解決方案**：\n    ```bash\n    # 查看歷史\n    kubectl rollout history deployment/myapp\n    \n    # 回滾到前一版\n    kubectl rollout undo deployment/myapp\n    \n    # 回滾到特定版本\n    kubectl rollout undo deployment/myapp --to-revision=2\n    \n    # 確認狀態\n    kubectl rollout status deployment/myapp\n    ```\n\n??? question \"Q4：ConfigMap 更新後 Pod 為什麼沒有變化？\"\n    **原因**：Pod 不會自動重新載入 ConfigMap\n    \n    **解決方案**：\n    ```bash\n    # 方法 1：重啟 Deployment\n    kubectl rollout restart deployment/myapp\n    \n    # 方法 2：使用 configmap hash annotation（建議）\n    # 在 Deployment template 加入 annotation\n    kubectl patch deployment myapp -p \\\n      '{\"spec\":{\"template\":{\"metadata\":{\"annotations\":{\"configmap-hash\":\"'$(kubectl get cm myconfig -o jsonpath='{.metadata.resourceVersion}')'\"}}}}}' \n    ```\n\n??? question \"Q5：如何清理 Evicted 的 Pod？\"\n    **解決方案**：\n    ```bash\n    # 查看 Evicted Pod\n    kubectl get pods --field-selector=status.phase=Failed\n    \n    # 刪除所有 Evicted Pod\n    kubectl delete pods --field-selector=status.phase=Failed --all-namespaces\n    ```\n\n---\n\n## 小結\n\n本章節重點回顧：\n\n- ✅ **Kubernetes 概述**：K8S 與 OpenShift/OKD 的關係，minikube 本地環境\n- ✅ **核心架構**：Control Plane（API Server、etcd、Scheduler）與 Worker Node\n- ✅ **資源類型**：Pod、Deployment、Service、ConfigMap、Secret 等\n- ✅ **部署策略**：RollingUpdate、Recreate、Canary、Blue/Green\n- ✅ **網路與儲存**：Service 類型、PV/PVC、NetworkPolicy\n- ✅ **安全控管**：RBAC（Role、ClusterRole、RoleBinding）\n- ✅ **實作經驗**：WordPress + MySQL 在 K8S 上的完整部署\n- ✅ **疑難排解**：kubectl logs、describe、exec 診斷技巧\n\n## 延伸閱讀\n\n- [Kubernetes 官方文件](https://kubernetes.io/docs/)\n- [Kubernetes 官方教程](https://kubernetes.io/docs/tutorials/)\n- [minikube 官方文件](https://minikube.sigs.k8s.io/docs/)\n- [OpenShift 官方文件](https://docs.openshift.com/)\n- [Kubernetes Patterns 電子書](https://www.redhat.com/en/resources/oreilly-kubernetes-patterns-cloud-native-apps-ebook)\n- [CNCF Landscape](https://landscape.cncf.io/)\n"
  },
  {
    "title": "Lab13 K8S Commands",
    "url": "https://caocharles.github.io/dcka-class-notes/lab13_k8s_commands/",
    "content": "﻿# LAB 13 kubernetes 常用指令\n\n## 學習目標\n\n- [ ] 待補\n\n## 實作步驟\n\n*(本章節內容待補)*\n\n"
  },
  {
    "title": "Lab14 Namespace Rolling",
    "url": "https://caocharles.github.io/dcka-class-notes/lab14_namespace_rolling/",
    "content": "﻿# LAB 14 namespaces 與 rolling update\n\n## 學習目標\n\n- [ ] 待補\n\n## 實作步驟\n\n*(本章節內容待補)*\n\n"
  },
  {
    "title": "Lab15 Service",
    "url": "https://caocharles.github.io/dcka-class-notes/lab15_service/",
    "content": "﻿# LAB 15 service\n\n## 學習目標\n\n- [ ] 待補\n\n## 實作步驟\n\n*(本章節內容待補)*\n\n"
  },
  {
    "title": "Lab16 Pv Pvc",
    "url": "https://caocharles.github.io/dcka-class-notes/lab16_pv_pvc/",
    "content": "﻿# LAB 16 PV/PVC\n\n## 學習目標\n\n- [ ] 待補\n\n## 實作步驟\n\n*(本章節內容待補)*\n\n"
  },
  {
    "title": "Lab17 Secret",
    "url": "https://caocharles.github.io/dcka-class-notes/lab17_secret/",
    "content": "﻿# LAB 17 secret\n\n## 學習目標\n\n- [ ] 待補\n\n## 實作步驟\n\n*(本章節內容待補)*\n\n"
  },
  {
    "title": "Lab18 Rbac Event Log",
    "url": "https://caocharles.github.io/dcka-class-notes/lab18_rbac_event_log/",
    "content": "﻿# LAB 18 RBAC 與 event/log\n\n## 學習目標\n\n- [ ] 待補\n\n## 實作步驟\n\n*(本章節內容待補)*\n\n"
  },
  {
    "title": "Lab19 K8S Wordpress Mysql",
    "url": "https://caocharles.github.io/dcka-class-notes/lab19_k8s_wordpress_mysql/",
    "content": "﻿# LAB 19 Kubernetes + wordpress + mysql\n\n## 學習目標\n\n- [ ] 待補\n\n## 實作步驟\n\n*(本章節內容待補)*\n\n"
  },
  {
    "title": "Lab20 Dashboard",
    "url": "https://caocharles.github.io/dcka-class-notes/lab20_dashboard/",
    "content": "﻿# LAB 20 圖形管理工具 Kubernetes Dashboard\n\n## 學習目標\n\n- [ ] 待補\n\n## 實作步驟\n\n*(本章節內容待補)*\n\n"
  }
]