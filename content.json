[
  {
    "title": "Docker 指令速查表",
    "url": "https://caocharles.github.io/dcka-class-notes/appendix/docker_cheatsheet/",
    "content": "# Docker 指令速查表\n\n快速參考 Docker 常用指令，適合日常操作與考試複習。\n\n---\n\n## 容器管理\n\n### 執行容器\n\n| 指令 | 說明 |\n|------|------|\n| `docker run <image>` | 執行容器 |\n| `docker run -d <image>` | 背景執行 |\n| `docker run -it <image> /bin/bash` | 互動模式 |\n| `docker run --name <name> <image>` | 指定名稱 |\n| `docker run -p 8080:80 <image>` | Port 對應 |\n| `docker run -v /host:/container <image>` | 掛載目錄 |\n| `docker run -e VAR=value <image>` | 設定環境變數 |\n| `docker run --rm <image>` | 結束後自動刪除 |\n| `docker run --restart=always <image>` | 自動重啟 |\n| `docker run --network <network> <image>` | 指定網路 |\n\n### 容器操作\n\n| 指令 | 說明 |\n|------|------|\n| `docker ps` | 列出運行中的容器 |\n| `docker ps -a` | 列出所有容器 |\n| `docker start <container>` | 啟動容器 |\n| `docker stop <container>` | 停止容器 |\n| `docker restart <container>` | 重啟容器 |\n| `docker pause <container>` | 暫停容器 |\n| `docker unpause <container>` | 繼續容器 |\n| `docker rm <container>` | 刪除容器 |\n| `docker rm -f <container>` | 強制刪除運行中的容器 |\n| `docker container prune` | 刪除所有已停止的容器 |\n\n### 容器操作與除錯\n\n| 指令 | 說明 |\n|------|------|\n| `docker exec -it <container> /bin/bash` | 進入容器 |\n| `docker exec <container> <command>` | 執行指令 |\n| `docker logs <container>` | 查看日誌 |\n| `docker logs -f <container>` | 追蹤日誌 |\n| `docker logs --tail 100 <container>` | 最後 100 行 |\n| `docker inspect <container>` | 詳細資訊 |\n| `docker stats` | 資源使用統計 |\n| `docker top <container>` | 容器內程序 |\n| `docker cp <src> <container>:<dest>` | 複製檔案到容器 |\n| `docker cp <container>:<src> <dest>` | 從容器複製檔案 |\n\n---\n\n## Image 管理\n\n### 基本操作\n\n| 指令 | 說明 |\n|------|------|\n| `docker images` | 列出本地 Image |\n| `docker pull <image>` | 拉取 Image |\n| `docker push <image>` | 推送 Image |\n| `docker rmi <image>` | 刪除 Image |\n| `docker image prune` | 刪除未使用的 Image |\n| `docker image prune -a` | 刪除所有未使用的 Image |\n\n### 建置與標籤\n\n| 指令 | 說明 |\n|------|------|\n| `docker build -t <name>:<tag> .` | 建置 Image |\n| `docker build -f Dockerfile.prod .` | 指定 Dockerfile |\n| `docker build --no-cache .` | 不使用快取 |\n| `docker tag <image> <new-tag>` | 加上標籤 |\n| `docker history <image>` | 查看 Image 歷史 |\n| `docker save -o image.tar <image>` | 匯出 Image |\n| `docker load -i image.tar` | 匯入 Image |\n\n### 搜尋\n\n| 指令 | 說明 |\n|------|------|\n| `docker search <keyword>` | 搜尋 Docker Hub |\n| `docker search --filter is-official=true <keyword>` | 只搜尋官方 Image |\n| `docker search --limit 5 <keyword>` | 限制結果數量 |\n\n---\n\n## Volume 管理\n\n| 指令 | 說明 |\n|------|------|\n| `docker volume ls` | 列出所有 Volume |\n| `docker volume create <name>` | 建立 Volume |\n| `docker volume inspect <name>` | 查看詳細資訊 |\n| `docker volume rm <name>` | 刪除 Volume |\n| `docker volume prune` | 刪除未使用的 Volume |\n\n### 掛載方式\n\n```bash\n# Volume 掛載\ndocker run -v my-volume:/app/data nginx\n\n# Bind Mount\ndocker run -v /host/path:/container/path nginx\n\n# 唯讀掛載\ndocker run -v /host/path:/container/path:ro nginx\n\n# --mount 語法（推薦）\ndocker run --mount type=volume,source=my-volume,target=/app/data nginx\ndocker run --mount type=bind,source=/host/path,target=/container/path nginx\n```\n\n---\n\n## 網路管理\n\n| 指令 | 說明 |\n|------|------|\n| `docker network ls` | 列出所有網路 |\n| `docker network create <name>` | 建立網路 |\n| `docker network connect <network> <container>` | 連接網路 |\n| `docker network disconnect <network> <container>` | 斷開網路 |\n| `docker network rm <name>` | 刪除網路 |\n| `docker network prune` | 刪除未使用的網路 |\n| `docker network inspect <name>` | 查看詳細資訊 |\n\n### 網路類型\n\n| 類型 | 說明 |\n|------|------|\n| `bridge` | 預設，容器透過虛擬橋接器連接 |\n| `host` | 直接使用主機網路 |\n| `none` | 無網路 |\n| `overlay` | 跨主機通訊（Swarm） |\n\n---\n\n## 系統管理\n\n| 指令 | 說明 |\n|------|------|\n| `docker info` | 系統資訊 |\n| `docker version` | 版本資訊 |\n| `docker system df` | 磁碟使用量 |\n| `docker system prune` | 清理未使用資源 |\n| `docker system prune -a --volumes` | 完整清理 |\n| `docker events` | 即時事件 |\n\n---\n\n## Docker Compose\n\n| 指令 | 說明 |\n|------|------|\n| `docker compose up` | 啟動服務 |\n| `docker compose up -d` | 背景啟動 |\n| `docker compose down` | 停止並移除 |\n| `docker compose down -v` | 同時移除 Volume |\n| `docker compose ps` | 列出服務 |\n| `docker compose logs` | 查看日誌 |\n| `docker compose logs -f` | 追蹤日誌 |\n| `docker compose exec <service> <command>` | 執行指令 |\n| `docker compose build` | 建置服務 |\n| `docker compose pull` | 拉取 Image |\n\n---\n\n## Registry 登入\n\n| 指令 | 說明 |\n|------|------|\n| `docker login` | 登入 Docker Hub |\n| `docker login <registry>` | 登入私有 Registry |\n| `docker logout` | 登出 |\n\n---\n\n## 常用組合指令\n\n```bash title=\"常用操作\"\n# 停止所有容器\ndocker stop $(docker ps -q)\n\n# 刪除所有容器\ndocker rm $(docker ps -aq)\n\n# 刪除所有 Image\ndocker rmi $(docker images -q)\n\n# 刪除 dangling Image\ndocker rmi $(docker images -f \"dangling=true\" -q)\n\n# 取得容器 IP\ndocker inspect -f '{{range.NetworkSettings.Networks}}{{.IPAddress}}{{end}}' <container>\n\n# 進入運行中的容器\ndocker exec -it $(docker ps -q -f name=nginx) /bin/sh\n```\n\n---\n\n## Dockerfile 指令\n\n| 指令 | 說明 |\n|------|------|\n| `FROM` | 基礎 Image |\n| `RUN` | 執行指令 |\n| `COPY` | 複製檔案 |\n| `ADD` | 複製檔案（支援 URL、解壓縮） |\n| `WORKDIR` | 工作目錄 |\n| `ENV` | 環境變數 |\n| `EXPOSE` | 暴露 Port |\n| `CMD` | 預設執行指令 |\n| `ENTRYPOINT` | 入口點 |\n| `VOLUME` | 掛載點 |\n| `USER` | 執行身份 |\n| `ARG` | 建置參數 |\n| `LABEL` | 標籤 |\n| `HEALTHCHECK` | 健康檢查 |\n\n---\n\n## 環境變數\n\n| 變數 | 說明 |\n|------|------|\n| `DOCKER_HOST` | Docker 主機位址 |\n| `DOCKER_TLS_VERIFY` | 啟用 TLS 驗證 |\n| `DOCKER_CERT_PATH` | TLS 憑證路徑 |\n| `DOCKER_CONFIG` | 設定檔目錄 |\n"
  },
  {
    "title": "Kubernetes 指令速查表",
    "url": "https://caocharles.github.io/dcka-class-notes/appendix/k8s_cheatsheet/",
    "content": "# Kubernetes 指令速查表\n\n快速參考 kubectl 常用指令，適合日常操作與考試複習。\n\n---\n\n## 基本操作\n\n### 叢集資訊\n\n| 指令 | 說明 |\n|------|------|\n| `kubectl cluster-info` | 叢集資訊 |\n| `kubectl version` | 版本資訊 |\n| `kubectl config view` | 查看設定 |\n| `kubectl config get-contexts` | 列出 Context |\n| `kubectl config use-context <name>` | 切換 Context |\n| `kubectl api-resources` | 列出 API 資源 |\n| `kubectl api-versions` | 列出 API 版本 |\n\n### 資源查詢\n\n| 指令 | 說明 |\n|------|------|\n| `kubectl get <resource>` | 列出資源 |\n| `kubectl get pods` | 列出 Pod |\n| `kubectl get pods -o wide` | 詳細資訊（含 IP、Node） |\n| `kubectl get pods -o yaml` | YAML 格式輸出 |\n| `kubectl get pods -o json` | JSON 格式輸出 |\n| `kubectl get pods -w` | 持續監看 |\n| `kubectl get pods -l app=nginx` | 依標籤過濾 |\n| `kubectl get pods -n <namespace>` | 指定 Namespace |\n| `kubectl get pods --all-namespaces` | 所有 Namespace |\n| `kubectl get all` | 列出常見資源 |\n\n---\n\n## 資源管理\n\n### 建立與套用\n\n| 指令 | 說明 |\n|------|------|\n| `kubectl apply -f <file.yaml>` | 套用設定 |\n| `kubectl apply -f <directory>/` | 套用目錄下所有設定 |\n| `kubectl create -f <file.yaml>` | 建立資源 |\n| `kubectl create deployment <name> --image=<image>` | 建立 Deployment |\n| `kubectl create service clusterip <name> --tcp=80:80` | 建立 Service |\n| `kubectl create configmap <name> --from-literal=key=value` | 建立 ConfigMap |\n| `kubectl create secret generic <name> --from-literal=key=value` | 建立 Secret |\n\n### 編輯與刪除\n\n| 指令 | 說明 |\n|------|------|\n| `kubectl edit <resource> <name>` | 編輯資源 |\n| `kubectl delete <resource> <name>` | 刪除資源 |\n| `kubectl delete -f <file.yaml>` | 依設定檔刪除 |\n| `kubectl delete pods --all` | 刪除所有 Pod |\n| `kubectl delete pods -l app=nginx` | 依標籤刪除 |\n\n### 詳細資訊\n\n| 指令 | 說明 |\n|------|------|\n| `kubectl describe <resource> <name>` | 詳細描述 |\n| `kubectl describe pod <pod-name>` | 描述 Pod |\n| `kubectl describe node <node-name>` | 描述 Node |\n\n---\n\n## Pod 操作\n\n### 執行與存取\n\n| 指令 | 說明 |\n|------|------|\n| `kubectl run <name> --image=<image>` | 建立 Pod |\n| `kubectl exec -it <pod> -- /bin/sh` | 進入 Pod |\n| `kubectl exec <pod> -- <command>` | 執行指令 |\n| `kubectl logs <pod>` | 查看日誌 |\n| `kubectl logs -f <pod>` | 追蹤日誌 |\n| `kubectl logs <pod> -c <container>` | 多容器指定 |\n| `kubectl logs <pod> --previous` | 前一個容器的日誌 |\n| `kubectl logs <pod> --tail=100` | 最後 100 行 |\n| `kubectl port-forward <pod> 8080:80` | Port 轉發 |\n| `kubectl cp <pod>:<path> <local-path>` | 複製檔案 |\n\n---\n\n## Deployment 管理\n\n### 基本操作\n\n| 指令 | 說明 |\n|------|------|\n| `kubectl get deployments` | 列出 Deployment |\n| `kubectl describe deployment <name>` | 詳細描述 |\n| `kubectl scale deployment <name> --replicas=3` | 調整副本 |\n| `kubectl set image deployment/<name> <container>=<image>` | 更新 Image |\n\n### 滾動更新\n\n| 指令 | 說明 |\n|------|------|\n| `kubectl rollout status deployment/<name>` | 查看更新狀態 |\n| `kubectl rollout history deployment/<name>` | 查看歷史 |\n| `kubectl rollout undo deployment/<name>` | 回滾 |\n| `kubectl rollout undo deployment/<name> --to-revision=2` | 回滾到特定版本 |\n| `kubectl rollout restart deployment/<name>` | 重啟 |\n| `kubectl rollout pause deployment/<name>` | 暫停更新 |\n| `kubectl rollout resume deployment/<name>` | 繼續更新 |\n\n---\n\n## Service 管理\n\n| 指令 | 說明 |\n|------|------|\n| `kubectl get services` | 列出 Service |\n| `kubectl get endpoints` | 列出 Endpoints |\n| `kubectl expose deployment <name> --port=80` | 建立 Service |\n| `kubectl expose deployment <name> --type=NodePort --port=80` | NodePort |\n| `kubectl expose deployment <name> --type=LoadBalancer --port=80` | LoadBalancer |\n\n---\n\n## Namespace 管理\n\n| 指令 | 說明 |\n|------|------|\n| `kubectl get namespaces` | 列出 Namespace |\n| `kubectl create namespace <name>` | 建立 Namespace |\n| `kubectl delete namespace <name>` | 刪除 Namespace |\n| `kubectl config set-context --current --namespace=<name>` | 切換預設 Namespace |\n\n---\n\n## ConfigMap & Secret\n\n### ConfigMap\n\n| 指令 | 說明 |\n|------|------|\n| `kubectl get configmaps` | 列出 ConfigMap |\n| `kubectl create configmap <name> --from-literal=key=value` | 從字面值建立 |\n| `kubectl create configmap <name> --from-file=<file>` | 從檔案建立 |\n| `kubectl describe configmap <name>` | 檢視內容 |\n\n### Secret\n\n| 指令 | 說明 |\n|------|------|\n| `kubectl get secrets` | 列出 Secret |\n| `kubectl create secret generic <name> --from-literal=key=value` | 建立 Secret |\n| `kubectl get secret <name> -o jsonpath='{.data.key}' \\| base64 -d` | 解碼 Secret |\n\n---\n\n## PV & PVC\n\n| 指令 | 說明 |\n|------|------|\n| `kubectl get pv` | 列出 PersistentVolume |\n| `kubectl get pvc` | 列出 PersistentVolumeClaim |\n| `kubectl describe pv <name>` | 描述 PV |\n| `kubectl describe pvc <name>` | 描述 PVC |\n\n---\n\n## Node 管理\n\n| 指令 | 說明 |\n|------|------|\n| `kubectl get nodes` | 列出節點 |\n| `kubectl describe node <name>` | 描述節點 |\n| `kubectl top nodes` | 節點資源使用 |\n| `kubectl cordon <node>` | 標記節點不可調度 |\n| `kubectl uncordon <node>` | 取消標記 |\n| `kubectl drain <node>` | 排空節點 |\n| `kubectl taint nodes <node> key=value:NoSchedule` | 加上 Taint |\n\n---\n\n## RBAC\n\n| 指令 | 說明 |\n|------|------|\n| `kubectl get roles` | 列出 Role |\n| `kubectl get clusterroles` | 列出 ClusterRole |\n| `kubectl get rolebindings` | 列出 RoleBinding |\n| `kubectl get clusterrolebindings` | 列出 ClusterRoleBinding |\n| `kubectl auth can-i <verb> <resource>` | 檢查權限 |\n| `kubectl auth can-i <verb> <resource> --as=<user>` | 模擬使用者檢查 |\n\n---\n\n## 疑難排解\n\n| 指令 | 說明 |\n|------|------|\n| `kubectl get events` | 查看事件 |\n| `kubectl get events --sort-by='.lastTimestamp'` | 依時間排序 |\n| `kubectl top pods` | Pod 資源使用 |\n| `kubectl top nodes` | Node 資源使用 |\n| `kubectl describe pod <name>` | 詳細描述 |\n| `kubectl logs <pod> --previous` | 前一個容器日誌 |\n\n---\n\n## 輸出格式\n\n| 格式 | 說明 |\n|------|------|\n| `-o wide` | 額外欄位 |\n| `-o yaml` | YAML 格式 |\n| `-o json` | JSON 格式 |\n| `-o name` | 只顯示名稱 |\n| `-o jsonpath='{...}'` | JSONPath 查詢 |\n| `-o custom-columns=...` | 自訂欄位 |\n\n### JSONPath 範例\n\n```bash\n# 取得 Pod IP\nkubectl get pod <name> -o jsonpath='{.status.podIP}'\n\n# 取得所有 Pod 名稱\nkubectl get pods -o jsonpath='{.items[*].metadata.name}'\n\n# 取得所有 Container Image\nkubectl get pods -o jsonpath='{.items[*].spec.containers[*].image}'\n```\n\n---\n\n## 常用組合指令\n\n```bash title=\"實用指令\"\n# 刪除所有 Evicted Pod\nkubectl delete pods --field-selector=status.phase=Failed --all-namespaces\n\n# 取得所有 Pod 的 Image\nkubectl get pods -o jsonpath=\"{.items[*].spec.containers[*].image}\" | tr -s '[[:space:]]' '\\n' | sort | uniq\n\n# 依記憶體使用量排序 Pod\nkubectl top pods --sort-by=memory\n\n# 快速建立測試 Pod\nkubectl run test --image=busybox --rm -it -- /bin/sh\n\n# 產生 YAML 但不執行\nkubectl create deployment nginx --image=nginx --dry-run=client -o yaml\n\n# 匯出現有資源\nkubectl get deployment nginx -o yaml > nginx-deployment.yaml\n```\n\n---\n\n## minikube 指令\n\n| 指令 | 說明 |\n|------|------|\n| `minikube start` | 啟動 |\n| `minikube stop` | 停止 |\n| `minikube delete` | 刪除 |\n| `minikube status` | 狀態 |\n| `minikube dashboard` | 開啟 Dashboard |\n| `minikube ip` | 取得 IP |\n| `minikube ssh` | SSH 連線 |\n| `minikube service <name>` | 開啟 Service |\n| `minikube addons list` | 列出插件 |\n| `minikube addons enable <name>` | 啟用插件 |\n\n---\n\n## 快捷別名\n\n```bash title=\"建議加入 ~/.bashrc 或 ~/.zshrc\"\nalias k='kubectl'\nalias kgp='kubectl get pods'\nalias kgs='kubectl get services'\nalias kgd='kubectl get deployments'\nalias kgn='kubectl get nodes'\nalias kd='kubectl describe'\nalias kl='kubectl logs'\nalias ke='kubectl exec -it'\nalias ka='kubectl apply -f'\nalias kd='kubectl delete -f'\n\n# 自動補全\nsource <(kubectl completion bash)\nsource <(kubectl completion zsh)\n```\n"
  },
  {
    "title": "疑難排解指南",
    "url": "https://caocharles.github.io/dcka-class-notes/appendix/troubleshooting/",
    "content": "# 疑難排解指南\n\n本章節整理 Docker 與 Kubernetes 常見問題的診斷與解決方法。\n\n---\n\n## Docker 疑難排解\n\n### 1. Docker 服務無法啟動\n\n!!! warning \"症狀\"\n    ```\n    Cannot connect to the Docker daemon at unix:///var/run/docker.sock\n    ```\n\n**診斷步驟**：\n\n```bash title=\"檢查 Docker 服務\"\n# 檢查服務狀態\nsudo systemctl status docker\n\n# 查看服務日誌\nsudo journalctl -u docker -f\n\n# 檢查 socket 檔案\nls -la /var/run/docker.sock\n```\n\n**解決方案**：\n\n```bash\n# 啟動 Docker 服務\nsudo systemctl start docker\n\n# 設定開機自動啟動\nsudo systemctl enable docker\n\n# 如果 socket 問題，重新建立\nsudo rm /var/run/docker.sock\nsudo systemctl restart docker\n```\n\n---\n\n### 2. Permission Denied\n\n!!! warning \"症狀\"\n    ```\n    permission denied while trying to connect to the Docker daemon socket\n    ```\n\n**解決方案**：\n\n```bash\n# 將使用者加入 docker 群組\nsudo usermod -aG docker $USER\n\n# 重新登入或執行\nnewgrp docker\n\n# 驗證群組\ngroups\n```\n\n---\n\n### 3. 容器啟動後立即退出\n\n**診斷步驟**：\n\n```bash title=\"診斷容器退出\"\n# 檢視容器狀態\ndocker ps -a\n\n# 查看退出碼\ndocker inspect <container> --format='{{.State.ExitCode}}'\n\n# 查看日誌\ndocker logs <container>\n\n# 查看最後輸出\ndocker logs --tail 50 <container>\n```\n\n**常見原因與解決**：\n\n| 退出碼 | 原因 | 解決方案 |\n|--------|------|----------|\n| 0 | 正常結束 | 確認 CMD 指令是否為前景程序 |\n| 1 | 應用程式錯誤 | 查看日誌找出錯誤 |\n| 137 | OOM Killed | 增加記憶體限制 |\n| 139 | Segmentation Fault | 檢查應用程式相容性 |\n| 143 | SIGTERM | 正常終止信號 |\n\n```bash title=\"保持容器運行（測試用）\"\n# 使用 sleep 保持運行\ndocker run -d --name test ubuntu sleep infinity\n\n# 或使用 tail\ndocker run -d --name test ubuntu tail -f /dev/null\n```\n\n---\n\n### 4. Image 拉取失敗\n\n!!! warning \"症狀\"\n    ```\n    Error response from daemon: pull access denied\n    Error response from daemon: Get https://registry-1.docker.io/v2/: net/http: request canceled\n    ```\n\n**診斷步驟**：\n\n```bash\n# 確認 Image 名稱\ndocker search <image-name>\n\n# 確認網路連線\nping registry-1.docker.io\n\n# 確認 DNS\nnslookup registry-1.docker.io\n```\n\n**解決方案**：\n\n```bash\n# 如需登入\ndocker login\n\n# 設定 Registry Mirror（國內加速）\n# 編輯 /etc/docker/daemon.json\n{\n  \"registry-mirrors\": [\"https://mirror.example.com\"]\n}\n\n# 重啟 Docker\nsudo systemctl restart docker\n```\n\n---\n\n### 5. 磁碟空間不足\n\n!!! warning \"症狀\"\n    ```\n    no space left on device\n    ```\n\n**診斷步驟**：\n\n```bash title=\"檢查磁碟使用\"\n# 檢視 Docker 磁碟使用\ndocker system df\n\n# 詳細資訊\ndocker system df -v\n\n# 檢查系統磁碟\ndf -h\n```\n\n**解決方案**：\n\n```bash title=\"清理資源\"\n# 清理未使用的資源\ndocker system prune\n\n# 完整清理（包含未使用的 Image 和 Volume）\ndocker system prune -a --volumes\n\n# 刪除 dangling Image\ndocker image prune\n\n# 刪除未使用的 Volume\ndocker volume prune\n\n# 刪除已停止的容器\ndocker container prune\n```\n\n---\n\n### 6. Port 已被佔用\n\n!!! warning \"症狀\"\n    ```\n    Bind for 0.0.0.0:8080 failed: port is already allocated\n    ```\n\n**診斷步驟**：\n\n```bash\n# 查看 Port 使用情況\nsudo lsof -i :8080\n\n# 或使用 netstat\nsudo netstat -tlnp | grep 8080\n\n# 查看 Docker 容器使用的 Port\ndocker ps --format \"table {{.Names}}\\t{{.Ports}}\"\n```\n\n**解決方案**：\n\n```bash\n# 停止佔用 Port 的程序\nsudo kill <PID>\n\n# 或使用其他 Port\ndocker run -d -p 8081:80 nginx\n```\n\n---\n\n### 7. Volume 權限問題\n\n!!! warning \"症狀\"\n    容器內無法寫入掛載的目錄\n\n**解決方案**：\n\n```bash\n# 方法 1：調整主機目錄權限\nsudo chown -R 1000:1000 /path/to/host/dir\n\n# 方法 2：使用特定 UID 執行容器\ndocker run -u $(id -u):$(id -g) -v /host:/container image\n\n# 方法 3：使用 SELinux 標籤（RHEL/CentOS）\ndocker run -v /host:/container:Z image\n```\n\n---\n\n## Kubernetes 疑難排解\n\n### 1. Pod 處於 Pending 狀態\n\n**診斷步驟**：\n\n```bash title=\"診斷 Pending Pod\"\n# 查看 Pod 事件\nkubectl describe pod <pod-name>\n\n# 查看 Events\nkubectl get events --field-selector involvedObject.name=<pod-name>\n\n# 檢查節點資源\nkubectl describe nodes | grep -A 5 \"Allocated resources\"\n```\n\n**常見原因與解決**：\n\n| 原因 | 說明 | 解決方案 |\n|------|------|----------|\n| 資源不足 | CPU/Memory 不夠 | 增加節點或減少 requests |\n| nodeSelector 不符 | 沒有符合的節點 | 調整 selector 或加 label |\n| PVC 未綁定 | PV 不存在或不符合 | 建立符合的 PV |\n| Taint/Toleration | 節點有 Taint | 加上 Toleration |\n\n---\n\n### 2. Pod 處於 CrashLoopBackOff\n\n**診斷步驟**：\n\n```bash title=\"診斷 CrashLoopBackOff\"\n# 查看日誌\nkubectl logs <pod-name>\n\n# 查看前一個容器的日誌\nkubectl logs <pod-name> --previous\n\n# 查看詳細狀態\nkubectl describe pod <pod-name>\n\n# 檢查退出碼\nkubectl get pod <pod-name> -o jsonpath='{.status.containerStatuses[0].lastState.terminated.exitCode}'\n```\n\n**常見原因與解決**：\n\n| 原因 | 解決方案 |\n|------|----------|\n| 應用程式錯誤 | 查看日誌，修復程式 |\n| 設定錯誤 | 檢查 ConfigMap/Secret |\n| 資源不足 | 增加 memory/cpu limits |\n| 健康檢查失敗 | 調整 probe 參數 |\n| 依賴服務未就緒 | 使用 initContainer |\n\n---\n\n### 3. Pod 處於 ImagePullBackOff\n\n**診斷步驟**：\n\n```bash\n# 查看錯誤訊息\nkubectl describe pod <pod-name> | grep -A 10 Events\n\n# 驗證 Image 存在\ndocker pull <image-name>\n```\n\n**解決方案**：\n\n```bash\n# 確認 Image 名稱正確\n# 確認 Registry 存取權限\n\n# 如果是私有 Registry，建立 Secret\nkubectl create secret docker-registry regcred \\\n  --docker-server=<registry> \\\n  --docker-username=<username> \\\n  --docker-password=<password>\n\n# 在 Pod spec 加入 imagePullSecrets\nspec:\n  imagePullSecrets:\n    - name: regcred\n```\n\n---\n\n### 4. Service 無法連接\n\n**診斷步驟**：\n\n```bash title=\"診斷 Service 連線\"\n# 確認 Service 存在\nkubectl get svc <service-name>\n\n# 確認 Endpoints\nkubectl get endpoints <service-name>\n\n# 確認 Pod 運行中\nkubectl get pods -l <selector>\n\n# 從 Pod 內測試連線\nkubectl exec -it <pod> -- curl <service-name>:<port>\n\n# 檢查 DNS\nkubectl exec -it <pod> -- nslookup <service-name>\n```\n\n**常見原因與解決**：\n\n| 原因 | 解決方案 |\n|------|----------|\n| Selector 不符 | 確認 Service selector 與 Pod label 一致 |\n| Pod 未就緒 | 等待 Pod Ready 或檢查 readinessProbe |\n| Port 錯誤 | 確認 port 和 targetPort |\n| NetworkPolicy 阻擋 | 檢查 NetworkPolicy 規則 |\n\n---\n\n### 5. ConfigMap/Secret 更新後 Pod 沒有變化\n\n**原因**：Pod 不會自動重新載入 ConfigMap/Secret\n\n**解決方案**：\n\n```bash\n# 方法 1：重啟 Deployment\nkubectl rollout restart deployment/<name>\n\n# 方法 2：使用 annotation 觸發更新\nkubectl patch deployment <name> -p \\\n  '{\"spec\":{\"template\":{\"metadata\":{\"annotations\":{\"date\":\"'$(date +%s)'\"}}}}}'\n\n# 方法 3：使用 Reloader 工具\n# https://github.com/stakater/Reloader\n```\n\n---\n\n### 6. PVC 處於 Pending 狀態\n\n**診斷步驟**：\n\n```bash\n# 查看 PVC 狀態\nkubectl get pvc <pvc-name>\n\n# 查看詳細資訊\nkubectl describe pvc <pvc-name>\n\n# 查看可用的 PV\nkubectl get pv\n```\n\n**常見原因與解決**：\n\n| 原因 | 解決方案 |\n|------|----------|\n| 無符合的 PV | 建立符合規格的 PV |\n| StorageClass 不存在 | 建立 StorageClass 或指定正確名稱 |\n| 容量不足 | 減少 PVC 請求或增加 PV 容量 |\n| accessModes 不符 | 確認 PV/PVC accessModes 一致 |\n\n---\n\n### 7. Node 處於 NotReady\n\n**診斷步驟**：\n\n```bash\n# 查看節點狀態\nkubectl describe node <node-name>\n\n# 檢查 kubelet 狀態\nssh <node> \"sudo systemctl status kubelet\"\n\n# 查看 kubelet 日誌\nssh <node> \"sudo journalctl -u kubelet -f\"\n```\n\n**常見原因與解決**：\n\n| 原因 | 解決方案 |\n|------|----------|\n| kubelet 停止 | 重啟 kubelet |\n| 網路問題 | 檢查節點網路連線 |\n| 磁碟壓力 | 清理磁碟空間 |\n| 記憶體壓力 | 增加記憶體或減少 Pod |\n\n---\n\n### 8. RBAC 權限問題\n\n!!! warning \"症狀\"\n    ```\n    Error from server (Forbidden): pods is forbidden: User \"xxx\" cannot list resource \"pods\"\n    ```\n\n**診斷步驟**：\n\n```bash\n# 檢查權限\nkubectl auth can-i list pods --as=<user>\n\n# 檢查角色綁定\nkubectl get rolebindings,clusterrolebindings -A | grep <user>\n\n# 詳細檢查\nkubectl describe rolebinding <name> -n <namespace>\n```\n\n**解決方案**：\n\n```bash\n# 建立適當的 Role 和 RoleBinding\nkubectl create role pod-reader --verb=get,list,watch --resource=pods\nkubectl create rolebinding pod-reader-binding --role=pod-reader --user=<user>\n```\n\n---\n\n## 診斷工具\n\n### kubectl debug\n\n```bash\n# 建立除錯 Pod\nkubectl debug node/<node-name> -it --image=busybox\n\n# 為 Pod 建立除錯容器\nkubectl debug <pod-name> -it --image=busybox --target=<container>\n```\n\n### 常用診斷指令\n\n```bash title=\"綜合診斷\"\n# 快速檢查叢集狀態\nkubectl get nodes\nkubectl get pods --all-namespaces | grep -v Running\n\n# 檢查系統 Pod\nkubectl get pods -n kube-system\n\n# 檢查最近事件\nkubectl get events --sort-by='.lastTimestamp' | tail -20\n\n# 檢查資源使用\nkubectl top nodes\nkubectl top pods --all-namespaces\n```\n\n---\n\n## 日誌收集\n\n### 收集診斷資訊\n\n```bash title=\"收集診斷資訊腳本\"\n#!/bin/bash\nOUTPUT_DIR=\"k8s-debug-$(date +%Y%m%d-%H%M%S)\"\nmkdir -p $OUTPUT_DIR\n\n# 節點資訊\nkubectl get nodes -o wide > $OUTPUT_DIR/nodes.txt\nkubectl describe nodes > $OUTPUT_DIR/nodes-describe.txt\n\n# Pod 資訊\nkubectl get pods --all-namespaces -o wide > $OUTPUT_DIR/pods.txt\n\n# Service 資訊\nkubectl get svc --all-namespaces > $OUTPUT_DIR/services.txt\n\n# Events\nkubectl get events --all-namespaces --sort-by='.lastTimestamp' > $OUTPUT_DIR/events.txt\n\n# 壓縮\ntar -czvf $OUTPUT_DIR.tar.gz $OUTPUT_DIR\necho \"診斷資訊已儲存至 $OUTPUT_DIR.tar.gz\"\n```\n"
  },
  {
    "title": "Docker Containers 與 Kubernetes 系統管理",
    "url": "https://caocharles.github.io/dcka-class-notes/",
    "content": "# Docker Containers 與 Kubernetes 系統管理\n\n歡迎來到 **恆逸教育訓練中心 DCKA 課程** 學習筆記！\n\n!!! info \"課程資訊\"\n    - **課程名稱**：Docker Containers 與 Kubernetes 系統管理\n    - **課程代號**：DCKA\n    - **總時數**：21 小時（3 天）\n    - **適合對象**：網路工程師、雲端運算工程師\n\n---\n\n## 課程簡介\n\n本課程旨在幫助學員掌握 Docker Container（容器）技術與 Kubernetes（簡稱 K8S）容器編排平台的核心概念與實務操作。透過理論講解與動手實作，你將學會如何建立、管理和部署容器化應用程式。\n\n```mermaid\ngraph LR\n    A[傳統部署] --> B[虛擬化部署]\n    B --> C[容器化部署]\n    C --> D[容器編排 K8S]\n    \n    style A fill:#f9f,stroke:#333\n    style B fill:#bbf,stroke:#333\n    style C fill:#bfb,stroke:#333\n    style D fill:#ff9,stroke:#333\n```\n\n---\n\n## 學習目標\n\n完成本課程後，你將能夠：\n\n- [x] 理解容器化技術的優勢與應用場景\n- [x] 熟練操作 Docker 容器的建立、啟動、停止與刪除\n- [x] 客製化 Docker Image（映像檔）\n- [x] 使用 Kubernetes 部署與管理容器化應用\n- [x] 實作 WordPress + MySQL 的容器化部署\n\n---\n\n## 課程大綱\n\n### 1. Docker 基礎與管理 (LAB 01-08)\n\n- 環境初始化與基本操作\n- Docker 安裝 (Docker/Podman)\n- Private Registry 建置\n- Persistent Storage 與 WordPress 實作\n\n[:octicons-arrow-right-24: 開始學習](lab01_environment_setup.md)\n\n---\n\n### 2. Docker 進階應用 (LAB 09-10)\n\n- 客製化 Docker Images (commit & Dockerfile)\n- Dockerfile 指令與最佳實踐\n\n[:octicons-arrow-right-24: 開始學習](lab09_commit.md)\n\n---\n\n### 3. Kubernetes 基礎 (LAB 11-15)\n\n- Kubernetes 安裝 (Standalone & Cluster)\n- 常用指令與 Namespaces\n- Rolling Update 與 Service 負載均衡\n\n[:octicons-arrow-right-24: 開始學習](lab11_standalone_k8s.md)\n\n---\n\n### 4. Kubernetes 進階管理 (LAB 16-20)\n\n- 儲存管理 (PV/PVC)\n- 設定管理 (Secret/ConfigMap)\n- 權限控制 (RBAC)\n- 實作：WordPress + MySQL 完整部署\n- Kubernetes Dashboard\n\n[:octicons-arrow-right-24: 開始學習](lab16_pv_pvc.md)\n\n---\n\n## 預備知識\n\n開始本課程之前，建議你具備：\n\n!!! note \"必備知識\"\n    - Linux 基礎指令操作（cd、ls、cat、vim 等）\n    - Linux 基本系統管理概念\n    - 建議具備 RHCE 認證能力或同等經驗\n\n---\n\n## 附錄資源\n\n| 資源 | 說明 |\n|------|------|\n| [Docker 指令速查表](appendix/docker_cheatsheet.md) | 常用 Docker 指令快速參考 |\n| [Kubernetes 指令速查表](appendix/k8s_cheatsheet.md) | 常用 kubectl 指令快速參考 |\n| [疑難排解指南](appendix/troubleshooting.md) | 常見問題與解決方案 |\n\n---\n\n## 相關資源\n\n- :fontawesome-brands-docker: [Docker 官方文件](https://docs.docker.com/)\n- :material-kubernetes: [Kubernetes 官方文件](https://kubernetes.io/docs/)\n- :fontawesome-brands-docker: [Docker Hub](https://hub.docker.com/)\n- :material-podman: [Podman 官方文件](https://podman.io/)\n- :material-school: [恆逸 DCKA 課程頁面](https://www.uuu.com.tw/Course/Show/1552/Docker-Containers與Kubernetes系統管理)\n\n---\n\n!!! tip \"學習建議\"\n    1. 建議按章節順序學習\n    2. 每個章節的 Lab 實作務必親自動手操作\n    3. 遇到問題先查閱 FAQ，再參考疑難排解指南\n    4. 善用指令速查表加速學習\n"
  },
  {
    "title": "LAB 01 LAB 環境初始化",
    "url": "https://caocharles.github.io/dcka-class-notes/lab01_environment_setup/",
    "content": "# LAB 01 LAB 環境初始化\n\n## 學習目標\n\n完成本章節後，你將能夠：\n\n- [ ] 安裝並設定 VMware Workstation\n- [ ] 設定虛擬網路（Virtual Network Editor）\n- [ ] 啟動並驗證六台 Rocky Linux 虛擬機\n\n## 前置知識\n\n開始之前，請確保你已經：\n\n- 準備好 Windows 主機（建議 16GB+ RAM）\n- 下載 DCKA 課程虛擬機映像檔\n- 下載 VMware Workstation 安裝程式\n\n---\n\n## 0.1 安裝 VMware Workstation\n\n### 取得安裝程式\n\n課程提供的 VMware Workstation 17.6.4 安裝檔案位於：\n\n```\nC:\\DCKA-v8 (C:)\\VMware\\VMwareWorkstation_17.6.4\\\n```\n\n![VMware 安裝檔案位置](images/00_environment/vmware_installer.png)\n\n資料夾內包含：\n\n| 檔案 | 說明 |\n|------|------|\n| `VMware-workstation-full-17.6.4-2483....exe` | VMware Workstation 安裝程式 |\n| `md5sum.txt` | MD5 校驗碼 |\n| `md5sum.png` | 校驗碼截圖 |\n\n### 安裝步驟\n\n1. 執行 `VMware-workstation-full-17.6.4-2483....exe`\n2. 依照安裝精靈完成安裝\n3. 安裝完成後重新啟動電腦\n\n!!! tip \"安裝提示\"\n    安裝過程中建議選擇「典型安裝」，使用預設設定即可。\n\n---\n\n## 0.2 設定虛擬網路\n\n### 開啟 Virtual Network Editor\n\n1. 開啟 VMware Workstation\n2. 選擇 **Edit** → **Virtual Network Editor**\n3. 點選 **Change Settings** 取得管理員權限\n\n![Virtual Network Editor](images/00_environment/virtual_network_editor.png)\n\n### 設定 VMnet8 (NAT)\n\n選擇 **VMnet8**（NAT 模式），進行以下設定：\n\n#### 步驟 1：設定 Subnet IP\n\n將 **Subnet IP** 修改為：\n\n```\n192.168.66.0\n```\n\n#### 步驟 2：設定 NAT Settings\n\n點選 **NAT Settings...**，將 **Gateway IP** 設定為：\n\n```\n192.168.66.2\n```\n\n#### 步驟 3：設定 DHCP Settings\n\n點選 **DHCP Settings...**，確認以下設定：\n\n| 設定項目 | 值 |\n|----------|-----|\n| Starting IP address | `192.168.66.128` |\n| Ending IP address | `192.168.66.254` |\n\n!!! warning \"重要\"\n    請確保 Subnet IP 為 `192.168.66.0`，Gateway 為 `192.168.66.2`，否則後續實作可能無法正常連線。\n\n點選 **OK** 儲存設定。\n\n---\n\n## 0.3 網路拓樸與虛擬機\n\n### 網路架構\n\n課程環境使用 VMware Workstation 的 NAT 網路（VMnet8），網段為 `192.168.66.0/24`：\n\n![網路拓樸](images/00_environment/network_topology.jpg)\n\n```mermaid\ngraph TB\n    subgraph \"外部網路\"\n        Internet((Internet))\n        ExtNet[10.0.1.0/24]\n    end\n    \n    subgraph \"VMware NAT Gateway\"\n        NAT[\".254\"]\n    end\n    \n    subgraph \"VMnet8 - 192.168.66.0/24\"\n        Host[\".xxx<br/>VMware Workstation\"]\n        D1[\"docker1<br/>.51\"]\n        D2[\"docker2<br/>.52\"]\n        KS[\"k8s-standalone<br/>.61\"]\n        KM[\"k8s-master1<br/>.71\"]\n        KN1[\"k8s-node1<br/>.81\"]\n        KN2[\"k8s-node2<br/>.82\"]\n    end\n    \n    Internet --> ExtNet --> NAT\n    NAT --> Host\n    Host --> D1\n    Host --> D2\n    Host --> KS\n    Host --> KM\n    Host --> KN1\n    Host --> KN2\n```\n\n### 虛擬機清單與 IP 配置\n\n課程提供六台已預先設定好的 Rocky Linux 9 虛擬機：\n\n![虛擬機資料夾](images/00_environment/vmware_folder.png)\n\n| 虛擬機名稱 | IP 位址 | 用途 |\n|------------|---------|------|\n| `docker1` | 192.168.66.**51** | Docker 實作主機 1 |\n| `docker2` | 192.168.66.**52** | Docker 實作主機 2 |\n| `k8s-standalone` | 192.168.66.**61** | 獨立 Kubernetes 環境（單節點） |\n| `k8s-master1` | 192.168.66.**71** | Kubernetes Master（控制平面）節點 |\n| `k8s-node1` | 192.168.66.**81** | Kubernetes Worker 節點 1 |\n| `k8s-node2` | 192.168.66.**82** | Kubernetes Worker 節點 2 |\n| `mirror` | - | 本地 Mirror 伺服器（套件庫映射） |\n\n!!! info \"IP 配置規則\"\n    - **Docker 環境**：192.168.66.5x\n    - **K8s Standalone**：192.168.66.6x\n    - **K8s Master**：192.168.66.7x\n    - **K8s Worker**：192.168.66.8x\n    - **NAT Gateway**：192.168.66.254\n\n### 啟動所有虛擬機\n\n#### 方法 1：使用批次檔（推薦）\n\n執行 `PowerON-allVM.bat` 一次啟動所有虛擬機：\n\n```batch title=\"PowerON-allVM.bat\"\n\"C:\\Program Files (x86)\\VMware\\VMware Workstation\\vmrun\" -T ws start \"C:\\VMware\\DCKA-Rocky9\\mirror\\mirror.vmx\"\n\"C:\\Program Files (x86)\\VMware\\VMware Workstation\\vmrun\" -T ws start \"C:\\VMware\\DCKA-Rocky9\\docker1\\docker1.vmx\"\n\"C:\\Program Files (x86)\\VMware\\VMware Workstation\\vmrun\" -T ws start \"C:\\VMware\\DCKA-Rocky9\\docker2\\docker2.vmx\"\n\"C:\\Program Files (x86)\\VMware\\VMware Workstation\\vmrun\" -T ws start \"C:\\VMware\\DCKA-Rocky9\\k8s-standalone\\k8s-standalone.vmx\"\n\"C:\\Program Files (x86)\\VMware\\VMware Workstation\\vmrun\" -T ws start \"C:\\VMware\\DCKA-Rocky9\\k8s-master1\\k8s-master1.vmx\"\n\"C:\\Program Files (x86)\\VMware\\VMware Workstation\\vmrun\" -T ws start \"C:\\VMware\\DCKA-Rocky9\\k8s-node1\\k8s-node1.vmx\"\n\"C:\\Program Files (x86)\\VMware\\VMware Workstation\\vmrun\" -T ws start \"C:\\VMware\\DCKA-Rocky9\\k8s-node2\\k8s-node2.vmx\"\n```\n\n!!! tip \"批次檔使用說明\"\n    - 此批次檔使用 VMware 的 `vmrun` 命令列工具\n    - `-T ws` 指定使用 VMware Workstation\n    - `start` 參數表示啟動虛擬機\n\n#### 方法 2：手動啟動\n\n1. 在 VMware Workstation 中依序開啟每台虛擬機的 `.vmx` 檔案\n2. 點選 **Power on this virtual machine**\n\n### 關閉所有虛擬機\n\n課程結束後，可使用 `Shutdown-allVM.bat` 一次關閉所有虛擬機：\n\n```batch title=\"Shutdown-allVM.bat\"\n\"C:\\Program Files (x86)\\VMware\\VMware Workstation\\vmrun\" -T ws stop \"C:\\VMware\\DCKA-Rocky9\\mirror\\mirror.vmx\"\n\"C:\\Program Files (x86)\\VMware\\VMware Workstation\\vmrun\" -T ws stop \"C:\\VMware\\DCKA-Rocky9\\docker1\\docker1.vmx\"\n\"C:\\Program Files (x86)\\VMware\\VMware Workstation\\vmrun\" -T ws stop \"C:\\VMware\\DCKA-Rocky9\\docker2\\docker2.vmx\"\n\"C:\\Program Files (x86)\\VMware\\VMware Workstation\\vmrun\" -T ws stop \"C:\\VMware\\DCKA-Rocky9\\k8s-standalone\\k8s-standalone.vmx\"\n\"C:\\Program Files (x86)\\VMware\\VMware Workstation\\vmrun\" -T ws stop \"C:\\VMware\\DCKA-Rocky9\\k8s-master1\\k8s-master1.vmx\"\n\"C:\\Program Files (x86)\\VMware\\VMware Workstation\\vmrun\" -T ws stop \"C:\\VMware\\DCKA-Rocky9\\k8s-node1\\k8s-node1.vmx\"\n\"C:\\Program Files (x86)\\VMware\\VMware Workstation\\vmrun\" -T ws stop \"C:\\VMware\\DCKA-Rocky9\\k8s-node2\\k8s-node2.vmx\"\n```\n\n!!! warning \"正確關機\"\n    使用 `stop` 命令會執行正常關機程序（相當於按下電源按鈕）。如需強制關機，可改用 `stop hard` 參數，但不建議經常使用。\n\n### 驗證虛擬機狀態\n\n啟動完成後，應該可以看到所有虛擬機都在運行中，並顯示 Rocky Linux 登入畫面：\n\n![虛擬機執行中](images/00_environment/vms_running.png)\n\n### 登入資訊\n\n| 帳號 | 密碼 |\n|------|------|\n| `root` | `container` |\n\n!!! success \"環境準備完成\"\n    當所有虛擬機都成功啟動並可以登入後，即可開始進行 Docker 與 Kubernetes 實作練習。\n\n---\n\n## 0.4 Mirror 伺服器\n\n課程提供本地 Mirror 伺服器，加速套件下載並支援離線環境。\n\n### Mirror 網址\n\n| 網路環境 | 網址 |\n|----------|------|\n| **內部網路**（VMnet8） | `http://192.168.66.248/k8s/` |\n| **外部網路**（教室網路） | `http://10.0.1.249/k8s/` |\n\n![內部 Mirror 伺服器](images/00_environment/mirror_internal.png)\n\n![外部 Mirror 伺服器](images/00_environment/mirror_external.png)\n\n### Mirror 資源內容\n\n| 資料夾/檔案 | 用途 |\n|-------------|------|\n| `248.repo` | YUM/DNF 套件庫設定檔 |\n| `ContainerImages/` | Docker/Container 映像檔 |\n| `Packages/` | RPM 套件 |\n| `command.txt` | 指令參考 |\n| `docs/` | 課程文件 |\n| `scripts/` | 自動化腳本 |\n| `yaml/` | Kubernetes YAML 設定檔 |\n| `VMwareWorkstation_17.6.4/` | VMware 安裝程式（外部網路） |\n\n!!! tip \"為什麼需要 Mirror？\"\n    - **加速下載**：從本地伺服器下載比網際網路快很多\n    - **離線環境**：教室可能沒有對外網路\n    - **版本一致**：確保所有學員使用相同版本的套件。\n\n---\n\n## 常見問題\n\n??? question \"Q1：虛擬機無法開機，顯示 VT-x 錯誤\"\n    **原因**：BIOS 未啟用虛擬化技術\n    \n    **解決方案**：\n    1. 重新啟動電腦，進入 BIOS 設定\n    2. 找到 Intel VT-x 或 AMD-V 選項\n    3. 將其設定為 Enabled\n    4. 儲存並重新啟動\n\n??? question \"Q2：網路無法連線\"\n    **原因**：Virtual Network Editor 設定錯誤\n    \n    **解決方案**：\n    1. 確認 VMnet8 的 Subnet IP 為 `192.168.66.0`\n    2. 確認 Gateway IP 為 `192.168.66.2`\n    3. 確認虛擬機網路介面設定為 NAT 模式\n\n??? question \"Q3：記憶體不足\"\n    **原因**：主機記憶體不足以運行所有虛擬機\n    \n    **解決方案**：\n    - 依序啟動需要的虛擬機，不要一次全部啟動\n    - 或升級主機記憶體至 16GB 以上\n\n---\n\n## 小結\n\n本章節重點回顧：\n\n- ✅ **VMware 安裝**：安裝 VMware Workstation 17.6.4\n- ✅ **網路設定**：VMnet8 設定為 192.168.66.0/24 網段\n- ✅ **虛擬機啟動**：六台 Rocky Linux 虛擬機全部啟動\n- ✅ **環境驗證**：確認可以正常登入虛擬機\n\n## 下一步\n\n環境準備完成後，請繼續前往 [LAB 02 安裝 DOCKER/DOCKER-CE](lab02_docker_install.md)\n"
  },
  {
    "title": "LAB 02 安裝 DOCKER/DOCKER-CE",
    "url": "https://caocharles.github.io/dcka-class-notes/lab02_docker_install/",
    "content": "# LAB 02 安裝 DOCKER/DOCKER-CE\n\n## 學習目標\n\n完成本 Lab 後，你將能夠：\n\n- [ ] 理解 RHEL/Rocky Linux 預設 `docker` 指令的行為 (Podman Emulation)\n- [ ] 移除預設的 `podman-docker` 套件\n- [ ] 設定 Docker CE 官方 Repository\n- [ ] 安裝並啟動 Docker CE (Community Edition)\n- [ ] 使用 `docker pull` 下載 Image 並備份\n\n---\n\n## 1.1 核心概念與比較\n\n在 RHEL/CentOS 9 環境中，套件名稱與背後的技術可能會讓人混淆。以下是三者的主要差異：\n\n| 項目 | **docker (Red Hat 套件)** | **docker-ce (Docker Inc. 套件)** | **podman** |\n|------|---------------------------|----------------------------------|------------|\n| **來源** | Red Hat 官方 Repository | Docker 官方 Repository | Red Hat 官方 Repository |\n| **本質** | 其實是 **podman-docker** | 原生 **Docker Engine** | 下一代容器工具 |\n| **守護行程 (Daemon)** | 無 (Daemonless) | **dockerd** (必須啟動服務) | 無 (Daemonless) |\n| **架構** | 模擬 Docker CLI 指令 | Client-Server 架構 | Fork/Exec 模型 |\n| **Root 權限** | 支援 Rootless | 預設需要 Root (Rootless 需設定) | 原生支援 Rootless |\n| **指令相容性** | 高度相容 | 原生指令 | 高度相容 Docker |\n\n!!! warning \"為什麼 `dnf install docker` 裝的是 Podman？\"\n    Red Hat 為了推廣自己的容器技術 (Podman/Buildah/Skopeo)，在 RHEL 8/9 的套件庫中，將 `docker` 套件指向了 `podman-docker`。這個套件主要提供一個 shell script，將 `docker` 指令轉導給 `podman` 執行。\n    \n    若你習慣使用原本的 Docker Daemon (例如需要與舊有的 Docker Compose 流程整合)，則必須移除此套件，並安裝 `docker-ce`。\n\n---\n\n## 實作步驟\n\n### 步驟 1：觀察預設的 Docker 套件 (Podman)\n\n在 RHEL 9 / Rocky Linux 9 中，官方預設的 `docker` 指令其實是 `podman` 的模擬器。\n\n1.  **安裝預設 docker 套件**\n    ```bash\n    dnf install docker -y\n    ```\n    > **指令說明**：\n    > - `dnf`: (Dandified YUM) 是 RHEL 8/9 與 Rocky Linux 的預設套件管理工具，用來取代舊的 `yum`。\n    > - `install`: 安裝套件。\n    > - `-y`: 自動回答 \"Yes\" 確認安裝，不需人工介入。\n\n    ![安裝預設 docker 套件](images/lab02/dnf_install_podman.png)\n\n2.  **檢查 docker 指令來源**\n    ```bash\n    ls -l /usr/bin/docker\n    file /usr/bin/docker\n    cat /usr/bin/docker\n    ```\n    > 你會發現 `/usr/bin/docker` 其實是一個 Shell Script，內容是執行 `/usr/bin/podman`。\n    > ```bash\n    > exec /usr/bin/podman \"$@\"\n    > ```\n\n3.  **嘗試啟動 Docker 服務**\n    ```bash\n    systemctl start docker\n    ```\n    > ❌ **失敗**：因為根本沒有安裝真正的 Docker Daemon，顯示 `Unit docker.service not found`。\n\n4.  **檢查版本**\n    ```bash\n    docker version\n    ```\n    > 輸出顯示 `Client: Podman Engine`，並提示 `Emulate Docker CLI using podman`。\n\n---\n\n### 步驟 2：移除 Podman-Docker 並安裝 Docker CE\n\n為了使用原生的 Docker Engine，我們需要移除模擬套件並安裝官方版本。\n\n1.  **移除預設套件**\n    ```bash\n    dnf remove docker -y\n    ```\n    > 這會移除 `podman-docker` 套件。\n\n2.  **新增 Docker CE Repository**\n    ```bash\n    dnf config-manager --add-repo=https://download.docker.com/linux/centos/docker-ce.repo\n    ```\n    > **指令說明**：\n    > - `config-manager`: `dnf` 的外掛模組，用於管理設定。\n    > - `--add-repo`: 新增一個外部的套件來源 (Repository)。這裡我們指向 Docker 官方為 CentOS 維護的 Repo。\n\n    > 驗證 Repo 是否加入成功：\n    > ```bash\n    > cat /etc/yum.repos.d/docker-ce.repo\n    > ```\n\n3.  **安裝 Docker CE**\n    ```bash\n    dnf install docker-ce -y\n    ```\n    > 安裝過程中會下載 `docker-ce` (Daemon), `docker-ce-cli` (指令工具), `containerd.io` (Runtime) 等套件。\n\n---\n\n### 步驟 3：啟動 Docker 服務\n\n安裝完成後，真正的 Docker Daemon (`dockerd`) 就已經就緒了。\n\n1.  **啟動並設定開機自動啟動**\n    ```bash\n    systemctl start docker\n    systemctl enable docker\n    ```\n    > **指令說明**：\n    > - `systemctl`: 用於管理系統服務 (Systemd)。\n    > - `start`: 立即啟動服務。\n    > - `enable`: 設定服務在開機時自動啟動。\n\n2.  **檢查服務狀態**\n    ```bash\n    systemctl status docker\n    ```\n    > ✅ 應顯示 `Active: active (running)`。\n\n3.  **檢查版本**\n    ```bash\n    docker version\n    ```\n    > 現在應該顯示 `Client: Docker Engine - Community` 和 `Server: Docker Engine - Community`。\n\n---\n\n### 步驟 4：下載與管理 Container Image\n\n1.  **下載映像檔**\n    ```bash\n    docker pull rockylinux:9\n    ```\n\n2.  **查看映像檔列表**\n    ```bash\n    docker images\n    ```\n\n3.  **查看映像檔歷史**\n    ```bash\n    docker history rockylinux:9\n    ```\n\n4.  **備份映像檔 (Docker Save)**\n    將映像檔匯出為 tar 檔案。\n    ```bash\n    docker save --output=/root/rockylinux-9.tar rockylinux:9\n    ls -lh /root/rockylinux-9.tar\n    ```\n\n---\n\n## 小結\n\n在本 Lab 中，我們發現 Linux 發行版可能會用 Podman 來模擬 Docker。若要使用標準 Docker Engine，必須手動設定 Docker 官方 Repository 並安裝 `docker-ce`。\n"
  },
  {
    "title": "Lab03 Podman",
    "url": "https://caocharles.github.io/dcka-class-notes/lab03_podman/",
    "content": "﻿# LAB 03 安裝 Podman\n\n## 學習目標\n\n完成本 Lab 後，你將能夠：\n\n- [ ] 理解 Podman 的核心架構 (Daemonless & Rootless)\n- [ ] 在 Linux 上安裝 Podman\n- [ ] 驗證 Podman 無需守護行程 (Daemon) 即可運作\n- [ ] 處理 Image Registry 搜尋順序與驗證問題\n\n---\n\n## 1.1 Podman 簡介\n\n**Podman** (Pod Manager) 是一個由 Red Hat 開發的開源容器引擎，用於在 Linux 系統上開發、管理和執行 OCI (Open Container Initiative) 容器。\n\n- **官方網站**：[https://podman.io/](https://podman.io/)\n- **最新文件**：[Podman Documentation](https://docs.podman.io/en/latest/)\n\n### Podman 與 Docker 的關鍵差異\n\n| 特性 | Docker | Podman |\n|------|--------|--------|\n| **架構** | **Client-Server** (依賴 dockerd 守護行程) | **Daemonless** (直接 Fork/Exec 程序) |\n| **執行權限** | 預設需要 **Root** | 原生支援 **Rootless** (一般使用者可執行) |\n| **Pod 支援** | 需透過 Docker Compose 或 K8S | **原生支援 Pod** (可在一個 Pod 跑多個容器) |\n| **服務相依** | 若 Daemon 掛掉，所有容器都受影響 | 容器是獨立程序，互不影響 |\n| **Systemd** | 整合較弱 | 原生整合，容易將容器作成系統服務 |\n\n!!! quote \"Podman 的設計理念\"\n    \"Alias docker=podman\" —— Podman 的 CLI 指令與 Docker 高度相容，絕大多數情況下，你可以直接把 `docker` 指令換成 `podman` 執行。\n\n---\n\n## 實作步驟\n\n### 步驟 1：安裝 Podman 套件\n\n在 RHEL 9 / Rocky Linux 9 中，Podman 通常已經預裝。如果沒有，可以使用 `dnf` 安裝。\n\n1.  **安裝 Podman**\n    ```bash\n    dnf install podman -y\n    ```\n    > **指令說明**：\n    > - 套件名稱就是 `podman`，不需要像 Docker 還要去找 `docker-ce`。\n    > - 如果系統顯示 `Nothing to do`，表示已經安裝過了。\n\n    ![安裝 podman](images/lab03/podman_install.png)\n\n2.  **檢查版本與環境資訊**\n    ```bash\n    podman version\n    podman info\n    ```\n    > - `podman version`: 顯示 Client/Server 版本（注意：Podman 的 Client 和 Server 通常是同一個 binary，除非是遠端操作）。\n    > - `podman info`: 顯示詳細的系統設定，包括 Storage Driver (通常是 overlay)、cgroup version (v2) 以及預設的 Registry。\n\n---\n\n### 步驟 2：驗證 Daemonless 架構（無需啟動服務）\n\n這是 Podman 最特別的地方：**你不需要啟動任何服務**。\n\n1.  **嘗試尋找 podman 服務**\n    在你安裝完 Docker 時，通常下一步是 `systemctl start docker`。但在 Podman：\n    \n    > 你**不需要**執行 `systemctl start podman`。\n    \n    Podman 是一個單純的 binary執行檔。當你執行 `podman run` 時，它會直接在當前使用者的權限下產生容器程序。\n\n2.  **為什麼會有 `podman.socket`？**\n    如果你檢查 systemd，可能會看到 `podman.socket` 或 `podman.service`。這主要是為了提供 API 給遠端工具（如 Docker Compose 或 IDE）連線使用，對於本地 CLI 操作並非必要。\n\n---\n\n### 步驟 3：使用 Podman 下載 Container Image\n\nPodman 預設會搜尋多個 Registry。\n\n1.  **查看目前的 Image**\n    ```bash\n    podman images\n    ```\n\n2.  **嘗試下載 MySQL Image**\n    執行以下指令：\n    ```bash\n    podman pull mysql\n    ```\n\n    **觀察輸出結果：**\n    \n    Podman 會依序嘗試設定檔 (`/etc/containers/registries.conf`) 中定義的 Registry：\n\n    1.  ❌ **`registry.access.redhat.com/mysql:latest`**\n        > `name unknown: Repo not found` (Red Hat 官方庫沒有這個 Image)\n    \n    2.  ❌ **`registry.redhat.io/mysql:latest`**\n        > `unauthorized: Please login` (需要 Red Hat 訂閱帳號才能存取)\n    \n    3.  ✅ **`docker.io/library/mysql:latest`**\n        > 成功從 Docker Hub 下載。\n\n3.  **驗證下載結果**\n    ```bash\n    podman images\n    ```\n    > 應該會看到來自 `docker.io/library/mysql` 的 Image。\n\n!!! tip \"Registry 搜尋順序並非隨機\"\n    RHEL/CentOS 預設的 `/etc/containers/registries.conf` 檔案定義了搜尋順序 (Search Registries)。這就是為什麼 Podman 會先去問 Red Hat，最後才問 Docker Hub。\n    而 Docker CE 預設只會找 Docker Hub (`docker.io`)。\n"
  },
  {
    "title": "使用 wget 下載腳本",
    "url": "https://caocharles.github.io/dcka-class-notes/lab04_docker_hub_rate_limit/",
    "content": "﻿# LAB 04 如何檢查 Docker Hub Rate Limiting\n\n## 學習目標\n\n完成本 Lab 後，你將能夠：\n\n- [ ] 理解 Docker Hub 的下載限制 (Rate Limiting)\n- [ ] 使用 `curl` 與 `jq` 指令檢查當前的 Rate Limit 狀態\n- [ ] 比較匿名使用者與免費帳號 (Free Account) 的限制差異\n\n---\n\n## 1.1 什麼是 Docker Hub Rate Limiting？\n\nDocker Hub 為了防止資源濫用，對 Container Image 的 `pull` (下載) 次數進行了限制：\n\n| 帳號類型 | 限制內容 |\n|----------|----------|\n| **匿名使用者 (Anonymous)** | 每 6 小時 **100** 次 pull (以 IP 為準) |\n| **免費帳號 (Free Account)** | 每 6 小時 **200** 次 pull (以帳號為準) |\n| **Pro / Team / Business** | **5000** 次 (每日) 或 無限制 |\n\n當你遇到 `Before you can look around... 429 Too Many Requests` 錯誤時，通常就是被限流了。\n\n---\n\n## 實作步驟\n\n### 步驟 1：安裝必要工具 jq\n\n為了方便解析 Docker Hub API 回傳的 JSON 格式 Token，我們需要安裝 `jq` 工具。\n\n1.  **安裝 jq**\n    ```bash\n    yum install jq -y\n    ```\n    > **指令說明**：`jq` 是一個輕量級且靈活的 command-line JSON 處理器。\n\n    ![安裝 jq 與檢查 limit](images/lab04/check_limit.png)\n\n---\n\n### 步驟 2：下載檢查腳本\n\n我們使用一段 Shell Script 來簡化檢查流程。這個 Script 會向 Docker Hub 申請 Token 並查詢 Header 資訊。\n\n1.  **下載 Script** (假設課堂環境提供)\n    ```bash\n    # 使用 wget 下載腳本\n    wget http://10.0.1.248/k8s/scripts/check_docker_pull_rate_limit.sh\n    \n    # 若上述連結無法連線 (Connection refused)，請嘗試備用位置\n    wget http://10.0.1.249/k8s/scripts/check_docker_pull_rate_limit.sh\n    ```\n\n2.  **賦予執行權限**\n    ```bash\n    chmod 755 check_docker_pull_rate_limit.sh\n    ```\n\n---\n\n### 步驟 3：檢查匿名使用者限制 (Anonymous)\n\n1.  **執行 Script**\n    ```bash\n    ./check_docker_pull_rate_limit.sh\n    ```\n\n2.  **觀察輸出結果**\n    ```yaml\n    ratelimit-limit: 100;w=21600\n    ratelimit-remaining: 58;w=21600\n    docker-ratelimit-source: 118.163.116.129\n    ```\n    > **輸出解析**：\n    > - `ratelimit-limit: 100;w=21600`: 限制為每 21600 秒 (6小時) **100** 次。\n    > - `ratelimit-remaining: 58`: 目前剩餘 **58** 次額度。\n    > - `docker-ratelimit-source`: 識別來源 IP。\n\n---\n\n### 步驟 4：檢查免費帳號限制 (Free Account)\n\n若要獲得更高的額度，可以登入 Docker Hub 帳號。\n\n1.  **修改 Script 加入認證資訊**\n    編輯 `check_docker_pull_rate_limit.sh`，將你的 Docker Hub 帳號密碼填入變數 (或是透過 `docker login` 後修改 Script 以使用 Token)。\n    \n    *假設 Script 支援以變數方式帶入帳密：*\n    ```bash\n    # 編輯腳本填入 USER=\"你的帳號\" PASSWORD=\"你的密碼\"\n    vi check_docker_pull_rate_limit.sh\n    ```\n\n    !!! tip \"手動檢查指令 (參考)\"\n        如果沒有 Script，你也可以用以下指令手動檢查 (記得替換帳密)：\n        ```bash\n        # 1. 取得 Token\n        TOKEN=$(curl -s -u \"你的帳號:你的密碼\" \"https://auth.docker.io/token?service=registry.docker.io&scope=repository:ratelimitpreview/test:pull\" | jq -r .token)\n        \n        # 2. 查詢 Header\n        curl --head -H \"Authorization: Bearer $TOKEN\" https://registry-1.docker.io/v2/ratelimitpreview/test/manifests/latest\n        ```\n\n2.  **再次執行 Script**\n    ```bash\n    ./check_docker_pull_rate_limit.sh\n    ```\n\n3.  **預期結果**\n    ```yaml\n    ratelimit-limit: 200;w=21600   <-- 額度變為 200\n    ratelimit-remaining: 198;w=21600\n    docker-ratelimit-source: [你的帳號UUID]\n    ```\n    > 登入後，`ratelimit-source` 通常會變成你的 User ID，且額度會提升至 **200** 次。\n\n---\n\n## 小結\n\n- **匿名下載**：方便但限制嚴格 (100次/6hr)，多台機器共用 Public IP 時容易被鎖。\n- **登入下載**：建議在 Server 上透過 `docker login` 登入，可將額度提升至 (200次/6hr)，或購買 Pro 方案解除限制。\n"
  },
  {
    "title": "LAB 05 建置 private registry",
    "url": "https://caocharles.github.io/dcka-class-notes/lab05_private_registry/",
    "content": "# LAB 05 建置 private registry\n\n## 學習目標\n\n完成本章節後，你將能夠：\n\n- [ ] 區分 Public Registry 與 Private Registry 的用途\n- [ ] 熟練操作 Docker 基本指令（run、exec、logs、inspect 等）\n- [ ] 設定 Docker 持久化儲存（Volumes 與 Bind Mounts）\n- [ ] 理解並設定 Docker 網路\n- [ ] 從 Docker Hub 搜尋、拉取、推送 Image\n- [ ] 完成 WordPress + MySQL 容器化部署實作\n\n## 前置知識\n\n開始之前，請確保你已經：\n\n- 完成第 1 章的內容\n- Docker 已正確安裝並可執行\n- 理解 Image 與 Container 的關係\n\n---\n\n## 2.1 Public Registry 與 Private Registry\n\n### 什麼是 Registry？\n\nRegistry（倉庫）是用來儲存和分發 Docker Image 的服務。就像 GitHub 儲存程式碼一樣，Registry 儲存容器映像檔。\n\n```mermaid\ngraph LR\n    Dev[開發者] -->|push| Registry[(Registry)]\n    Registry -->|pull| Server1[伺服器 1]\n    Registry -->|pull| Server2[伺服器 2]\n    Registry -->|pull| Server3[伺服器 3]\n```\n\n### Public Registry\n\n公開的 Registry 服務，任何人都可以存取公開的 Image。\n\n| Registry | 說明 | 網址 |\n|----------|------|------|\n| **Docker Hub** | 官方預設 Registry，最大的公開 Image 倉庫 | hub.docker.com |\n| **Quay.io** | Red Hat 提供的 Registry | quay.io |\n| **GitHub Container Registry** | GitHub 提供的容器 Registry | ghcr.io |\n| **Google Container Registry** | Google Cloud 提供 | gcr.io |\n| **Amazon ECR Public** | AWS 提供的公開 Registry | public.ecr.aws |\n\n!!! tip \"Docker Hub 使用技巧\"\n    - **官方 Image**：沒有前綴，如 `nginx`、`mysql`、`redis`\n    - **社群 Image**：包含使用者名稱，如 `bitnami/nginx`\n    - **標籤**：指定版本，如 `nginx:1.25`、`nginx:alpine`\n\n### Private Registry\n\n私有 Registry 用於儲存企業內部的 Image，不對外公開。\n\n#### 常見私有 Registry 方案\n\n| 方案 | 說明 | 適用場景 |\n|------|------|----------|\n| **Docker Registry** | Docker 官方提供的輕量級 Registry | 小型團隊、測試環境 |\n| **Harbor** | VMware 開源的企業級 Registry | 大型企業、需要 RBAC |\n| **Nexus Repository** | Sonatype 的多功能倉庫 | 已使用 Nexus 管理套件 |\n| **JFrog Artifactory** | 企業級製品管理 | 大型企業 |\n| **AWS ECR** | AWS 私有 Registry | AWS 雲端環境 |\n| **Azure ACR** | Azure 私有 Registry | Azure 雲端環境 |\n| **GCP GCR** | Google 私有 Registry | GCP 雲端環境 |\n\n#### 建立簡易 Private Registry\n\n```bash title=\"使用 Docker 建立私有 Registry\"\n# 啟動 Registry Container\ndocker run -d \\\n  --name my-registry \\\n  -p 5000:5000 \\\n  -v registry-data:/var/lib/registry \\\n  registry:2\n\n# 為 Image 加上私有 Registry 標籤\ndocker tag nginx:latest localhost:5000/my-nginx:v1\n\n# 推送到私有 Registry\ndocker push localhost:5000/my-nginx:v1\n\n# 從私有 Registry 拉取\ndocker pull localhost:5000/my-nginx:v1\n```\n\n!!! warning \"生產環境注意事項\"\n    - 私有 Registry 應配置 TLS 憑證\n    - 設定適當的存取控制\n    - 定期備份 Registry 資料\n    - 考慮使用企業級方案如 Harbor\n\n---\n\n## 2.2 Docker 基本操作\n\n### Container 生命週期管理\n\n```mermaid\nstateDiagram-v2\n    [*] --> Created: docker create\n    Created --> Running: docker start\n    Running --> Paused: docker pause\n    Paused --> Running: docker unpause\n    Running --> Stopped: docker stop\n    Stopped --> Running: docker start\n    Stopped --> Removed: docker rm\n    Running --> Removed: docker rm -f\n    Removed --> [*]\n```\n\n### 核心指令詳解\n\n#### docker run - 執行容器\n\n```bash title=\"docker run 常用選項\"\n# 基本執行\ndocker run nginx\n\n# 背景執行 (detached)\ndocker run -d nginx\n\n# 指定名稱\ndocker run -d --name my-nginx nginx\n\n# Port 對應 (主機:容器)\ndocker run -d -p 8080:80 nginx\n\n# 環境變數\ndocker run -d -e MYSQL_ROOT_PASSWORD=secret mysql\n\n# 自動刪除（結束後自動移除）\ndocker run --rm nginx echo \"Hello\"\n\n# 互動模式\ndocker run -it ubuntu /bin/bash\n\n# 資源限制\ndocker run -d --memory=\"512m\" --cpus=\"1.0\" nginx\n\n# 重啟策略\ndocker run -d --restart=always nginx\n```\n\n!!! note \"docker run 選項說明\"\n    | 選項 | 說明 |\n    |------|------|\n    | `-d` | Detached mode，背景執行 |\n    | `-it` | 互動模式 + TTY |\n    | `-p` | Port mapping |\n    | `-v` | Volume mapping |\n    | `-e` | 環境變數 |\n    | `--name` | 指定容器名稱 |\n    | `--rm` | 結束後自動刪除 |\n    | `--restart` | 重啟策略 |\n\n#### docker exec - 執行指令\n\n```bash title=\"在運行中的容器執行指令\"\n# 執行單一指令\ndocker exec my-nginx cat /etc/nginx/nginx.conf\n\n# 進入互動式 Shell\ndocker exec -it my-nginx /bin/bash\n\n# 以特定使用者執行\ndocker exec -u root my-nginx whoami\n\n# 設定環境變數\ndocker exec -e VAR=value my-nginx printenv VAR\n```\n\n#### docker logs - 檢視日誌\n\n```bash title=\"Container 日誌操作\"\n# 檢視全部日誌\ndocker logs my-nginx\n\n# 持續追蹤日誌\ndocker logs -f my-nginx\n\n# 顯示最後 N 行\ndocker logs --tail 100 my-nginx\n\n# 顯示時間戳記\ndocker logs -t my-nginx\n\n# 指定時間範圍\ndocker logs --since 2024-01-01 my-nginx\ndocker logs --since 10m my-nginx  # 最近 10 分鐘\n```\n\n#### docker inspect - 檢視詳細資訊\n\n```bash title=\"檢視容器/映像檔詳細資訊\"\n# 檢視容器詳細資訊（JSON 格式）\ndocker inspect my-nginx\n\n# 取得特定資訊（使用 Go 模板）\ndocker inspect --format='{{.NetworkSettings.IPAddress}}' my-nginx\n\n# 取得 Port 對應\ndocker inspect --format='{{range $p, $conf := .NetworkSettings.Ports}}{{$p}} -> {{(index $conf 0).HostPort}}{{end}}' my-nginx\n\n# 取得掛載資訊\ndocker inspect --format='{{json .Mounts}}' my-nginx | jq .\n```\n\n#### 其他常用指令\n\n```bash title=\"容器管理指令\"\n# 列出運行中的容器\ndocker ps\n\n# 列出所有容器（包含已停止）\ndocker ps -a\n\n# 停止容器\ndocker stop my-nginx\n\n# 啟動已停止的容器\ndocker start my-nginx\n\n# 重啟容器\ndocker restart my-nginx\n\n# 刪除容器\ndocker rm my-nginx\n\n# 強制刪除運行中的容器\ndocker rm -f my-nginx\n\n# 刪除所有已停止的容器\ndocker container prune\n\n# 檢視容器資源使用\ndocker stats\n\n# 複製檔案到容器\ndocker cp ./index.html my-nginx:/usr/share/nginx/html/\n\n# 從容器複製檔案\ndocker cp my-nginx:/etc/nginx/nginx.conf ./nginx.conf\n```\n\n---\n\n## 2.3 Persistent Storage\n\n### 為什麼需要持久化儲存？\n\nContainer 預設的資料是短暫的（ephemeral），當 Container 被刪除時，所有資料都會消失。\n\n```mermaid\ngraph LR\n    subgraph \"沒有持久化\"\n        C1[Container] --> RW1[讀寫層]\n        RW1 -.->|刪除容器| X[資料消失]\n    end\n    \n    subgraph \"使用持久化\"\n        C2[Container] --> RW2[讀寫層]\n        C2 --> V[Volume/Bind Mount]\n        V -->|容器刪除| V\n    end\n```\n\n### 三種儲存方式\n\n| 類型 | 說明 | 適用場景 |\n|------|------|----------|\n| **Volume** | 由 Docker 管理的儲存區域 | 生產環境、資料持久化 |\n| **Bind Mount** | 將主機目錄掛載到容器 | 開發環境、程式碼同步 |\n| **tmpfs Mount** | 儲存在主機記憶體中 | 暫存敏感資料 |\n\n### Volumes\n\n```bash title=\"Volume 基本操作\"\n# 建立 Volume\ndocker volume create my-data\n\n# 列出所有 Volume\ndocker volume ls\n\n# 檢視 Volume 詳細資訊\ndocker volume inspect my-data\n\n# 使用 Volume 執行容器\ndocker run -d \\\n  --name my-nginx \\\n  -v my-data:/usr/share/nginx/html \\\n  nginx\n\n# 刪除 Volume\ndocker volume rm my-data\n\n# 清理未使用的 Volume\ndocker volume prune\n```\n\n!!! tip \"Volume 位置\"\n    Docker Volume 預設儲存在：\n    \n    - **Linux**: `/var/lib/docker/volumes/`\n    - **macOS/Windows**: Docker Desktop 管理的虛擬磁碟內\n\n### Bind Mounts\n\n```bash title=\"Bind Mount 使用方式\"\n# 使用 -v 語法\ndocker run -d \\\n  --name my-nginx \\\n  -v /path/on/host:/usr/share/nginx/html \\\n  -p 8080:80 \\\n  nginx\n\n# 使用 --mount 語法（推薦）\ndocker run -d \\\n  --name my-nginx \\\n  --mount type=bind,source=/path/on/host,target=/usr/share/nginx/html \\\n  -p 8080:80 \\\n  nginx\n\n# 唯讀掛載\ndocker run -d \\\n  --name my-nginx \\\n  -v /path/on/host:/usr/share/nginx/html:ro \\\n  nginx\n```\n\n!!! example \"開發環境範例\"\n    ```bash title=\"前端開發即時同步\"\n    # 將本地專案目錄掛載到容器\n    docker run -d \\\n      --name frontend-dev \\\n      -v $(pwd)/src:/app/src \\\n      -p 3000:3000 \\\n      node:18\n    ```\n    \n    修改本地 `src` 目錄的檔案會立即反映到容器中。\n\n### Volume vs Bind Mount 比較\n\n| 比較項目 | Volume | Bind Mount |\n|----------|--------|------------|\n| 儲存位置 | Docker 管理 | 指定主機路徑 |\n| 可移植性 | 高 | 依賴主機路徑 |\n| 效能 | 較佳 | 取決於主機檔案系統 |\n| 備份 | 容易 | 需手動處理 |\n| 適用場景 | 生產環境 | 開發環境 |\n\n---\n\n## 2.4 Docker Network\n\n### 預設網路類型\n\nDocker 提供多種網路驅動，滿足不同的使用場景。\n\n```mermaid\ngraph TB\n    subgraph \"Bridge Network（預設）\"\n        B_C1[Container 1] --- B_NET[docker0 bridge]\n        B_C2[Container 2] --- B_NET\n        B_NET --- B_HOST[Host Network Stack]\n    end\n    \n    subgraph \"Host Network\"\n        H_C[Container] --- H_HOST[Host Network Stack]\n    end\n    \n    subgraph \"None Network\"\n        N_C[Container - 無網路]\n    end\n```\n\n| 網路類型 | 說明 | 適用場景 |\n|----------|------|----------|\n| **bridge** | 預設網路，Container 透過虛擬橋接器連接 | 單機多容器通訊 |\n| **host** | Container 直接使用主機網路 | 需要最高網路效能 |\n| **none** | 無網路連接 | 安全隔離需求 |\n| **overlay** | 跨主機容器通訊 | Docker Swarm 叢集 |\n| **macvlan** | 分配真實 MAC 地址 | 需要直接連接實體網路 |\n\n### 網路基本操作\n\n```bash title=\"Docker 網路管理\"\n# 列出所有網路\ndocker network ls\n\n# 檢視網路詳細資訊\ndocker network inspect bridge\n\n# 建立自訂網路\ndocker network create my-network\n\n# 建立指定子網路的網路\ndocker network create \\\n  --driver bridge \\\n  --subnet 172.20.0.0/16 \\\n  --gateway 172.20.0.1 \\\n  my-custom-network\n\n# 刪除網路\ndocker network rm my-network\n\n# 清理未使用的網路\ndocker network prune\n```\n\n### 容器連接網路\n\n```bash title=\"容器網路連接\"\n# 執行容器時指定網路\ndocker run -d --name app1 --network my-network nginx\n\n# 將運行中的容器連接到網路\ndocker network connect my-network container-name\n\n# 將容器從網路斷開\ndocker network disconnect my-network container-name\n```\n\n### 容器間通訊\n\n!!! tip \"使用自訂網路實現容器間通訊\"\n    在同一個自訂網路中的容器，可以使用**容器名稱**作為 hostname 互相存取。\n\n```bash title=\"容器間通訊範例\"\n# 建立網路\ndocker network create app-network\n\n# 啟動 MySQL Container\ndocker run -d \\\n  --name mysql-db \\\n  --network app-network \\\n  -e MYSQL_ROOT_PASSWORD=secret \\\n  mysql:8\n\n# 啟動應用程式 Container，使用 mysql-db 作為資料庫主機\ndocker run -d \\\n  --name my-app \\\n  --network app-network \\\n  -e DB_HOST=mysql-db \\\n  -e DB_PASSWORD=secret \\\n  my-application\n\n# 測試連線\ndocker exec my-app ping mysql-db\n```\n\n### Port 對應\n\n```bash title=\"Port Mapping\"\n# 對應單一 Port\ndocker run -d -p 8080:80 nginx\n\n# 對應多個 Port\ndocker run -d -p 8080:80 -p 8443:443 nginx\n\n# 對應到所有介面的隨機 Port\ndocker run -d -P nginx\n\n# 只對應到 localhost\ndocker run -d -p 127.0.0.1:8080:80 nginx\n\n# 對應 UDP Port\ndocker run -d -p 53:53/udp dns-server\n```\n\n---\n\n## 2.5 Docker Search\n\n### 搜尋 Image\n\n```bash title=\"搜尋 Docker Hub\"\n# 基本搜尋\ndocker search nginx\n\n# 限制結果數量\ndocker search --limit 5 nginx\n\n# 只顯示官方 Image\ndocker search --filter is-official=true nginx\n\n# 只顯示自動建置的 Image\ndocker search --filter is-automated=true nginx\n\n# 根據星星數過濾\ndocker search --filter stars=100 nginx\n```\n\n**搜尋結果說明**：\n\n| 欄位 | 說明 |\n|------|------|\n| NAME | Image 名稱 |\n| DESCRIPTION | 描述 |\n| STARS | 星星數（人氣指標） |\n| OFFICIAL | 是否為官方 Image |\n| AUTOMATED | 是否自動建置 |\n\n!!! tip \"選擇 Image 的建議\"\n    1. 優先選擇**官方 Image**（OFFICIAL = [OK]）\n    2. 查看**星星數**和**下載次數**\n    3. 到 Docker Hub 網站查看**文件**和**更新頻率**\n    4. 檢查 Image 的**安全掃描結果**\n\n---\n\n## 2.6 Docker Pull\n\n### 拉取 Image\n\n```bash title=\"拉取 Image\"\n# 拉取最新版本（預設 latest tag）\ndocker pull nginx\n\n# 拉取特定版本\ndocker pull nginx:1.25\n\n# 拉取特定版本（alpine 輕量版）\ndocker pull nginx:alpine\n\n# 從其他 Registry 拉取\ndocker pull quay.io/bitnami/nginx\n\n# 拉取特定平台的 Image\ndocker pull --platform linux/amd64 nginx\n```\n\n### Image 標籤（Tag）\n\n```mermaid\ngraph LR\n    N[nginx] --> L[latest]\n    N --> V1[1.25]\n    N --> V2[1.25.3]\n    N --> A[alpine]\n    N --> VA[1.25-alpine]\n```\n\n!!! warning \"避免使用 latest\"\n    - `latest` 標籤會隨時間變化\n    - 生產環境應使用**明確版本號**\n    - 例如：`nginx:1.25.3` 而非 `nginx:latest`\n\n### 管理本地 Image\n\n```bash title=\"Image 管理指令\"\n# 列出本地 Image\ndocker images\n\n# 列出所有 Image（包含中間層）\ndocker images -a\n\n# 檢視 Image 詳細資訊\ndocker image inspect nginx\n\n# 檢視 Image 歷史（分層）\ndocker history nginx\n\n# 刪除 Image\ndocker rmi nginx\n\n# 刪除未使用的 Image\ndocker image prune\n\n# 刪除所有未使用的 Image（包含未標記的）\ndocker image prune -a\n```\n\n---\n\n## 2.7 Docker Push\n\n### 推送 Image 到 Registry\n\n#### 推送到 Docker Hub\n\n```bash title=\"推送到 Docker Hub\"\n# 1. 登入 Docker Hub\ndocker login\n\n# 2. 為 Image 加上標籤（必須包含使用者名稱）\ndocker tag my-app:v1 username/my-app:v1\n\n# 3. 推送 Image\ndocker push username/my-app:v1\n\n# 4. 登出（選用）\ndocker logout\n```\n\n#### 推送到私有 Registry\n\n```bash title=\"推送到私有 Registry\"\n# 1. 登入私有 Registry\ndocker login my-registry.example.com\n\n# 2. 為 Image 加上私有 Registry 標籤\ndocker tag my-app:v1 my-registry.example.com/my-app:v1\n\n# 3. 推送\ndocker push my-registry.example.com/my-app:v1\n```\n\n!!! note \"Image 命名規則\"\n    ```\n    [registry/][username/]repository[:tag]\n    ```\n    \n    例如：\n    \n    - `nginx` = `docker.io/library/nginx:latest`\n    - `bitnami/nginx` = `docker.io/bitnami/nginx:latest`\n    - `gcr.io/project/app:v1`\n\n### 標籤管理\n\n```bash title=\"Image 標籤操作\"\n# 加上新標籤\ndocker tag my-app:v1 my-app:latest\ndocker tag my-app:v1 my-app:stable\n\n# 推送多個標籤\ndocker push my-app:v1\ndocker push my-app:latest\ndocker push my-app:stable\n```\n\n---\n\n## 2.8 使用 Docker 架設 WordPress + MySQL\n\n### Lab 實作目標\n\n部署一個完整的 WordPress 網站，包含：\n\n- MySQL 資料庫容器\n- WordPress 應用程式容器\n- 使用 Docker Network 連接\n- 使用 Volume 持久化資料\n\n### 架構圖\n\n```mermaid\ngraph TB\n    subgraph \"Docker 環境\"\n        subgraph \"wp-network\"\n            WP[WordPress<br/>Port: 8080] -->|連接| DB[(MySQL<br/>Port: 3306)]\n        end\n        WP_VOL[wordpress-data<br/>Volume] --> WP\n        DB_VOL[mysql-data<br/>Volume] --> DB\n    end\n    \n    User[使用者] -->|http://localhost:8080| WP\n```\n\n### 實作步驟\n\n#### 步驟 1：建立網路\n\n```bash title=\"建立專用網路\"\ndocker network create wp-network\n```\n\n#### 步驟 2：啟動 MySQL 容器\n\n```bash title=\"啟動 MySQL\"\ndocker run -d \\\n  --name wp-mysql \\\n  --network wp-network \\\n  -v mysql-data:/var/lib/mysql \\\n  -e MYSQL_ROOT_PASSWORD=rootpassword \\\n  -e MYSQL_DATABASE=wordpress \\\n  -e MYSQL_USER=wpuser \\\n  -e MYSQL_PASSWORD=wppassword \\\n  mysql:8.0\n```\n\n!!! note \"MySQL 環境變數說明\"\n    | 環境變數 | 說明 |\n    |----------|------|\n    | `MYSQL_ROOT_PASSWORD` | root 密碼（必填） |\n    | `MYSQL_DATABASE` | 自動建立的資料庫 |\n    | `MYSQL_USER` | 自動建立的使用者 |\n    | `MYSQL_PASSWORD` | 使用者密碼 |\n\n#### 步驟 3：啟動 WordPress 容器\n\n```bash title=\"啟動 WordPress\"\ndocker run -d \\\n  --name wp-app \\\n  --network wp-network \\\n  -p 8080:80 \\\n  -v wordpress-data:/var/www/html \\\n  -e WORDPRESS_DB_HOST=wp-mysql:3306 \\\n  -e WORDPRESS_DB_NAME=wordpress \\\n  -e WORDPRESS_DB_USER=wpuser \\\n  -e WORDPRESS_DB_PASSWORD=wppassword \\\n  wordpress:latest\n```\n\n#### 步驟 4：驗證部署\n\n```bash title=\"驗證容器狀態\"\n# 檢查容器是否運行\ndocker ps\n\n# 檢查容器日誌\ndocker logs wp-mysql\ndocker logs wp-app\n\n# 測試 MySQL 連線\ndocker exec wp-mysql mysql -uwpuser -pwppassword -e \"SHOW DATABASES;\"\n```\n\n#### 步驟 5：存取 WordPress\n\n開啟瀏覽器，前往 `http://localhost:8080`，完成 WordPress 安裝精靈。\n\n### 使用 Docker Compose（額外說明）\n\n!!! tip \"更簡潔的方式\"\n    使用 Docker Compose 可以將以上所有設定集中在一個檔案中。\n\n```yaml title=\"docker-compose.yml\"\nversion: '3.8'\n\nservices:\n  db:\n    image: mysql:8.0\n    container_name: wp-mysql\n    volumes:\n      - mysql-data:/var/lib/mysql\n    environment:\n      MYSQL_ROOT_PASSWORD: rootpassword\n      MYSQL_DATABASE: wordpress\n      MYSQL_USER: wpuser\n      MYSQL_PASSWORD: wppassword\n    networks:\n      - wp-network\n\n  wordpress:\n    image: wordpress:latest\n    container_name: wp-app\n    depends_on:\n      - db\n    ports:\n      - \"8080:80\"\n    volumes:\n      - wordpress-data:/var/www/html\n    environment:\n      WORDPRESS_DB_HOST: db:3306\n      WORDPRESS_DB_NAME: wordpress\n      WORDPRESS_DB_USER: wpuser\n      WORDPRESS_DB_PASSWORD: wppassword\n    networks:\n      - wp-network\n\nnetworks:\n  wp-network:\n    driver: bridge\n\nvolumes:\n  mysql-data:\n  wordpress-data:\n```\n\n```bash title=\"使用 Docker Compose 啟動\"\n# 啟動所有服務\ndocker compose up -d\n\n# 檢視狀態\ndocker compose ps\n\n# 檢視日誌\ndocker compose logs -f\n\n# 停止並移除\ndocker compose down\n\n# 停止並移除（包含 Volume）\ndocker compose down -v\n```\n\n### 清理資源\n\n```bash title=\"清理實作環境\"\n# 停止容器\ndocker stop wp-app wp-mysql\n\n# 刪除容器\ndocker rm wp-app wp-mysql\n\n# 刪除網路\ndocker network rm wp-network\n\n# 刪除 Volume（警告：會刪除所有資料）\ndocker volume rm mysql-data wordpress-data\n```\n\n---\n\n## 常見問題\n\n??? question \"Q1：Container 啟動後立即退出怎麼辦？\"\n    **診斷步驟**：\n    ```bash\n    # 檢視容器日誌\n    docker logs container-name\n    \n    # 檢視容器詳細資訊\n    docker inspect container-name\n    \n    # 檢視最後退出狀態\n    docker ps -a --filter \"name=container-name\"\n    ```\n    \n    **常見原因**：\n    \n    - 啟動指令錯誤\n    - 環境變數缺失\n    - 依賴服務未就緒\n    - 設定檔錯誤\n\n??? question \"Q2：如何讓容器在主機重啟後自動啟動？\"\n    **解決方案**：使用 `--restart` 選項\n    ```bash\n    # always: 總是重啟\n    docker run -d --restart=always nginx\n    \n    # unless-stopped: 除非手動停止\n    docker run -d --restart=unless-stopped nginx\n    \n    # on-failure: 只在異常退出時重啟\n    docker run -d --restart=on-failure:3 nginx\n    ```\n\n??? question \"Q3：Volume 資料如何備份？\"\n    **解決方案**：\n    ```bash\n    # 方法 1：使用臨時容器備份\n    docker run --rm \\\n      -v mysql-data:/source:ro \\\n      -v $(pwd):/backup \\\n      alpine tar cvf /backup/mysql-backup.tar /source\n    \n    # 方法 2：使用 docker cp（需要先掛載到容器）\n    docker cp container-name:/var/lib/mysql ./mysql-backup\n    ```\n\n??? question \"Q4：如何查看 Docker 佔用的磁碟空間？\"\n    **解決方案**：\n    ```bash\n    # 檢視整體使用情況\n    docker system df\n    \n    # 詳細資訊\n    docker system df -v\n    \n    # 清理未使用的資源\n    docker system prune\n    \n    # 清理所有未使用資源（包含 Volume）\n    docker system prune -a --volumes\n    ```\n\n??? question \"Q5：容器間無法通訊怎麼辦？\"\n    **診斷步驟**：\n    ```bash\n    # 1. 確認容器在同一個網路\n    docker network inspect my-network\n    \n    # 2. 確認容器 IP\n    docker inspect --format='{{.NetworkSettings.IPAddress}}' container-name\n    \n    # 3. 在容器內測試連線\n    docker exec container1 ping container2\n    \n    # 4. 確認 Port 是否開放\n    docker exec container1 nc -zv container2 port\n    ```\n\n---\n\n## 小結\n\n本章節重點回顧：\n\n- ✅ **Registry 類型**：Public Registry（如 Docker Hub）與 Private Registry（如 Harbor）\n- ✅ **Container 管理**：run、exec、logs、inspect 等核心指令\n- ✅ **持久化儲存**：Volume（Docker 管理）vs Bind Mount（主機目錄）\n- ✅ **Docker 網路**：bridge、host、none 網路類型，自訂網路實現容器間通訊\n- ✅ **Image 操作**：search、pull、push、tag 完整流程\n- ✅ **實作經驗**：WordPress + MySQL 容器化部署\n\n## 延伸閱讀\n\n- [Docker 官方文件 - Storage](https://docs.docker.com/storage/)\n- [Docker 官方文件 - Networking](https://docs.docker.com/network/)\n- [Docker Hub 官方網站](https://hub.docker.com/)\n- [Harbor - 企業級 Registry](https://goharbor.io/)\n- [Docker Compose 官方文件](https://docs.docker.com/compose/)\n"
  },
  {
    "title": "Lab06 Docker Basics",
    "url": "https://caocharles.github.io/dcka-class-notes/lab06_docker_basics/",
    "content": "﻿# LAB 06 docker 基本操作\n\n## 學習目標\n\n- [ ] 待補\n\n## 實作步驟\n\n*(本章節內容待補)*\n\n"
  },
  {
    "title": "Lab07 Persistent Storage",
    "url": "https://caocharles.github.io/dcka-class-notes/lab07_persistent_storage/",
    "content": "﻿# LAB 07 Persistent Storage\n\n## 學習目標\n\n- [ ] 待補\n\n## 實作步驟\n\n*(本章節內容待補)*\n\n"
  },
  {
    "title": "Lab08 Wordpress",
    "url": "https://caocharles.github.io/dcka-class-notes/lab08_wordpress/",
    "content": "﻿# LAB 08 架設部落格 - wordpress\n\n## 學習目標\n\n- [ ] 待補\n\n## 實作步驟\n\n*(本章節內容待補)*\n\n"
  },
  {
    "title": "LAB 09 客製化 Container Images - docker commit",
    "url": "https://caocharles.github.io/dcka-class-notes/lab09_commit/",
    "content": "---\nauthors:\n  - name: 課程作者\n    email: author@example.com\ndate: 2026-01-27\nupdated: 2026-01-27\ntags:\n  - Docker\n  - Container\n  - Image\n---\n\n# LAB 09 客製化 Container Images - docker commit\n\n## 學習目標\n\n完成本章節後，你將能夠：\n\n- [ ] 使用 `docker commit` 從容器建立新的 Image\n- [ ] 使用 `docker save` 將 Image 匯出為 tar 檔\n- [ ] 使用 `docker load` 從 tar 檔載入 Image\n- [ ] 建立清理 Docker 環境的腳本\n\n## 前置知識\n\n開始之前，請確保你已經：\n\n- 完成 LAB 06 的內容\n- 熟悉 Docker 基本操作\n- 已設定 Private Registry（docker1.training.lab:5000）\n\n---\n\n## 9.1 環境準備\n\n### 切換到 docker2 虛擬機\n\n本 Lab 在 docker2 虛擬機上執行。\n\n### 確認現有環境\n\n```bash title=\"檢視現有的 Container Images\"\ndocker images\n```\n\n**預期結果**：\n\n```\nIMAGE                                   ID             DISK USAGE   CONTENT SIZE   EXTRA\n192.168.66.51:5000/nginx:1.9.1          667cfe3b0942        289MB          139MB        \ndocker1.training.lab:5000/nginx:1.7.1   b1590b02702d       1.06GB          515MB        \n```\n\n```bash title=\"檢視現有的 Container\"\ndocker ps -a\n```\n\n**預期結果**：\n\n```\nCONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES\n```\n\n### 建立清理腳本\n\n建立一個腳本來清理所有 Container 與 Image：\n\n```bash title=\"建立 docker_clean_all.sh\"\nvi docker_clean_all.sh\n```\n\n腳本內容：\n\n```bash title=\"docker_clean_all.sh\"\n#!/bin/bash\n# 停止並刪除所有 Container\ndocker stop $(docker ps -aq)\ndocker rm $(docker ps -aq)\n# 刪除所有 Image\ndocker rmi $(docker images -q)\n```\n\n!!! note \"腳本說明\"\n    - `docker ps -aq`：列出所有 Container 的 ID（`-a` 包含已停止的，`-q` 只顯示 ID）\n    - `docker images -q`：列出所有 Image 的 ID\n    - 如果沒有 Container 或 Image，指令會顯示錯誤訊息，但不影響後續操作\n\n```bash title=\"設定執行權限\"\nchmod 755 ./docker_clean_all.sh\n```\n\n```bash title=\"執行清理腳本\"\n./docker_clean_all.sh\n```\n\n**預期結果**：\n\n```\ndocker: 'docker stop' requires at least 1 argument\ndocker: 'docker rm' requires at least 1 argument\nUntagged: 192.168.66.51:5000/nginx:1.9.1\nDeleted: sha256:667cfe3b094262dcd2323f28a800d8376221b017a9dd14b6fff78e4ec96a6177\nUntagged: docker1.training.lab:5000/nginx:1.7.1\nDeleted: sha256:b1590b02702d926755e02ca8f01baa42c9789758a3fb6d40aa87bdcfe871965d\n```\n\n!!! info \"錯誤訊息說明\"\n    當沒有 Container 時，`docker stop` 和 `docker rm` 會顯示錯誤訊息，這是正常的，不影響後續操作。\n\n---\n\n## 9.2 下載 Docker Image\n\n### 從 Private Registry 下載 Alpine\n\n```bash title=\"下載 Alpine Image\"\ndocker pull docker1.training.lab:5000/alpine\n```\n\n**預期結果**：\n\n```\nUsing default tag: latest\nlatest: Pulling from alpine\n77cae8ab23bf: Pull complete \nDigest: sha256:d0a0f8e7bf9a6287c7dab568b947b6c3dd6b84e9c67ab9f1e95f79751d808641\nStatus: Downloaded newer image for docker1.training.lab:5000/alpine:latest\ndocker1.training.lab:5000/alpine:latest\n```\n\n!!! note \"docker pull 說明\"\n    - 如果沒有指定 tag，預設會使用 `latest`\n    - 從 Private Registry 下載需要指定完整的 Registry 位址\n\n```bash title=\"確認 Image 已下載\"\ndocker images\n```\n\n**預期結果**：\n\n```\nIMAGE                                     ID             DISK USAGE   CONTENT SIZE   EXTRA\ndocker1.training.lab:5000/alpine:latest   d0a0f8e7bf9a       11.6MB         5.82MB        \n```\n\n---\n\n## 9.3 進入 Alpine 執行 sh\n\n### 啟動互動式 Container\n\n```bash title=\"啟動 Alpine Container\"\ndocker run -it --name alpine-1 docker1.training.lab:5000/alpine:latest\n```\n\n!!! note \"docker run 參數說明\"\n    | 參數 | 說明 |\n    |------|------|\n    | `-i` | 保持 STDIN 開啟（interactive） |\n    | `-t` | 分配虛擬終端機（tty） |\n    | `--name alpine-1` | 指定 Container 名稱 |\n\n進入容器後會看到提示符號 `/ #`，表示已在 Container 內部。\n\n---\n\n## 9.4 在 Alpine 中安裝 Bash\n\n### 測試 Bash 是否存在\n\n```bash title=\"測試 bash（在 Container 內執行）\"\nbash\n```\n\n**預期結果**：\n\n```\n/bin/sh: bash: not found\n```\n\n!!! info \"為什麼 Alpine 沒有 Bash？\"\n    Alpine Linux 是一個極輕量的 Linux 發行版，使用 BusyBox 作為核心工具集，預設只提供 `/bin/sh`（ash shell）以維持極小的映像大小（約 5MB）。\n\n### 使用 apk 安裝 Bash\n\n```bash title=\"安裝 bash（在 Container 內執行）\"\napk add --no-cache --update-cache bash\n```\n\n**預期結果**：\n\n```\nfetch http://dl-cdn.alpinelinux.org/alpine/v3.10/main/x86_64/APKINDEX.tar.gz\nfetch http://dl-cdn.alpinelinux.org/alpine/v3.10/community/x86_64/APKINDEX.tar.gz\n(1/4) Installing ncurses-terminfo-base (6.1_p20190518-r2)\n(2/4) Installing ncurses-libs (6.1_p20190518-r2)\n(3/4) Installing readline (8.0.0-r0)\n(4/4) Installing bash (5.0.0-r0)\nExecuting bash-5.0.0-r0.post-install\nExecuting busybox-1.30.1-r2.trigger\nOK: 8 MiB in 18 packages\n```\n\n!!! tip \"apk 參數說明\"\n    | 參數 | 說明 |\n    |------|------|\n    | `add` | 安裝套件 |\n    | `--no-cache` | 不使用本地快取，減少 Image 大小 |\n    | `--update-cache` | 更新套件索引 |\n\n### 驗證安裝成功\n\n```bash title=\"切換到 bash（在 Container 內執行）\"\nbash\n```\n\n**預期結果**：\n\n成功進入 bash，提示符號變成 `bash-5.0#`\n\n```bash title=\"退出 Container\"\nexit  # 退出 bash\nexit  # 退出 Container\n```\n\n---\n\n## 9.5 Commit 新的 Container Image\n\n### 使用 docker commit 建立新 Image\n\n```bash title=\"建立新 Image\"\ndocker commit -m \"alpine + bash\" alpine-1 alpine-bash\n```\n\n**預期結果**：\n\n```\nsha256:4326afd8916bbf220fcb95d27fd5cac5096b74fa6ccba7c8929d5a70820875ec\n```\n\n!!! note \"docker commit 語法\"\n    ```\n    docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]\n    ```\n    \n    | 參數 | 說明 |\n    |------|------|\n    | `-m` | 提交訊息（描述變更內容） |\n    | `-a` | 指定作者（可選） |\n    | `alpine-1` | 來源 Container 名稱 |\n    | `alpine-bash` | 新 Image 名稱（預設 tag 為 latest） |\n\n```bash title=\"確認新 Image 已建立\"\ndocker images\n```\n\n**預期結果**：\n\n```\nIMAGE                                     ID             DISK USAGE   CONTENT SIZE   EXTRA\nalpine-bash:latest                        4326afd8916b       14.5MB          6.6MB        \ndocker1.training.lab:5000/alpine:latest   d0a0f8e7bf9a       11.6MB         5.82MB    U   \n```\n\n!!! info \"Image 大小變化\"\n    安裝 Bash 後，Image 從 5.82MB 增加到 6.6MB，增加約 0.78MB（主要是 Bash 及其相依套件）。\n\n---\n\n## 9.6 匯出並壓縮為 Tar Ball 檔案\n\n### 使用 docker save 匯出 Image\n\n```bash title=\"匯出 Image 為 tar 檔\"\ndocker save --output=alpine-bash.tar alpine-bash\n```\n\n!!! note \"docker save 語法\"\n    ```\n    docker save [OPTIONS] IMAGE [IMAGE...]\n    ```\n    \n    | 參數 | 說明 |\n    |------|------|\n    | `--output` 或 `-o` | 指定輸出檔案名稱 |\n    | 可一次匯出多個 Image | |\n\n```bash title=\"確認 tar 檔案大小\"\nls -lh alpine-bash.tar\n```\n\n**預期結果**：\n\n```\n-rw------- 1 root root 6.3M Jan 27 11:05 alpine-bash.tar\n```\n\n### 使用 gzip 壓縮\n\n```bash title=\"壓縮 tar 檔案\"\ngzip -9 alpine-bash.tar\n```\n\n!!! tip \"gzip 參數說明\"\n    - `-9`：最高壓縮比（1-9，9 為最高）\n    - 壓縮後檔案會自動加上 `.gz` 副檔名\n\n```bash title=\"確認壓縮後大小\"\nls -lh alpine-bash.tar.gz\n```\n\n**預期結果**：\n\n```\n-rw------- 1 root root 3.4M Jan 27 11:05 alpine-bash.tar.gz\n```\n\n!!! success \"壓縮效果\"\n    檔案從 6.3MB 壓縮到 3.4MB，減少約 46% 的空間。\n\n---\n\n## 9.7 測試 - 清除全部的 Container 及 Images\n\n```bash title=\"清除所有 Container 與 Image\"\n./docker_clean_all.sh\n```\n\n**預期結果**：\n\n```\n20fb31307e87\n20fb31307e87\nUntagged: alpine-bash:latest\nDeleted: sha256:4326afd8916bbf220fcb95d27fd5cac5096b74fa6ccba7c8929d5a70820875ec\nUntagged: docker1.training.lab:5000/alpine:latest\nDeleted: sha256:d0a0f8e7bf9a6287c7dab568b947b6c3dd6b84e9c67ab9f1e95f79751d808641\n```\n\n```bash title=\"確認環境已清理\"\ndocker images\n```\n\n**預期結果**：\n\n```\nIMAGE   ID             DISK USAGE   CONTENT SIZE   EXTRA\n```\n\n---\n\n## 9.8 載入 Container Image\n\n### 使用 docker load 載入壓縮檔\n\n```bash title=\"從壓縮檔載入 Image\"\ndocker load -i alpine-bash.tar.gz\n```\n\n**預期結果**：\n\n```\nLoaded image: alpine-bash:latest\n```\n\n!!! note \"docker load 語法\"\n    ```\n    docker load [OPTIONS]\n    ```\n    \n    | 參數 | 說明 |\n    |------|------|\n    | `-i` 或 `--input` | 指定輸入檔案 |\n    | 支援 `.tar` 和 `.tar.gz` 格式 | |\n\n```bash title=\"確認 Image 已載入\"\ndocker images\n```\n\n**預期結果**：\n\n```\nIMAGE                ID             DISK USAGE   CONTENT SIZE   EXTRA\nalpine-bash:latest   4326afd8916b       14.5MB          6.6MB        \n```\n\n---\n\n## 9.9 確認是否有 Bash\n\n```bash title=\"使用載入的 Image 啟動 Container\"\ndocker run -it --name alpine-2 alpine-bash /bin/bash\n```\n\n進入容器後會看到提示符號 `bash-5.0#`，表示 Bash 已成功安裝。\n\n```bash title=\"確認 bash 已安裝（在 Container 內執行）\"\nls -l /bin/bash\n```\n\n**預期結果**：\n\n```\n-rwxr-xr-x    1 root     root        735488 May  3  2019 /bin/bash\n```\n\n```bash title=\"退出 Container\"\nexit\n```\n\n---\n\n## 9.10 清除全部的 Container 及 Images\n\n```bash title=\"最終清理\"\n./docker_clean_all.sh\n```\n\n**預期結果**：\n\n```\ndb10817df336\ndb10817df336\nUntagged: alpine-bash:latest\nDeleted: sha256:4326afd8916bbf220fcb95d27fd5cac5096b74fa6ccba7c8929d5a70820875ec\n```\n\n!!! success \"Lab 完成\"\n    恭喜你已成功完成本 Lab！\n\n---\n\n## 指令參考\n\n### docker commit\n\n| 選項 | 說明 | 範例 |\n|------|------|------|\n| `-m` | 提交訊息 | `-m \"alpine + bash\"` |\n| `-a` | 指定作者 | `-a \"John Doe\"` |\n| `-c` | 套用 Dockerfile 指令 | `-c 'CMD [\"bash\"]'` |\n| `-p` | 提交前暫停容器 | `-p` |\n\n### docker save 與 docker load\n\n| 指令 | 說明 | 範例 |\n|------|------|------|\n| `docker save` | 將 Image 匯出為 tar 檔 | `docker save -o image.tar my-image` |\n| `docker load` | 從 tar 檔載入 Image | `docker load -i image.tar` |\n\n!!! warning \"docker save vs docker export\"\n    | 比較 | docker save | docker export |\n    |------|-------------|---------------|\n    | 對象 | Image | Container |\n    | 保留 | 完整 Layer 與 metadata | 單一檔案系統 |\n    | 載入指令 | docker load | docker import |\n    | 用途 | Image 備份/傳輸 | Container 檔案系統備份 |\n\n---\n\n## 小結\n\n本章節重點回顧：\n\n- ✅ **docker commit**：將執行中的 Container 狀態儲存為新 Image\n- ✅ **docker save**：將 Image 匯出為 tar 檔案\n- ✅ **docker load**：從 tar 檔載入 Image\n- ✅ **gzip 壓縮**：減少匯出檔案的大小\n- ✅ **清理腳本**：使用腳本批次清理 Container 與 Image\n"
  },
  {
    "title": "LAB 10 客製化 Container Images - Dockerfile",
    "url": "https://caocharles.github.io/dcka-class-notes/lab10_dockerfile/",
    "content": "﻿---\nauthors:\n  - name: 課程作者\n    email: author@example.com\ndate: 2026-01-27\nupdated: 2026-01-27\ntags:\n  - Docker\n  - Dockerfile\n  - Docker Hub\n---\n\n# LAB 10 客製化 Container Images - Dockerfile\n\n## 學習目標\n\n完成本章節後，你將能夠：\n\n- [ ] 撰寫 Dockerfile 建立客製化 Image\n- [ ] 使用 `docker build` 建置 Image\n- [ ] 使用 `docker login` 登入 Docker Hub\n- [ ] 使用 `docker tag` 標記 Image\n- [ ] 使用 `docker push` 上傳 Image 到 Docker Hub\n- [ ] 從 Docker Hub 下載自己上傳的 Image\n\n## 前置知識\n\n開始之前，請確保你已經：\n\n- 完成 LAB 09 的內容\n- 了解 Docker Image 的基本概念\n- 已註冊 Docker Hub 帳號（https://hub.docker.com）\n\n---\n\n## 10.1 環境準備\n\n### 切換到 docker2 虛擬機\n\n本 Lab 在 docker2 虛擬機上執行。\n\n### 確認環境已清理\n\n```bash title=\"檢視現有的 Container Images\"\ndocker images\n```\n\n**預期結果**：\n\n```\nIMAGE   ID             DISK USAGE   CONTENT SIZE   EXTRA\n```\n\n```bash title=\"檢視現有的 Container\"\ndocker ps -a\n```\n\n**預期結果**：\n\n```\nCONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES\n```\n\n### 執行清理腳本（如有需要）\n\n```bash title=\"執行清理腳本\"\n./docker_clean_all.sh\n```\n\n!!! info \"腳本說明\"\n    如果沒有 Container 或 Image，指令會顯示錯誤訊息，這是正常的，不影響後續操作。\n\n---\n\n## 10.2 建立專用目錄與 Dockerfile\n\n### 建立工作目錄\n\n```bash title=\"建立 Dockerfile 專用目錄\"\nmkdir /root/dockerfile-1\ncd /root/dockerfile-1\n```\n\n### 建立 Dockerfile\n\n```bash title=\"編輯 Dockerfile\"\nvi dockerfile\n```\n\nDockerfile 內容：\n\n```dockerfile title=\"dockerfile\"\nFROM docker1.training.lab:5000/alpine\n#FROM 192.168.66.51:5000/alpine\nRUN apk add --no-cache --update-cache bash\nCMD [\"/bin/bash\"]\n```\n\n!!! note \"Dockerfile 指令說明\"\n    | 指令 | 說明 |\n    |------|------|\n    | `FROM` | 指定基礎映像，這裡使用 Private Registry 的 Alpine |\n    | `RUN` | 在建置過程中執行指令，這裡安裝 bash |\n    | `CMD` | 指定容器啟動時預設執行的指令 |\n\n```bash title=\"確認 Dockerfile 內容\"\ncat dockerfile\n```\n\n**預期結果**：\n\n```\nFROM docker1.training.lab:5000/alpine\n#FROM 192.168.66.51:5000/alpine\nRUN apk add --no-cache --update-cache bash\nCMD [\"/bin/bash\"]\n```\n\n---\n\n## 10.3 測試基礎 Alpine Image\n\n在建置自訂 Image 之前，先確認基礎 Alpine 沒有 Bash：\n\n```bash title=\"啟動 Alpine Container 測試\"\ndocker run -it --name alpine-1 docker1.training.lab:5000/alpine /bin/sh\n```\n\n**預期結果**：\n\n```\nUnable to find image 'docker1.training.lab:5000/alpine:latest' locally\nlatest: Pulling from alpine\n77cae8ab23bf: Pull complete \nDigest: sha256:d0a0f8e7bf9a6287c7dab568b947b6c3dd6b84e9c67ab9f1e95f79751d808641\nStatus: Downloaded newer image for docker1.training.lab:5000/alpine:latest\n```\n\n在容器內測試 Bash：\n\n```bash title=\"測試 bash（在 Container 內執行）\"\nbash\n```\n\n**預期結果**：\n\n```\n/bin/sh: bash: not found\n```\n\n```bash title=\"退出容器\"\nexit\n```\n\n---\n\n## 10.4 使用 Dockerfile 建置新的 Docker Image\n\n### 執行 docker build\n\n```bash title=\"建置 Docker Image\"\ndocker build -t alpine-bash-2 .\n```\n\n**預期結果**：\n\n```\n[+] Building 2.9s (6/6) FINISHED                                                docker:default\n => [internal] load build definition from dockerfile                                      0.0s\n => => transferring dockerfile: 171B                                                      0.0s\n => [internal] load metadata for docker1.training.lab:5000/alpine:latest                  0.0s\n => [internal] load .dockerignore                                                         0.0s\n => => transferring context: 2B                                                           0.0s\n => [1/2] FROM docker1.training.lab:5000/alpine:latest                                    0.0s\n => [2/2] RUN apk add --no-cache --update-cache bash                                      2.7s\n => exporting to image                                                                    0.2s\n => => exporting layers                                                                   0.1s\n => => naming to docker.io/library/alpine-bash-2:latest                                   0.0s\n => => unpacking to docker.io/library/alpine-bash-2:latest                                0.0s\n```\n\n!!! note \"docker build 語法\"\n    ```\n    docker build -t <image_name>:<tag> <path>\n    ```\n    \n    | 參數 | 說明 |\n    |------|------|\n    | `-t` | 指定 Image 名稱和標籤 |\n    | `.` | 指定 Dockerfile 所在目錄（當前目錄） |\n\n!!! info \"建置過程說明\"\n    - `[1/2] FROM`：載入基礎映像\n    - `[2/2] RUN`：執行 Dockerfile 中的 RUN 指令（安裝 bash）\n    - `exporting to image`：匯出為新的 Image\n\n---\n\n## 10.5 測試新的 Container Image\n\n### 使用新 Image 啟動容器\n\n```bash title=\"使用新 Image 啟動 Container\"\ndocker run -it --name alpine-3 alpine-bash-2 /bin/bash\n```\n\n進入容器後會看到 `bash-5.0#` 提示符號，表示 Bash 已成功安裝。\n\n### 確認 Bash 已安裝\n\n```bash title=\"確認 bash（在 Container 內執行）\"\nls -l /bin/bash\n```\n\n**預期結果**：\n\n```\n-rwxr-xr-x    1 root     root        735488 May  3  2019 /bin/bash\n```\n\n```bash title=\"退出容器\"\nexit\n```\n\n!!! success \"建置成功\"\n    使用 Dockerfile 建置的 Image 已包含 Bash，與 LAB 09 使用 `docker commit` 的結果相同，但 Dockerfile 方式更具可重現性。\n\n---\n\n## 10.6 清理環境\n\n```bash title=\"切換到家目錄並清理\"\ncd\n./docker_clean_all.sh\n```\n\n**預期結果**：\n\n```\n254f09eaadac\n9ae97d52cd65\n254f09eaadac\n9ae97d52cd65\nUntagged: alpine-bash-2:latest\nDeleted: sha256:fe1c0340426860bdd7792a7e560d3dfbb1c6a4d0bf4caadd5e987a4b71fbd169\nUntagged: docker1.training.lab:5000/alpine:latest\nDeleted: sha256:d0a0f8e7bf9a6287c7dab568b947b6c3dd6b84e9c67ab9f1e95f79751d808641\n```\n\n---\n\n## 10.7 上傳 Docker Image 到 Docker Hub\n\n### 註冊 Docker Hub 帳號\n\n!!! tip \"事前準備\"\n    請先到 [https://hub.docker.com](https://hub.docker.com) 註冊帳號。\n\n### 使用 docker login 登入\n\n```bash title=\"登入 Docker Hub\"\ndocker login -u <你的帳號>\n```\n\n**範例**：\n\n```bash\ndocker login -u caocharles\n```\n\n**預期結果**：\n\n```\nPassword: \nWARNING! Your credentials are stored unencrypted in '/root/.docker/config.json'.\nConfigure a credential helper to remove this warning. See\nhttps://docs.docker.com/go/credential-store/\n\nLogin Succeeded\n```\n\n!!! warning \"密碼儲存警告\"\n    登入後，Docker 會將認證資訊儲存在 `/root/.docker/config.json`，這是 Base64 編碼（非加密），請注意安全。\n\n### 重新建置 Docker Image\n\n```bash title=\"切換到 Dockerfile 目錄\"\ncd /root/dockerfile-1\n```\n\n```bash title=\"建置要上傳的 Image\"\ndocker build -t alpine-bash-charles .\n```\n\n**預期結果**：\n\n```\n[+] Building 0.1s (6/6) FINISHED                                                docker:default\n => [internal] load build definition from dockerfile                                      0.0s\n => CACHED [2/2] RUN apk add --no-cache --update-cache bash                               0.0s\n => exporting to image                                                                    0.0s\n => => naming to docker.io/library/alpine-bash-charles:latest                             0.0s\n```\n\n!!! info \"CACHED 說明\"\n    如果之前已建置過相同的層，Docker 會使用快取，加快建置速度。\n\n### 為 Image 加上 Tag\n\n要上傳到 Docker Hub，Image 名稱必須包含你的 Docker Hub 帳號名稱：\n\n```bash title=\"為 Image 加上 Tag\"\ndocker tag alpine-bash-charles:latest <你的帳號>/alpine-bash-charles:latest\n```\n\n**範例**：\n\n```bash\ndocker tag alpine-bash-charles:latest caocharles/alpine-bash-charles:latest\n```\n\n!!! note \"docker tag 語法\"\n    ```\n    docker tag <source_image>:<tag> <target_image>:<tag>\n    ```\n    \n    - Target image 格式：`<Docker Hub 帳號>/<Image 名稱>:<tag>`\n\n```bash title=\"確認 Tag 已建立\"\ndocker images\n```\n\n**預期結果**：\n\n```\nIMAGE                                   ID             DISK USAGE   CONTENT SIZE   EXTRA\nalpine-bash-charles:latest              28024b3ae76e       14.5MB          6.6MB        \ncaocharles/alpine-bash-charles:latest   28024b3ae76e       14.5MB          6.6MB        \n```\n\n!!! info \"兩個 Image 使用相同 ID\"\n    `docker tag` 只是建立一個新的標籤指向同一個 Image，不會佔用額外空間。\n\n---\n\n## 10.8 上傳 Docker Image\n\n### 執行 docker push\n\n```bash title=\"上傳 Image 到 Docker Hub\"\ndocker push <你的帳號>/alpine-bash-charles:latest\n```\n\n**範例**：\n\n```bash\ndocker push caocharles/alpine-bash-charles:latest\n```\n\n**預期結果**：\n\n```\nThe push refers to repository [docker.io/caocharles/alpine-bash-charles]\n77cae8ab23bf: Pushed \n34b2f2a4fe94: Pushed \n01bc7f934740: Pushed \nlatest: digest: sha256:28024b3ae76eb1a9400407051085821a6f0a76b1b96cb2f4a92cec35f350d29f size: 855\n```\n\n!!! warning \"常見錯誤：push access denied\"\n    如果出現以下錯誤：\n    ```\n    push access denied, repository does not exist or may require authorization\n    ```\n    \n    **可能原因**：\n    \n    1. Image 標籤的帳號名稱與登入帳號不符\n    2. 尚未登入或登入憑證過期\n    \n    **解決方案**：\n    ```bash\n    # 確認使用正確的帳號名稱\n    docker tag alpine-bash-charles:latest <正確帳號>/alpine-bash-charles:latest\n    \n    # 重新登入\n    docker logout\n    docker login -u <你的帳號>\n    ```\n\n---\n\n## 10.9 驗證上傳結果\n\n### 在 Docker Hub 網站確認\n\n1. 開啟 [https://hub.docker.com](https://hub.docker.com)\n2. 登入你的帳號\n3. 進入 Repositories\n4. 確認可以看到剛上傳的 Image\n\n### 清理本地環境並從 Docker Hub 下載\n\n```bash title=\"清理本地環境\"\ncd\n./docker_clean_all.sh\n```\n\n```bash title=\"確認已清理\"\ndocker images\n```\n\n**預期結果**：\n\n```\nIMAGE   ID             DISK USAGE   CONTENT SIZE   EXTRA\n```\n\n```bash title=\"從 Docker Hub 下載 Image\"\ndocker pull <你的帳號>/alpine-bash-charles\n```\n\n**範例**：\n\n```bash\ndocker pull caocharles/alpine-bash-charles\n```\n\n**預期結果**：\n\n```\nUsing default tag: latest\nlatest: Pulling from caocharles/alpine-bash-charles\n01bc7f934740: Pull complete \n34b2f2a4fe94: Download complete \nDigest: sha256:28024b3ae76eb1a9400407051085821a6f0a76b1b96cb2f4a92cec35f350d29f\nStatus: Downloaded newer image for caocharles/alpine-bash-charles:latest\ndocker.io/caocharles/alpine-bash-charles:latest\n```\n\n```bash title=\"確認下載成功\"\ndocker images\n```\n\n**預期結果**：\n\n```\nIMAGE                                   ID             DISK USAGE   CONTENT SIZE   EXTRA\ncaocharles/alpine-bash-charles:latest   28024b3ae76e       14.5MB          6.6MB    \n```\n\n!!! success \"完成確認\"\n    成功從 Docker Hub 下載剛才上傳的 Image！\n\n---\n\n## 指令參考\n\n### Dockerfile 基本指令\n\n| 指令 | 說明 | 範例 |\n|------|------|------|\n| `FROM` | 指定基礎映像 | `FROM alpine:latest` |\n| `RUN` | 建置時執行指令 | `RUN apk add bash` |\n| `CMD` | 容器啟動時預設指令 | `CMD [\"/bin/bash\"]` |\n| `COPY` | 複製檔案到 Image | `COPY ./src /app` |\n| `WORKDIR` | 設定工作目錄 | `WORKDIR /app` |\n| `EXPOSE` | 宣告開放的 Port | `EXPOSE 80` |\n| `ENV` | 設定環境變數 | `ENV APP_HOME=/app` |\n\n### Docker Hub 相關指令\n\n| 指令 | 說明 | 範例 |\n|------|------|------|\n| `docker login` | 登入 Docker Registry | `docker login -u username` |\n| `docker logout` | 登出 Docker Registry | `docker logout` |\n| `docker tag` | 為 Image 加上標籤 | `docker tag image:tag user/image:tag` |\n| `docker push` | 上傳 Image | `docker push user/image:tag` |\n| `docker pull` | 下載 Image | `docker pull user/image:tag` |\n\n---\n\n## 常見問題\n\n??? question \"Q1：docker build 時出現 'no such file or directory' 錯誤？\"\n    **可能原因**：\n    \n    1. Dockerfile 檔名不正確（注意大小寫）\n    2. 不在正確的目錄\n    \n    **解決方案**：\n    ```bash\n    # 確認檔案存在\n    ls -la dockerfile\n    \n    # 使用 -f 指定 Dockerfile 路徑\n    docker build -f ./dockerfile -t my-image .\n    ```\n\n??? question \"Q2：docker push 失敗，顯示 'access denied'？\"\n    **解決方案**：\n    \n    1. 確認已登入：`docker login`\n    2. 確認 Image 標籤包含正確的帳號名稱\n    3. 標籤格式必須是：`<帳號>/<image名稱>:<tag>`\n\n??? question \"Q3：Dockerfile 與 docker commit 有什麼差別？\"\n    | 比較 | docker commit | Dockerfile |\n    |------|---------------|------------|\n    | 可追蹤性 | 無法追蹤變更 | 可版本控制 |\n    | 可重現性 | 難以重現 | 可重複建置 |\n    | 自動化 | 手動操作 | 可自動化 |\n    | 建議用途 | 測試/除錯 | 生產環境 |\n\n---\n\n## 小結\n\n本章節重點回顧：\n\n- ✅ **Dockerfile**：使用 FROM、RUN、CMD 指令建立客製化 Image\n- ✅ **docker build**：根據 Dockerfile 建置 Image\n- ✅ **docker login**：登入 Docker Hub\n- ✅ **docker tag**：為 Image 加上符合 Docker Hub 格式的標籤\n- ✅ **docker push**：上傳 Image 到 Docker Hub\n- ✅ **docker pull**：從 Docker Hub 下載 Image\n"
  },
  {
    "title": "LAB 11 Standalone Kubernetes 安裝",
    "url": "https://caocharles.github.io/dcka-class-notes/lab11_standalone_k8s/",
    "content": "﻿---\nauthors:\n  - name: 課程作者\n    email: author@example.com\ndate: 2026-01-27\nupdated: 2026-01-27\ntags:\n  - Kubernetes\n  - Installation\n  - Standalone\n---\n\n# LAB 11 Standalone Kubernetes 安裝\n\n## 學習目標\n\n完成本章節後，你將能夠：\n\n- [ ] 使用 Shell Script 自動化安裝 Kubernetes\n- [ ] 了解 Standalone Kubernetes 的架構\n- [ ] 監控 Kubernetes 叢集狀態\n- [ ] 在 Standalone Master 節點上部署 Pod\n- [ ] 建立虛擬機快照保留狀態\n\n## 前置知識\n\n開始之前，請確保你已經：\n\n- 完成 Docker 相關章節\n- 了解基本的 Linux 指令操作\n- 了解容器化的基本概念\n\n---\n\n## 11.1 環境說明\n\n### 什麼是 Standalone Kubernetes？\n\nStandalone Kubernetes 是一個單節點的 Kubernetes 叢集，Master 節點同時也作為 Worker 節點使用。這種架構適合：\n\n- 學習與測試環境\n- 開發環境\n- 小型專案\n\n```mermaid\ngraph TB\n    subgraph \"Standalone Kubernetes\"\n        M[k8s-standalone<br/>Master + Worker<br/>192.168.66.61]\n        subgraph \"Control Plane\"\n            API[API Server]\n            ETCD[etcd]\n            SCHED[Scheduler]\n            CM[Controller Manager]\n        end\n        subgraph \"Node Components\"\n            KL[Kubelet]\n            KP[Kube-Proxy]\n            CR[CRI-O]\n        end\n        subgraph \"Pods\"\n            P1[Pod 1]\n            P2[Pod 2]\n        end\n    end\n```\n\n### 虛擬機資訊\n\n| 項目 | 值 |\n|------|------|\n| 主機名稱 | k8s-standalone.training.lab |\n| IP 位址 | 192.168.66.61 |\n| 作業系統 | Rocky Linux 9 |\n| Kubernetes 版本 | 1.32 |\n\n---\n\n## 11.2 切換到 k8s-standalone 虛擬機\n\n### 確認網路設定\n\n```bash title=\"檢視網路介面\"\nifconfig ens160\n```\n\n**預期結果**：\n\n```\nens160: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500\n        inet 192.168.66.61  netmask 255.255.255.0  broadcast 192.168.66.255\n        inet6 fe80::20c:29ff:fe91:c3  prefixlen 64  scopeid 0x20<link>\n        ether 00:0c:29:91:00:c3  txqueuelen 1000  (Ethernet)\n        RX packets 41897  bytes 25015527 (23.8 MiB)\n        RX errors 0  dropped 0  overruns 0  frame 0\n        TX packets 672  bytes 55461 (54.1 KiB)\n        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\n```\n\n### 確認主機名稱\n\n```bash title=\"檢視主機名稱\"\nhostname\n```\n\n**預期結果**：\n\n```\nk8s-standalone.training.lab\n```\n\n### 確認 hosts 檔案\n\n```bash title=\"檢視 /etc/hosts\"\ncat /etc/hosts\n```\n\n**預期結果**：\n\n```\n127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4\n::1         localhost localhost.localdomain localhost6 localhost6.localdomain6\n\n192.168.66.10\tmaster.training.lab\tmaster\n192.168.66.11\tnode1.training.lab\tnode1\n192.168.66.12\tnode2.training.lab\tnode2\n192.168.66.21\tdocker.training.lab\tdocker\n192.168.66.22\tminikube.training.lab\tminikube\n\n192.168.66.51\t\tdocker1.training.lab\t\tdocker1\n192.168.66.52\t\tdocker2.training.lab\t\tdocker2\n192.168.66.61\t\tk8s-standalone.training.lab\tk8s-standalone\n192.168.66.71\t\tk8s-master1.training.lab\tk8s-master1\n192.168.66.81\t\tk8s-node1.training.lab\t\tk8s-node1\n192.168.66.82\t\tk8s-node2.training.lab\t\tk8s-node2\n```\n\n---\n\n## 11.3 下載安裝 Script\n\n### 使用 wget 下載\n\n```bash title=\"下載安裝腳本\"\nwget http://10.0.1.249/k8s/scripts/install_k8s-latest.sh\n```\n\n**預期結果**：\n\n```\n--2026-01-27 11:21:14--  http://10.0.1.249/k8s/scripts/install_k8s-latest.sh\nConnecting to 10.0.1.249:80... connected.\nHTTP request sent, awaiting response... 200 OK\nLength: 22517 (22K) [application/x-sh]\nSaving to: 'install_k8s-latest.sh'\n\ninstall_k8s-latest.sh       100%[========================================>]  21.99K  --.-KB/s    in 0s      \n\n2026-01-27 11:21:14 (61.0 MB/s) - 'install_k8s-latest.sh' saved [22517/22517]\n```\n\n### 設定執行權限\n\n```bash title=\"設定執行權限\"\nchmod 755 install_k8s-latest.sh\n```\n\n---\n\n## 11.4 使用 Shell Script 自動化安裝 Kubernetes\n\n### 查看安裝選項\n\n```bash title=\"執行腳本查看使用說明\"\n./install_k8s-latest.sh\n```\n\n**預期結果**：\n\n```\n請輸入 完整安裝(full) 或是 standalone\n./install_k8s-latest.sh -full\n或 \n./install_k8s-latest.sh -standalone\n```\n\n!!! note \"安裝模式說明\"\n    | 模式 | 說明 |\n    |------|------|\n    | `-full` | 完整安裝，包含 Master 與 Worker 節點設定 |\n    | `-standalone` | 單機安裝，Master 節點同時作為 Worker 節點 |\n\n### 執行 Standalone 安裝\n\n```bash title=\"執行 Standalone 安裝\"\n./install_k8s-latest.sh -standalone\n```\n\n!!! info \"安裝過程說明\"\n    腳本會自動執行以下步驟：\n    \n    1. **安裝必要套件**：sshpass、bash-completion\n    2. **安裝 Docker CE**：包含 containerd.io、docker-ce-cli\n    3. **關閉 Swap**：Kubernetes 要求關閉 Swap\n    4. **設定核心參數**：啟用 IP 轉發、設定網路參數\n    5. **安裝 Kubernetes 套件**：kubelet、kubeadm、kubectl\n    6. **安裝 CRI-O**：Container Runtime Interface\n    7. **關閉防火牆**：停用 firewalld\n    8. **執行 kubeadm init**：初始化 Kubernetes 叢集\n    9. **安裝 CNI**：安裝 Antrea 網路套件\n    10. **移除 Taint**：允許在 Master 節點上部署 Pod\n\n### 安裝過程輸出（部分）\n\n安裝 Docker CE：\n\n```\nInstalling:\n docker-ce                    x86_64    3:29.2.0-1.el9    docker-ce-stable     24 M\n containerd.io                x86_64    2.2.1-1.el9       docker-ce-stable     35 M\n docker-ce-cli                x86_64    1:29.2.0-1.el9    docker-ce-stable    8.4 M\n docker-buildx-plugin         x86_64    0.30.1-1.el9      docker-ce-stable     17 M\n docker-compose-plugin        x86_64    5.0.2-1.el9       docker-ce-stable    8.1 M\n\nComplete!\n```\n\n安裝 Kubernetes 套件：\n\n```\nInstalling:\n kubeadm       x86_64    1.32.11-150500.1.1    kubernetes    12 M\n kubectl       x86_64    1.32.11-150500.1.1    kubernetes    11 M\n kubelet       x86_64    1.32.11-150500.1.1    kubernetes    15 M\n cri-tools     x86_64    1.32.0-150500.1.1     kubernetes   7.1 M\n kubernetes-cni x86_64   1.6.0-150500.1.1      kubernetes   8.0 M\n\nComplete!\n```\n\n安裝 CRI-O：\n\n```\nInstalling:\n cri-o         x86_64    1.32.1-150500.1.1     cri-o         20 M\n\nComplete!\n```\n\n### kubeadm init 輸出\n\n```\n[init] Using Kubernetes version: v1.32.11\n[preflight] Running pre-flight checks\n[preflight] Pulling images required for setting up a Kubernetes cluster\n[certs] Using certificateDir folder \"/etc/kubernetes/pki\"\n[certs] Generating \"ca\" certificate and key\n[certs] Generating \"apiserver\" certificate and key\n[certs] apiserver serving cert is signed for DNS names [k8s-standalone.training.lab kubernetes kubernetes.default kubernetes.default.svc kubernetes.default.svc.cluster.local] and IPs [172.30.0.1 192.168.66.61]\n...\n[kubelet-start] Starting the kubelet\n[kubelet-check] The kubelet is healthy after 515.21134ms\n[api-check] The API server is healthy after 3.001460102s\n...\n[addons] Applied essential addon: CoreDNS\n[addons] Applied essential addon: kube-proxy\n\nYour Kubernetes control-plane has initialized successfully!\n```\n\n!!! success \"初始化成功\"\n    看到 `Your Kubernetes control-plane has initialized successfully!` 表示 Kubernetes 控制平面已成功初始化。\n\n### 安裝 Antrea CNI\n\n腳本會自動安裝 Antrea 作為 CNI（Container Network Interface）：\n\n```\ncustomresourcedefinition.apiextensions.k8s.io/antreaagentinfos.crd.antrea.io created\nserviceaccount/antrea-agent created\nserviceaccount/antrea-controller created\nclusterrole.rbac.authorization.k8s.io/antrea-agent created\nclusterrole.rbac.authorization.k8s.io/antrea-controller created\n...\ndeployment.apps/antrea-controller created\ndaemonset.apps/antrea-agent created\n```\n\n### 移除 Master 節點的 Taint\n\n預設情況下，Kubernetes 不允許在 Master 節點上部署 Pod。腳本會自動移除這個限制：\n\n```\nnode/k8s-standalone.training.lab untainted\n```\n\n!!! note \"Taint 說明\"\n    Taint（汙點）是 Kubernetes 用來限制 Pod 調度的機制。Master 節點預設有 `node-role.kubernetes.io/control-plane:NoSchedule` 的 Taint，表示不接受一般 Pod 的調度。\n\n---\n\n## 11.5 監控 Kubernetes 狀態\n\n### 檢視節點狀態\n\n```bash title=\"檢視節點狀態\"\nkubectl get nodes\n```\n\n**預期結果**（初始狀態）：\n\n```\nNAME                          STATUS     ROLES           AGE   VERSION\nk8s-standalone.training.lab   NotReady   control-plane   35s   v1.32.11\n```\n\n!!! warning \"NotReady 狀態\"\n    節點剛初始化時會顯示 `NotReady`，等待 CNI 套件完全啟動後會變成 `Ready`。\n\n等待約 30 秒後再次檢查：\n\n```bash title=\"再次檢視節點狀態\"\nkubectl get nodes\n```\n\n**預期結果**：\n\n```\nNAME                          STATUS   ROLES           AGE   VERSION\nk8s-standalone.training.lab   Ready    control-plane   2m    v1.32.11\n```\n\n### 檢視系統 Pod 狀態\n\n```bash title=\"檢視 kube-system namespace 的 Pod\"\nkubectl get pods -n kube-system\n```\n\n**預期結果**：\n\n```\nNAME                                                  READY   STATUS    RESTARTS   AGE\nantrea-agent-xxxxx                                    2/2     Running   0          2m\nantrea-controller-xxxxx                               1/1     Running   0          2m\ncoredns-xxxxx                                         1/1     Running   0          2m\ncoredns-xxxxx                                         1/1     Running   0          2m\netcd-k8s-standalone.training.lab                      1/1     Running   0          2m\nkube-apiserver-k8s-standalone.training.lab            1/1     Running   0          2m\nkube-controller-manager-k8s-standalone.training.lab   1/1     Running   0          2m\nkube-proxy-xxxxx                                      1/1     Running   0          2m\nkube-scheduler-k8s-standalone.training.lab            1/1     Running   0          2m\n```\n\n### 持續監控節點狀態\n\n```bash title=\"使用 watch 持續監控\"\nwatch kubectl get nodes\n```\n\n!!! tip \"watch 指令\"\n    `watch` 指令會每 2 秒重新執行一次指令，按 `Ctrl+C` 可以退出。\n\n---\n\n## 11.6 部署測試\n\n### 建立測試 Deployment\n\n```bash title=\"建立 nginx Deployment\"\nkubectl create deployment test1 --image=nginx\n```\n\n**預期結果**：\n\n```\ndeployment.apps/test1 created\n```\n\n!!! note \"kubectl create deployment 語法\"\n    ```\n    kubectl create deployment <name> --image=<image>\n    ```\n    \n    | 參數 | 說明 |\n    |------|------|\n    | `<name>` | Deployment 名稱 |\n    | `--image` | 使用的容器映像 |\n\n### 檢視 Deployment 狀態\n\n```bash title=\"檢視 Deployment\"\nkubectl get deployments.apps\n```\n\n**預期結果**：\n\n```\nNAME    READY   UP-TO-DATE   AVAILABLE   AGE\ntest1   0/1     1            0           15s\n```\n\n!!! info \"Deployment 欄位說明\"\n    | 欄位 | 說明 |\n    |------|------|\n    | `READY` | 就緒的 Pod 數量 / 預期數量 |\n    | `UP-TO-DATE` | 已更新到最新版本的 Pod 數量 |\n    | `AVAILABLE` | 可用的 Pod 數量 |\n\n### 檢視 Pod 狀態\n\n```bash title=\"檢視 Pod 狀態\"\nkubectl get pods\n```\n\n**預期結果**：\n\n```\nNAME                     READY   STATUS    RESTARTS   AGE\ntest1-7d9bdc56f4-mbtc5   0/1     Pending   0          27s\n```\n\n### 檢視 Pod 詳細資訊\n\n```bash title=\"檢視 Pod 詳細資訊（含節點資訊）\"\nkubectl get pods -o wide\n```\n\n**預期結果**：\n\n```\nNAME                     READY   STATUS    RESTARTS   AGE   IP       NODE     NOMINATED NODE   READINESS GATES\ntest1-7d9bdc56f4-mbtc5   0/1     Pending   0          33s   <none>   <none>   <none>           <none>\n```\n\n!!! warning \"Pod 處於 Pending 狀態\"\n    如果 Pod 持續處於 `Pending` 狀態且 `NODE` 顯示 `<none>`，可能是因為：\n    \n    1. 節點尚未就緒（NotReady）\n    2. 節點仍有 Taint 限制\n    \n    需要等待節點變成 Ready 狀態，或確認 Taint 已移除。\n\n### 等待節點就緒後確認\n\n等待節點變成 Ready 後，Pod 會自動調度並啟動：\n\n```bash title=\"確認節點狀態\"\nkubectl get nodes\n```\n\n當節點顯示 `Ready` 後：\n\n```bash title=\"再次檢視 Pod 狀態\"\nkubectl get pods -o wide\n```\n\n**預期結果**（節點就緒後）：\n\n```\nNAME                     READY   STATUS    RESTARTS   AGE   IP            NODE                          NOMINATED NODE   READINESS GATES\ntest1-7d9bdc56f4-mbtc5   1/1     Running   0          2m    10.244.0.5    k8s-standalone.training.lab   <none>           <none>\n```\n\n!!! success \"部署成功\"\n    當 Pod 狀態變成 `Running` 且 `NODE` 顯示 `k8s-standalone.training.lab`，表示已成功在 Standalone Master 節點上部署 Pod。\n\n### 清理測試 Deployment\n\n```bash title=\"刪除測試 Deployment\"\nkubectl delete deployment test1\n```\n\n**預期結果**：\n\n```\ndeployment.apps \"test1\" deleted\n```\n\n---\n\n## 11.7 建立快照 Snapshot\n\n!!! tip \"建議\"\n    完成安裝後，建議在 VMware 中建立虛擬機快照，以便日後需要時可以快速還原到乾淨的 Kubernetes 環境。\n\n### 建立快照步驟\n\n1. 在 VMware vSphere Client 或 VMware Workstation 中\n2. 選擇 k8s-standalone 虛擬機\n3. 右鍵選擇 **快照** > **拍攝快照**\n4. 輸入快照名稱，例如：`K8s 1.32 安裝完成`\n5. 點擊確定\n\n---\n\n## 指令參考\n\n### kubectl 基本指令\n\n| 指令 | 說明 |\n|------|------|\n| `kubectl get nodes` | 檢視節點狀態 |\n| `kubectl get pods` | 檢視 Pod 列表 |\n| `kubectl get pods -n kube-system` | 檢視系統 Pod |\n| `kubectl describe node <name>` | 檢視節點詳細資訊 |\n| `kubectl describe pod <name>` | 檢視 Pod 詳細資訊 |\n| `kubectl run <name> --image=<image>` | 建立 Pod |\n| `kubectl delete pod <name>` | 刪除 Pod |\n| `kubectl exec -it <name> -- <cmd>` | 在 Pod 中執行指令 |\n\n### 安裝相關元件版本\n\n| 元件 | 版本 |\n|------|------|\n| Kubernetes | 1.32.11 |\n| Docker CE | 29.2.0 |\n| containerd.io | 2.2.1 |\n| CRI-O | 1.32.1 |\n| Antrea CNI | 最新版 |\n\n---\n\n## 常見問題\n\n??? question \"Q1：節點一直顯示 NotReady？\"\n    **可能原因**：\n    \n    1. CNI 套件尚未完全啟動\n    2. kubelet 服務異常\n    \n    **解決方案**：\n    ```bash\n    # 檢視 kubelet 狀態\n    systemctl status kubelet\n    \n    # 檢視 kubelet 日誌\n    journalctl -u kubelet -f\n    \n    # 檢視系統 Pod 狀態\n    kubectl get pods -n kube-system\n    ```\n\n??? question \"Q2：Pod 無法在 Master 節點上執行？\"\n    **可能原因**：Master 節點有 Taint 限制\n    \n    **解決方案**：\n    ```bash\n    # 檢視節點 Taint\n    kubectl describe node k8s-standalone.training.lab | grep Taint\n    \n    # 移除 control-plane Taint\n    kubectl taint nodes k8s-standalone.training.lab node-role.kubernetes.io/control-plane:NoSchedule-\n    ```\n\n??? question \"Q3：如何重新安裝 Kubernetes？\"\n    **解決方案**：\n    ```bash\n    # 重置 kubeadm\n    kubeadm reset -f\n    \n    # 清理 iptables\n    iptables -F && iptables -t nat -F && iptables -t mangle -F && iptables -X\n    \n    # 重新執行安裝腳本\n    ./install_k8s-latest.sh -standalone\n    ```\n\n---\n\n## 小結\n\n本章節重點回顧：\n\n- ✅ **環境準備**：切換到 k8s-standalone 虛擬機，確認網路設定\n- ✅ **下載安裝腳本**：使用 wget 下載自動化安裝腳本\n- ✅ **自動化安裝**：使用 `-standalone` 參數執行單機安裝\n- ✅ **監控狀態**：使用 `kubectl get nodes` 確認節點 Ready\n- ✅ **部署測試**：成功在 Standalone Master 上部署 Pod\n- ✅ **建立快照**：保留乾淨的 Kubernetes 環境\n"
  },
  {
    "title": "Lab12 K8S Install",
    "url": "https://caocharles.github.io/dcka-class-notes/lab12_k8s_install/",
    "content": "﻿# LAB 12 Kubernetes 叢集安裝\n\n## 學習目標\n\n完成本章節後，你將能夠：\n\n- [ ] 使用 Shell Script 自動化安裝 Kubernetes 叢集\n- [ ] 配置多節點（Master + Worker）Kubernetes 環境\n- [ ] 理解 kubeadm、kubelet、kubectl 的角色\n- [ ] 安裝並配置 CRI-O 容器執行環境\n- [ ] 部署 Antrea CNI 網路插件\n- [ ] 將 Worker Node 加入叢集\n- [ ] 監控叢集狀態與驗證部署\n\n## 前置知識\n\n開始之前，請確保你已經：\n\n- 完成 LAB 11 獨立 Kubernetes 環境\n- 熟悉 Docker 基本操作\n- 理解容器化的基本概念\n- 準備好三台虛擬機（K8S-MASTER1、K8S-NODE1、K8S-NODE2）\n\n---\n\n## Lab 實作練習：使用 Shell Script 安裝 Kubernetes 叢集\n\n### 環境架構\n\n```mermaid\ngraph TB\n    subgraph \"Kubernetes Cluster\"\n        Master[k8s-master1<br/>192.168.66.71<br/>Control Plane]\n        Node1[k8s-node1<br/>192.168.66.81<br/>Worker Node]\n        Node2[k8s-node2<br/>192.168.66.82<br/>Worker Node]\n        Master --> Node1\n        Master --> Node2\n    end\n    \n    subgraph \"安裝元件\"\n        CRI[CRI-O 1.32]\n        K8S[Kubernetes 1.32]\n        CNI[Antrea CNI]\n    end\n```\n\n| 主機名稱 | IP 位址 | 角色 |\n|---------|---------|------|\n| k8s-master1.training.lab | 192.168.66.71 | Control Plane (Master) |\n| k8s-node1.training.lab | 192.168.66.81 | Worker Node |\n| k8s-node2.training.lab | 192.168.66.82 | Worker Node |\n\n!!! info \"安裝特點\"\n    - **全程在 Master 節點操作**：透過 SSH 自動化安裝 Worker 節點\n    - **使用 CRI-O**：Kubernetes 原生的容器執行環境\n    - **Antrea CNI**：VMware 開發的高效能網路插件\n\n---\n\n### 步驟 1：啟動虛擬機並確認環境\n\n首先，在 VMware Workstation 中啟動三台虛擬機：\n\n- K8S-MASTER1\n- K8S-NODE1  \n- K8S-NODE2\n\n登入 `k8s-master1`，確認主機名稱與網路設定：\n\n```bash title=\"確認主機名稱\"\nhostname\n```\n\n**預期結果**：\n\n```\nk8s-master1.training.lab\n```\n\n```bash title=\"確認 IP 位址\"\nifconfig ens160\n```\n\n**預期結果**：\n\n```\nens160: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500\n        inet 192.168.66.71  netmask 255.255.255.0  broadcast 192.168.66.255\n```\n\n```bash title=\"確認 /etc/hosts 設定\"\ncat /etc/hosts\n```\n\n**預期結果**：\n\n```\n127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4\n::1         localhost localhost.localdomain localhost6 localhost6.localdomain6\n\n192.168.66.71\t\tk8s-master1.training.lab\tk8s-master1\n192.168.66.81\t\tk8s-node1.training.lab\t\tk8s-node1\n192.168.66.82\t\tk8s-node2.training.lab\t\tk8s-node2\n```\n\n---\n\n### 步驟 2：確認網路連線\n\n測試與其他節點的連線：\n\n```bash title=\"Ping Worker Node 1\"\nping k8s-node1 -c3\n```\n\n**預期結果**：\n\n```\nPING k8s-node1.training.lab (192.168.66.81) 56(84) bytes of data.\n64 bytes from k8s-node1.training.lab (192.168.66.81): icmp_seq=1 ttl=64 time=0.430 ms\n64 bytes from k8s-node1.training.lab (192.168.66.81): icmp_seq=2 ttl=64 time=0.345 ms\n64 bytes from k8s-node1.training.lab (192.168.66.81): icmp_seq=3 ttl=64 time=0.243 ms\n\n--- k8s-node1.training.lab ping statistics ---\n3 packets transmitted, 3 received, 0% packet loss\n```\n\n```bash title=\"Ping Worker Node 2\"\nping k8s-node2 -c3\n```\n\n```bash title=\"測試網際網路連線\"\nping google.com -c3\n```\n\n**預期結果**：\n\n```\nPING google.com (142.250.66.78) 56(84) bytes of data.\n64 bytes from lctsaa-aa-in-f14.1e100.net (142.250.66.78): icmp_seq=1 ttl=128 time=66.8 ms\n...\n3 packets transmitted, 3 received, 0% packet loss\n```\n\n!!! success \"連線確認\"\n    確保三台虛擬機之間可以互相 ping 通，且可以連接網際網路下載套件。\n\n---\n\n### 步驟 3：下載安裝 Script\n\n從課程伺服器下載 Kubernetes 安裝腳本：\n\n```bash title=\"下載安裝腳本\"\nwget http://10.0.1.249/k8s/scripts/install_k8s-latest.sh\n```\n\n**預期結果**：\n\n```\n--2026-01-27 15:55:16--  http://10.0.1.249/k8s/scripts/install_k8s-latest.sh\nConnecting to 10.0.1.249:80... connected.\nHTTP request sent, awaiting response... 200 OK\nLength: 22517 (22K) [application/x-sh]\nSaving to: 'install_k8s-latest.sh'\n\ninstall_k8s-latest.sh    100%[==>]  21.99K  51.0KB/s    in 0.4s    \n\n2026-01-27 15:55:17 (51.0 KB/s) - 'install_k8s-latest.sh' saved [22517/22517]\n```\n\n設定執行權限：\n\n```bash title=\"設定執行權限\"\nchmod 755 install_k8s-latest.sh\n```\n\n查看使用說明：\n\n```bash title=\"查看腳本使用方式\"\n./install_k8s-latest.sh\n```\n\n**預期結果**：\n\n```\n請輸入 完整安裝(full) 或是 standalone\n./install_k8s-latest.sh -full\n或 \n./install_k8s-latest.sh -standalone\n```\n\n---\n\n### 步驟 4：執行完整安裝\n\n執行腳本進行完整叢集安裝（包含 Master 和 Worker 節點）：\n\n```bash title=\"執行完整安裝\"\n./install_k8s-latest.sh -full\n```\n\n!!! warning \"安裝時間\"\n    完整安裝過程約需 5-10 分鐘，取決於網路速度。請耐心等待。\n\n#### 安裝過程說明\n\n腳本會自動執行以下步驟：\n\n```mermaid\ngraph LR\n    A[安裝 sshpass] --> B[安裝 Docker CE]\n    B --> C[設定 bash-completion]\n    C --> D[關閉 Swap]\n    D --> E[設定 Kernel 參數]\n    E --> F[安裝 kubeadm/kubectl/kubelet]\n    F --> G[安裝 CRI-O]\n    G --> H[kubeadm init]\n    H --> I[Worker 加入叢集]\n    I --> J[安裝 Antrea CNI]\n```\n\n**主要安裝項目**：\n\n| 階段 | 說明 |\n|------|------|\n| **sshpass** | 用於自動化 SSH 登入 Worker 節點 |\n| **Docker CE** | 安裝 Docker 29.2.0（所有節點） |\n| **bash-completion** | kubectl 指令自動補齊 |\n| **Swap 關閉** | Kubernetes 要求關閉 Swap |\n| **Kernel 參數** | 設定 ip_forward、bridge-nf-call 等 |\n| **kubeadm/kubectl/kubelet** | Kubernetes 1.32.11 核心元件 |\n| **CRI-O** | 容器執行環境 1.32.1 |\n| **Antrea** | CNI 網路插件 |\n\n---\n\n### 步驟 5：驗證安裝結果\n\n安裝完成後，腳本會顯示類似以下訊息：\n\n```\nYour Kubernetes control-plane has initialized successfully!\n\nTo start using your cluster, you need to run the following as a regular user:\n\n  mkdir -p $HOME/.kube\n  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config\n  sudo chown $(id -u):$(id -g) $HOME/.kube/config\n\nThen you can join any number of worker nodes by running the following on each as root:\n\nkubeadm join 192.168.66.71:6443 --token hv80nh.sji1vjeju8b5l10n \\\n\t--discovery-token-ca-cert-hash sha256:f2af63e6d5dafedcc62702dcb939b51bfa98b96ab996af3556665a05a7cf0a6c\n```\n\n!!! success \"安裝成功\"\n    看到 \"Your Kubernetes control-plane has initialized successfully!\" 表示 Master 節點安裝成功。\n\n---\n\n### 步驟 6：監控叢集狀態\n\n使用 `while` 迴圈持續監控節點狀態：\n\n```bash title=\"持續監控節點狀態\"\nwhile true\ndo\n  date\n  kubectl get nodes\n  sleep 5\ndone\n```\n\n**初始狀態**（NotReady）：\n\n```\nTue Jan 27 04:05:22 PM CST 2026\nNAME                       STATUS     ROLES           AGE   VERSION\nk8s-master1.training.lab   NotReady   control-plane   84s   v1.32.11\nk8s-node1.training.lab     NotReady   <none>          76s   v1.32.11\nk8s-node2.training.lab     NotReady   <none>          75s   v1.32.11\n```\n\n!!! info \"NotReady 狀態\"\n    剛安裝完成時，節點會顯示 `NotReady`，等待 CNI 網路插件完成初始化後會變成 `Ready`。\n\n**最終狀態**（Ready）：\n\n```\nNAME                       STATUS   ROLES           AGE    VERSION\nk8s-master1.training.lab   Ready    control-plane   5m     v1.32.11\nk8s-node1.training.lab     Ready    <none>          4m52s  v1.32.11\nk8s-node2.training.lab     Ready    <none>          4m51s  v1.32.11\n```\n\n按 `Ctrl+C` 停止監控。\n\n---\n\n### 步驟 7：驗證部署功能\n\n建立一個測試 Deployment 來驗證叢集功能：\n\n```bash title=\"建立測試 Deployment\"\nkubectl create deployment test1 --image=httpd\n```\n\n**預期結果**：\n\n```\ndeployment.apps/test1 created\n```\n\n查看 Deployment 狀態：\n\n```bash title=\"查看 Deployment\"\nkubectl get deployments\n```\n\n```bash title=\"查看 Pod 詳細資訊\"\nkubectl get pods -o wide\n```\n\n**預期結果**（Pod Running）：\n\n```\nNAME                     READY   STATUS    RESTARTS   AGE   IP            NODE\ntest1-5b88789dbb-h99dh   1/1     Running   0          30s   10.244.1.2    k8s-node1.training.lab\n```\n\n!!! tip \"清理測試資源\"\n    測試完成後，可以刪除測試 Deployment：\n    ```bash\n    kubectl delete deployment test1\n    ```\n\n---\n\n### 常用檢查指令\n\n```bash title=\"檢查所有 Pod（包含系統 Pod）\"\nkubectl get pods -A\n```\n\n```bash title=\"檢查叢集資訊\"\nkubectl cluster-info\n```\n\n```bash title=\"查看節點詳細資訊\"\nkubectl describe node k8s-master1.training.lab\n```\n\n```bash title=\"檢查 CRI-O 狀態\"\nsystemctl status crio\n```\n\n```bash title=\"檢查 kubelet 狀態\"\nsystemctl status kubelet\n```\n\n---\n\n### 安裝摘要\n\n| 項目 | 版本/值 |\n|------|---------|\n| **Kubernetes** | 1.32.11 |\n| **CRI-O** | 1.32.1 |\n| **Docker CE** | 29.2.0 |\n| **CNI** | Antrea |\n| **Pod Network CIDR** | 10.244.0.0/16 |\n| **Service CIDR** | 172.30.0.0/16 |\n\n!!! success \"完成確認\"\n    當所有節點顯示 `Ready` 狀態，且測試 Pod 可以正常運行，表示 Kubernetes 叢集安裝成功！\n\n---\n\n## 小結\n\n本章節重點回顧：\n\n- ✅ **環境準備**：啟動三台虛擬機（k8s-master1、k8s-node1、k8s-node2）\n- ✅ **網路確認**：確保節點間可以互相通訊，且可連接網際網路\n- ✅ **腳本安裝**：使用 `install_k8s-latest.sh -full` 自動化安裝\n- ✅ **核心元件**：安裝 kubeadm、kubectl、kubelet v1.32.11\n- ✅ **容器執行環境**：安裝 CRI-O v1.32.1\n- ✅ **CNI 網路**：部署 Antrea 網路插件\n- ✅ **叢集驗證**：確認所有節點 Ready 並測試 Deployment\n\n## 延伸閱讀\n\n- [Kubernetes 官方文件](https://kubernetes.io/docs/)\n- [kubeadm 安裝指南](https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/)\n- [CRI-O 官方文件](https://cri-o.io/)\n- [Antrea CNI](https://antrea.io/)\n"
  },
  {
    "title": "完整寫法",
    "url": "https://caocharles.github.io/dcka-class-notes/lab13_k8s_commands/",
    "content": "﻿# LAB 13 Kubernetes 常用指令\n\n## 學習目標\n\n完成本章節後，你將能夠：\n\n- [ ] 使用 kubectl 建立與管理 Deployment\n- [ ] 使用 kubectl run 建立獨立 Pod\n- [ ] 使用 kubectl scale 手動擴展 Deployment\n- [ ] 使用 kubectl autoscale 設定自動擴展（HPA）\n- [ ] 使用 Labels 標籤管理與查詢 Pod\n- [ ] 使用 YAML 檔案部署與刪除資源\n\n## 前置知識\n\n開始之前，請確保你已經：\n\n- 完成 LAB 12 Kubernetes 叢集安裝\n- 熟悉 Kubernetes 基本概念（Pod、Deployment、Service）\n- 準備好 Kubernetes 叢集環境（k8s-master1）\n\n---\n\n## 核心概念說明\n\n### kubectl 是什麼？\n\n`kubectl`（讀音：kube-control 或 kube-C-T-L）是 Kubernetes 的**命令列工具（CLI）**，用來與 Kubernetes 叢集進行互動。\n\n```mermaid\ngraph LR\n    User[使用者] --> kubectl[kubectl 指令]\n    kubectl --> API[API Server]\n    API --> Controller[Controller Manager]\n    API --> Scheduler[Scheduler]\n    API --> etcd[(etcd)]\n```\n\n!!! info \"kubectl 功能\"\n    - 建立、查看、更新、刪除 Kubernetes 資源\n    - 查看叢集狀態與日誌\n    - 進入容器執行指令\n    - 部署應用程式\n\n---\n\n### Pod 是什麼？\n\n**Pod（豆莢）** 是 Kubernetes 中**最小的部署單位**，一個 Pod 可以包含一個或多個容器（Container）。\n\n```mermaid\ngraph TB\n    subgraph \"Pod\"\n        C1[Container 1]\n        C2[Container 2]\n        Volume[(Shared Volume)]\n        C1 -.-> Volume\n        C2 -.-> Volume\n    end\n    Network[Shared Network<br/>同一個 IP]\n    Pod --> Network\n```\n\n| 特性 | 說明 |\n|------|------|\n| **共享網路** | 同一個 Pod 內的容器共享相同的 IP 位址和 Port |\n| **共享儲存** | 可以掛載共享的 Volume |\n| **生命週期** | Pod 是臨時性的，可能隨時被重新調度 |\n| **最小單位** | 無法部署「半個容器」，Pod 是不可分割的 |\n\n---\n\n### Deployment 是什麼？\n\n**Deployment（部署）** 是 Kubernetes 中用來**管理 Pod 副本數量和更新策略**的控制器（Controller）。\n\n```mermaid\ngraph TB\n    D[Deployment] --> RS[ReplicaSet]\n    RS --> P1[Pod 1]\n    RS --> P2[Pod 2]\n    RS --> P3[Pod 3]\n```\n\n| Deployment 功能 | 說明 |\n|-----------------|------|\n| **副本管理** | 確保指定數量的 Pod 副本始終運行 |\n| **自動修復** | Pod 掛掉時自動建立新的 Pod |\n| **滾動更新** | 更新應用程式時逐步替換舊 Pod |\n| **回滾** | 發現問題時可以回到先前版本 |\n\n!!! tip \"Pod vs Deployment\"\n    - **直接建立 Pod**（使用 `kubectl run`）：適合測試，但 Pod 掛掉後**不會自動重建**\n    - **使用 Deployment**（使用 `kubectl create deployment`）：正式環境推薦，會**自動維護指定數量的 Pod**\n\n---\n\n### API 資源簡稱\n\n在 `kubectl` 指令中，你可能會看到不同的資源名稱寫法：\n\n| 完整名稱 | 簡稱 | 說明 |\n|----------|------|------|\n| `pods` | `po` | Pod 資源 |\n| `deployments.apps` | `deploy` | Deployment 資源 |\n| `services` | `svc` | Service 資源 |\n| `replicasets.apps` | `rs` | ReplicaSet 資源 |\n| `namespaces` | `ns` | Namespace 資源 |\n| `configmaps` | `cm` | ConfigMap 資源 |\n| `secrets` | `secret` | Secret 資源 |\n| `persistentvolumeclaims` | `pvc` | PVC 資源 |\n\n**範例**：以下指令效果相同：\n\n```bash\n# 完整寫法\nkubectl get deployments.apps\n\n# 簡稱寫法\nkubectl get deploy\n```\n\n!!! note \"deployments.apps 的由來\"\n    `deployments.apps` 表示 Deployment 資源屬於 `apps` API 群組。這是因為 Kubernetes 的 API 分成多個群組（如 `core`、`apps`、`batch`），完整寫法可以明確指定資源來源。\n\n---\n\n## Lab 實作練習：Kubernetes 基本指令操作\n\n### 環境準備\n\n```mermaid\ngraph TB\n    subgraph \"Kubernetes Cluster\"\n        Master[k8s-master1<br/>192.168.66.71<br/>Control Plane]\n        Node1[k8s-node1<br/>192.168.66.81<br/>Worker Node]\n        Node2[k8s-node2<br/>192.168.66.82<br/>Worker Node]\n        Master --> Node1\n        Master --> Node2\n    end\n    \n    subgraph \"Private Registry\"\n        Docker1[docker1.training.lab:5000<br/>私有映像檔倉庫]\n    end\n    \n    Master -.-> Docker1\n    Node1 -.-> Docker1\n    Node2 -.-> Docker1\n```\n\n---\n\n### 步驟 1：初始化私有 Registry 連線設定\n\n為了讓所有節點都能從私有 Registry 拉取映像檔，需要先執行初始化腳本：\n\n```bash title=\"下載初始化腳本\"\nwget http://10.0.1.249/k8s/scripts/init_pull_from_private_registry.sh\n```\n\n**預期結果**：\n\n```\n--2026-01-28 10:40:26--  http://10.0.1.249/k8s/scripts/init_pull_from_private_registry.sh\nConnecting to 10.0.1.249:80... connected.\nHTTP request sent, awaiting response... 200 OK\nLength: 3711 (3.6K) [application/x-sh]\nSaving to: 'init_pull_from_private_registry.sh'\n\ninit_pull_from_private_registry.sh   100%[======>]   3.62K  --.-KB/s    in 0s      \n\n2026-01-28 10:40:26 (760 MB/s) - 'init_pull_from_private_registry.sh' saved [3711/3711]\n```\n\n設定執行權限並執行腳本：\n\n```bash title=\"設定權限並執行\"\nchmod 755 init_pull_from_private_registry.sh\n./init_pull_from_private_registry.sh\n```\n\n**預期結果**（部分輸出）：\n\n```\ndocker1\nWarning: Permanently added 'docker1' (ED25519) to the list of known hosts.\ndocker1.training.lab\ndocker-ce-29.1.5-1.el9.x86_64\nInstall docker-ce...\ncontainerd.io-2.2.1-1.el9.x86_64\nInstall containerd.io...\n...\nk8s-master1\nk8s-master1.training.lab\ndocker-ce-29.2.0-1.el9.x86_64\nInstall docker-ce...\ncontainerd.io-2.2.1-1.el9.x86_64\nInstall containerd.io...\ncri-o-1.32.1-150500.1.1.x86_64\nInstall cri-o...\n```\n\n!!! info \"腳本功能\"\n    此腳本會自動設定所有節點（docker1、docker2、k8s-standalone、k8s-master1、k8s-node1、k8s-node2）的 Docker、containerd 和 CRI-O 環境，使其能夠從私有 Registry 拉取映像檔。\n\n---\n\n### 步驟 2：清理現有資源\n\n下載並執行清理腳本：\n\n```bash title=\"下載清理腳本\"\ncurl -LO http://10.0.1.249/k8s/scripts/kube_clean_all.sh\nchmod 755 kube_clean_all.sh\n```\n\n執行清理：\n\n```bash title=\"清理所有資源\"\n./kube_clean_all.sh\n```\n\n**預期結果**：\n\n```\nservice \"kubernetes\" deleted\ndeployment.apps \"test1\" deleted\nNo resources found\nconfigmap \"kube-root-ca.crt\" deleted\nnamespace \"kube-node-lease\" deleted\nError from server (Forbidden): namespaces \"default\" is forbidden: this namespace may not be deleted\nError from server (Forbidden): namespaces \"kube-public\" is forbidden: this namespace may not be deleted\nError from server (Forbidden): namespaces \"kube-system\" is forbidden: this namespace may not be deleted\n```\n\n!!! warning \"系統命名空間\"\n    `default`、`kube-public`、`kube-system` 為系統保護的命名空間，無法被刪除，出現錯誤訊息是正常的。\n\n---\n\n### 步驟 3：建立 Deployment\n\n使用 `kubectl create deployment` 建立 Deployment：\n\n```bash title=\"建立 Deployment (4 個副本)\"\nkubectl create deployment test1 --image=docker1.training.lab:5000/httpd --replicas=4\n```\n\n**預期結果**：\n\n```\ndeployment.apps/test1 created\n```\n\n查看 Deployment 狀態：\n\n```bash title=\"查看 Deployment\"\nkubectl get deployments.apps\n```\n\n**預期結果**：\n\n```\nNAME    READY   UP-TO-DATE   AVAILABLE   AGE\ntest1   0/4     4            0           13s\n```\n\n查看 Pod 詳細資訊：\n\n```bash title=\"查看 Pod 詳細位置\"\nkubectl get pods -o wide\n```\n\n**預期結果**：\n\n```\nNAME                    READY   STATUS    RESTARTS   AGE     IP       NODE     NOMINATED NODE   READINESS GATES\ntest1-dcd787f9d-9rkdj   0/1     Pending   0          5m49s   <none>   <none>   <none>           <none>\ntest1-dcd787f9d-cqqmc   0/1     Pending   0          5m49s   <none>   <none>   <none>           <none>\ntest1-dcd787f9d-l5rmx   0/1     Pending   0          5m49s   <none>   <none>   <none>           <none>\ntest1-dcd787f9d-rznwh   0/1     Pending   0          5m49s   <none>   <none>   <none>           <none>\n```\n\n!!! note \"Pending 狀態\"\n    如果 Pod 顯示 `Pending` 狀態，可能是因為：\n    \n    - Worker Node 尚未 Ready\n    - 資源不足\n    - 無法拉取映像檔\n    \n    使用 `kubectl describe pod <pod-name>` 查看詳細原因。\n\n---\n\n### 步驟 4：刪除 Pod 與 Deployment\n\n刪除單一 Pod：\n\n```bash title=\"刪除指定 Pod\"\nkubectl delete pod/test1-dcd787f9d-rznwh\n```\n\n**預期結果**：\n\n```\npod \"test1-dcd787f9d-rznwh\" deleted\n```\n\n!!! tip \"Pod 名稱格式\"\n    Pod 名稱格式為 `<deployment-name>-<replicaset-hash>-<pod-hash>`。\n    注意不要多打連字號（`--`），否則會找不到 Pod。\n\n刪除整個 Deployment（會同時刪除所有相關 Pod）：\n\n```bash title=\"刪除 Deployment\"\nkubectl delete deployments.apps test1\n```\n\n**預期結果**：\n\n```\ndeployment.apps \"test1\" deleted\n```\n\n驗證刪除結果：\n\n```bash title=\"確認刪除完成\"\nkubectl get deployments.apps\nkubectl get pods\n```\n\n**預期結果**：\n\n```\nNo resources found in default namespace.\n```\n\n---\n\n### 步驟 5：使用 kubectl run 建立 Pod\n\n使用 `kubectl run` 直接建立獨立 Pod（不透過 Deployment）：\n\n```bash title=\"建立 Pod 並設定環境變數\"\nkubectl run test4 --image=docker1.training.lab:5000/nginx --env=\"TEST=test4\"\n```\n\n**預期結果**：\n\n```\npod/test4 created\n```\n\n進入 Pod 執行指令（使用 `kubectl exec`）：\n\n```bash title=\"進入 Pod 執行 bash\"\nkubectl exec test4 -it -- bash\n```\n\n!!! warning \"常見錯誤\"\n    **錯誤寫法**：`kubectl exec test4 -it --bash`（缺少 `--` 分隔符）\n    \n    **正確寫法**：`kubectl exec test4 -it -- bash`\n    \n    `--` 用來分隔 kubectl 參數和容器內要執行的指令。\n\n---\n\n### 步驟 6：建立與擴展 Deployment\n\n建立 Deployment：\n\n```bash title=\"建立 test5 Deployment\"\nkubectl create deployment test5 --image=docker1.training.lab:5000/nginx\n```\n\n```bash title=\"建立 test6 Deployment（2 個副本）\"\nkubectl create deployment test6 --image=docker1.training.lab:5000/nginx --replicas=2\n```\n\n查看 Deployment 狀態：\n\n```bash title=\"查看特定 Deployment\"\nkubectl get deployments.apps test5\nkubectl get deployments.apps test6\n```\n\n**預期結果**：\n\n```\nNAME    READY   UP-TO-DATE   AVAILABLE   AGE\ntest5   0/1     1            0           28s\n\nNAME    READY   UP-TO-DATE   AVAILABLE   AGE\ntest6   0/2     2            0           4m43s\n```\n\n---\n\n### 步驟 7：手動擴展 Deployment（Scale）\n\n使用 `kubectl scale` 手動調整副本數量：\n\n```bash title=\"擴展 test5 到 3 個副本\"\nkubectl scale deployment test5 --replicas=3\n```\n\n**預期結果**：\n\n```\ndeployment.apps/test5 scaled\n```\n\n驗證擴展結果：\n\n```bash title=\"查看擴展後的狀態\"\nkubectl get deployments.apps test5\nkubectl get pods | grep test5\n```\n\n**預期結果**：\n\n```\nNAME    READY   UP-TO-DATE   AVAILABLE   AGE\ntest5   0/3     3            0           10m\n\ntest5-8464657978-5jgj6   0/1     Pending   0          10m\ntest5-8464657978-fc7zg   0/1     Pending   0          28s\ntest5-8464657978-sqgql   0/1     Pending   0          28s\n```\n\n---\n\n### 步驟 8：設定自動擴展（Autoscale / HPA）\n\n使用 `kubectl autoscale` 建立 Horizontal Pod Autoscaler（HPA）：\n\n```bash title=\"設定自動擴展\"\nkubectl autoscale deployment test5 --min=4 --max=9 --cpu-percent=80\n```\n\n**預期結果**：\n\n```\nhorizontalpodautoscaler.autoscaling/test5 autoscaled\n```\n\n!!! warning \"常見錯誤\"\n    **錯誤寫法**：\n    \n    - `--cpu80%`（缺少等號和 percent）\n    - `--cpu 80%`（有空格、缺少 percent）\n    - `--cpu=80%`（flag 名稱錯誤）\n    \n    **正確寫法**：`--cpu-percent=80`\n\n驗證 HPA 效果：\n\n```bash title=\"查看擴展後的 Deployment\"\nkubectl get deployments.apps test5\n```\n\n**預期結果**：\n\n```\nNAME    READY   UP-TO-DATE   AVAILABLE   AGE\ntest5   0/4     4            0           12m\n```\n\n!!! info \"HPA 說明\"\n    HPA 會根據 CPU 使用率自動調整 Pod 數量：\n    \n    - **--min=4**：最少維持 4 個副本\n    - **--max=9**：最多擴展到 9 個副本\n    - **--cpu-percent=80**：當 CPU 使用率超過 80% 時觸發擴展\n\n---\n\n### 步驟 9：使用 Labels 標籤管理 Pod\n\n建立帶有自訂 Label 的 Pod：\n\n```bash title=\"建立帶有 Label 的 Pod\"\nkubectl run test7 --image=docker1.training.lab:5000/nginx --labels=\"os=linux\"\n```\n\n**預期結果**：\n\n```\npod/test7 created\n```\n\n!!! warning \"常見錯誤\"\n    **錯誤寫法**：`kubectl run test8 --image=nginx ==labels=\"os=windows\"`（兩個等號）\n    \n    **正確寫法**：`kubectl run test8 --image=nginx --labels=\"os=windows\"`\n\n查看 Pod Labels：\n\n```bash title=\"顯示所有 Pod 的 Labels\"\nkubectl get pods --show-labels\n```\n\n**預期結果**：\n\n```\nNAME                     READY   STATUS    RESTARTS   AGE     LABELS\ntest4                    0/1     Pending   0          18m     run=test4\ntest5-8464657978-5jgj6   0/1     Pending   0          14m     app=test5,pod-template-hash=8464657978\ntest7                    0/1     Pending   0          47s     os=linux\ntest8                    0/1     Pending   0          13s     run=test8\n```\n\n依據 Label 過濾 Pod：\n\n```bash title=\"過濾包含 os Label 的 Pod\"\nkubectl get pods --show-labels | grep 'os='\n```\n\n```bash title=\"顯示特定 Label 欄位\"\nkubectl get pods -L os\n```\n\n**預期結果**：\n\n```\nNAME                     READY   STATUS    RESTARTS   AGE     OS\ntest4                    0/1     Pending   0          20m     \ntest5-8464657978-5jgj6   0/1     Pending   0          16m     \ntest7                    0/1     Pending   0          2m57s   linux\ntest8                    0/1     Pending   0          2m23s   \n```\n\n!!! tip \"Label 使用技巧\"\n    - `--show-labels`：顯示所有 Labels\n    - `-L <label-key>`：將指定的 Label 顯示為獨立欄位\n    - `-l <label-selector>`：依據 Label 過濾資源\n\n---\n\n### 步驟 10：使用 YAML 檔案部署\n\n從 URL 直接套用 YAML 檔案：\n\n```bash title=\"從 URL 套用 YAML\"\nkubectl apply -f http://10.0.1.249/k8s/yaml/test9.yaml\n```\n\n**預期結果**：\n\n```\npod/test9 created\n```\n\n!!! warning \"常見錯誤\"\n    注意 URL 路徑要正確（`/k8s/yaml/`），打錯會出現 404 錯誤：\n    ```\n    error: unable to read URL \"http://10.0.1.249/k8s/taml/test9.yaml\", \n    server reported 404 Not Found, status code=404\n    ```\n\n下載 YAML 檔案查看內容：\n\n```bash title=\"下載 YAML 檔案\"\nwget http://10.0.1.249/k8s/yaml/test9.yaml\n```\n\n```bash title=\"查看 YAML 內容\"\ncat test9.yaml\n```\n\n**YAML 內容**：\n\n```yaml title=\"test9.yaml\"\napiVersion: v1\nkind: Pod\nmetadata:\n  name: test9\nspec:\n  containers:\n  - name: test9\n    image: docker1.training.lab:5000/nginx\n```\n\n使用本地 YAML 檔案刪除資源：\n\n```bash title=\"使用 YAML 刪除資源\"\nkubectl delete -f test9.yaml\n```\n\n**預期結果**：\n\n```\npod \"test9\" deleted\n```\n\n!!! tip \"YAML 部署的優點\"\n    - **版本控制**：可以將 YAML 檔案納入 Git 管理\n    - **重複使用**：同一個 YAML 可以重複部署\n    - **完整定義**：YAML 可以包含更多進階設定\n\n---\n\n## 常用 kubectl 指令對照表\n\n| 操作 | 指令 | 範例 |\n|------|------|------|\n| **建立 Deployment** | `kubectl create deployment` | `kubectl create deployment test --image=nginx --replicas=3` |\n| **建立 Pod** | `kubectl run` | `kubectl run test --image=nginx --env=\"KEY=value\"` |\n| **查看資源** | `kubectl get` | `kubectl get pods -o wide` |\n| **擴展副本** | `kubectl scale` | `kubectl scale deployment test --replicas=5` |\n| **自動擴展** | `kubectl autoscale` | `kubectl autoscale deployment test --min=2 --max=10 --cpu-percent=80` |\n| **進入容器** | `kubectl exec` | `kubectl exec test -it -- bash` |\n| **刪除資源** | `kubectl delete` | `kubectl delete pod/test` |\n| **套用 YAML** | `kubectl apply -f` | `kubectl apply -f deployment.yaml` |\n| **刪除 YAML 資源** | `kubectl delete -f` | `kubectl delete -f deployment.yaml` |\n\n---\n\n## 常見問題\n\n??? question \"Q1：Pod 一直處於 Pending 狀態怎麼辦？\"\n    **原因**：通常是因為沒有可用的 Worker Node 或節點資源不足。\n    \n    **解決方案**：\n    ```bash\n    # 查看詳細原因\n    kubectl describe pod <pod-name>\n    \n    # 確認節點狀態\n    kubectl get nodes\n    ```\n\n??? question \"Q2：kubectl exec 出現錯誤 'unknown flag: --bash'\"\n    **原因**：`--bash` 應該放在 `--` 後面，作為容器內執行的指令。\n    \n    **解決方案**：\n    ```bash\n    # 錯誤\n    kubectl exec test -it --bash\n    \n    # 正確\n    kubectl exec test -it -- bash\n    ```\n\n??? question \"Q3：如何查看特定 Label 的 Pod？\"\n    **解答**：使用 `-l` 或 `-L` 參數：\n    \n    ```bash\n    # 依據 Label 過濾\n    kubectl get pods -l os=linux\n    \n    # 顯示 Label 欄位\n    kubectl get pods -L os\n    ```\n\n---\n\n## 小結\n\n本章節重點回顧：\n\n- ✅ **環境初始化**：使用腳本設定私有 Registry 連線\n- ✅ **Deployment 管理**：使用 `kubectl create deployment` 建立並管理 Deployment\n- ✅ **Pod 操作**：使用 `kubectl run` 建立獨立 Pod，`kubectl exec` 進入容器\n- ✅ **手動擴展**：使用 `kubectl scale` 調整副本數量\n- ✅ **自動擴展**：使用 `kubectl autoscale` 設定 HPA\n- ✅ **Labels 管理**：使用 `--labels` 建立標籤，`--show-labels` 和 `-L` 查詢\n- ✅ **YAML 部署**：使用 `kubectl apply -f` 和 `kubectl delete -f` 管理資源\n\n## 延伸閱讀\n\n- [kubectl 完整指令參考](https://kubernetes.io/docs/reference/kubectl/)\n- [Kubernetes Deployments](https://kubernetes.io/docs/concepts/workloads/controllers/deployment/)\n- [Horizontal Pod Autoscaler](https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/)\n- [Labels and Selectors](https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/)\n"
  },
  {
    "title": "查看卡住的資源",
    "url": "https://caocharles.github.io/dcka-class-notes/lab14_namespace_rolling/",
    "content": "﻿# LAB 14 Namespace 與 Rolling Update\n\n## 學習目標\n\n完成本章節後，你將能夠：\n\n- [ ] 使用 kubectl 建立與管理 Namespace\n- [ ] 在不同 Namespace 中部署與查詢資源\n- [ ] 使用 `--dry-run=client -o yaml` 產生 YAML 檔案\n- [ ] 使用 `kubectl apply -f` 套用 YAML 更新進行 Rolling Update\n- [ ] 使用 `kubectl rollout` 查看歷史紀錄與回滾版本\n\n## 前置知識\n\n開始之前，請確保你已經：\n\n- 完成 LAB 13 Kubernetes 常用指令\n- 熟悉 Pod、Deployment 基本概念\n- 準備好 Kubernetes 叢集環境（k8s-master1）\n\n---\n\n## 核心概念說明\n\n### Namespace 是什麼？\n\n**Namespace（命名空間）** 是 Kubernetes 中用來**隔離資源的虛擬分區**。不同 Namespace 中的資源名稱可以相同，彼此不會衝突。\n\n```mermaid\ngraph TB\n    subgraph \"Kubernetes Cluster\"\n        subgraph \"default namespace\"\n            D1[Deployment A]\n            P1[Pod A]\n        end\n        subgraph \"ns1 namespace\"\n            D2[Deployment A]\n            P2[Pod A]\n        end\n        subgraph \"kube-system namespace\"\n            D3[CoreDNS]\n            D4[Antrea]\n        end\n    end\n```\n\n| Namespace 用途 | 說明 |\n|----------------|------|\n| **資源隔離** | 不同團隊或專案使用不同 Namespace |\n| **權限控制** | 可以設定不同 Namespace 的存取權限 |\n| **資源配額** | 可以限制各 Namespace 的資源使用量 |\n| **名稱區隔** | 同名資源可以存在於不同 Namespace |\n\n---\n\n### Rolling Update 是什麼？\n\n**Rolling Update（滾動更新）** 是 Kubernetes 更新 Deployment 的預設策略，會**逐步**將舊版 Pod 替換成新版，確保服務不中斷。\n\n```mermaid\ngraph LR\n    subgraph \"更新前\"\n        P1[Pod v1.7.1]\n        P2[Pod v1.7.1]\n        P3[Pod v1.7.1]\n    end\n    \n    subgraph \"更新中\"\n        P4[Pod v1.7.1]\n        P5[Pod v1.9.1]\n        P6[Pod v1.9.1]\n    end\n    \n    subgraph \"更新後\"\n        P7[Pod v1.9.1]\n        P8[Pod v1.9.1]\n        P9[Pod v1.9.1]\n    end\n    \n    更新前 --> 更新中 --> 更新後\n```\n\n| Rolling Update 特性 | 說明 |\n|---------------------|------|\n| **零停機時間** | 更新過程中服務不中斷 |\n| **逐步替換** | 一次只替換部分 Pod |\n| **可回滾** | 發現問題可以回到先前版本 |\n| **歷史紀錄** | 保留部署版本歷史 |\n\n---\n\n## Lab 實作練習：Namespace 管理\n\n### 步驟 1：啟用 kubectl 指令自動補齊\n\n設定 bash 自動補齊功能，方便操作：\n\n```bash title=\"啟用 bash completion\"\nsource <(kubectl completion bash)\n```\n\n!!! tip \"永久生效\"\n    將上述指令加入 `~/.bashrc`，每次登入自動啟用：\n    ```bash\n    echo 'source <(kubectl completion bash)' >> ~/.bashrc\n    ```\n\n---\n\n### 步驟 2：清理所有資源\n\n使用 `kubectl delete all --all` 刪除目前 Namespace 中的所有資源：\n\n```bash title=\"刪除所有資源\"\nkubectl delete all --all\n```\n\n**預期結果**：\n\n```\npod \"test4\" deleted\npod \"test5-8464657978-5jgj6\" deleted\nservice \"kubernetes\" deleted\ndeployment.apps \"test5\" deleted\ndeployment.apps \"test6\" deleted\nreplicaset.apps \"test5-8464657978\" deleted\nhorizontalpodautoscaler.autoscaling \"test5\" deleted\n```\n\n!!! info \"all 包含哪些資源？\"\n    `kubectl delete all --all` 會刪除以下資源類型：\n    \n    - Pod\n    - Service\n    - Deployment\n    - ReplicaSet\n    - StatefulSet\n    - DaemonSet\n    - Job\n    - CronJob\n    \n    **不包含**：ConfigMap、Secret、PV、PVC、Namespace 等。\n\n---\n\n### 步驟 3：查看現有 Namespace\n\n```bash title=\"查看所有 Namespace\"\nkubectl get namespaces\n```\n\n**預期結果**：\n\n```\nNAME              STATUS   AGE\ndefault           Active   19h\nkube-node-lease   Active   19h\nkube-public       Active   19h\nkube-system       Active   19h\n```\n\n| Namespace | 用途 |\n|-----------|------|\n| **default** | 預設命名空間，未指定時使用 |\n| **kube-system** | Kubernetes 系統元件（CoreDNS、CNI 等） |\n| **kube-public** | 公開資源，所有使用者可讀取 |\n| **kube-node-lease** | 節點心跳資訊 |\n\n---\n\n### 步驟 4：建立自訂 Namespace\n\n```bash title=\"建立 Namespace\"\nkubectl create namespace ns1\nkubectl create namespace ns2\n```\n\n**預期結果**：\n\n```\nnamespace/ns1 created\nnamespace/ns2 created\n```\n\n驗證建立結果：\n\n```bash title=\"查看 Namespace\"\nkubectl get namespaces\n```\n\n**預期結果**：\n\n```\nNAME              STATUS   AGE\ndefault           Active   19h\nkube-node-lease   Active   19h\nkube-public       Active   19h\nkube-system       Active   19h\nns1               Active   12s\nns2               Active   8s\n```\n\n---\n\n### 步驟 5：在不同 Namespace 建立 Deployment\n\n使用 `--namespace=` 參數指定 Namespace：\n\n```bash title=\"在 ns1 建立 Deployment\"\nkubectl create deployment test1 --image=docker1.training.lab:5000/nginx --namespace=ns1\n```\n\n```bash title=\"在 ns2 建立 Deployment\"\nkubectl create deployment test2 --image=docker1.training.lab:5000/nginx --namespace=ns2\n```\n\n**預期結果**：\n\n```\ndeployment.apps/test1 created\ndeployment.apps/test2 created\n```\n\n---\n\n### 步驟 6：查詢不同 Namespace 的資源\n\n查詢預設 Namespace（會找不到資源）：\n\n```bash title=\"查詢 default Namespace\"\nkubectl get deployments.apps\n```\n\n**預期結果**：\n\n```\nNo resources found in default namespace.\n```\n\n查詢所有 Namespace：\n\n```bash title=\"查詢所有 Namespace（完整參數）\"\nkubectl get deployments.apps --all-namespaces\n```\n\n```bash title=\"查詢所有 Namespace（簡寫）\"\nkubectl get deployments.apps -A\n```\n\n**預期結果**：\n\n```\nNAMESPACE     NAME                READY   UP-TO-DATE   AVAILABLE   AGE\nkube-system   antrea-controller   1/1     1            1           19h\nkube-system   coredns             2/2     2            2           19h\nns1           test1               1/1     1            1           43s\nns2           test2               1/1     1            1           27s\n```\n\n查詢特定 Namespace：\n\n```bash title=\"查詢 ns1 的 Deployment\"\nkubectl get deployments.apps --namespace=ns1\n```\n\n```bash title=\"查詢 ns2 的 Deployment（簡寫）\"\nkubectl get deployments.apps -n ns2\n```\n\n!!! warning \"常見錯誤\"\n    **錯誤寫法**：`--namespaces=ns1`（多了 s）\n    \n    **正確寫法**：`--namespace=ns1` 或 `-n ns1`\n\n---\n\n### 步驟 7：刪除 Namespace\n\n刪除 Namespace 會**同時刪除該 Namespace 中的所有資源**：\n\n```bash title=\"刪除 Namespace\"\nkubectl delete namespace ns1\nkubectl delete namespace ns2\n```\n\n!!! warning \"刪除時間\"\n    Namespace 刪除可能需要一段時間，狀態會變成 `Terminating`：\n    ```\n    NAME   STATUS        AGE\n    ns1    Terminating   3m5s\n    ns2    Terminating   3m1s\n    ```\n    等待刪除完成即可。\n\n!!! danger \"系統 Namespace 無法刪除\"\n    `default`、`kube-public`、`kube-system` 為系統保護的 Namespace，無法被刪除。\n\n---\n\n## Lab 實作練習：Rolling Update 滾動更新\n\n### 步驟 1：使用 dry-run 產生 YAML\n\n使用 `--dry-run=client -o yaml` 可以產生 YAML 檔案而不實際建立資源：\n\n```bash title=\"產生 nginx 1.7.1 的 Deployment YAML\"\nkubectl create deployment test1 --image=docker1.training.lab:5000/nginx:1.7.1 --replicas=3 --dry-run=client -o yaml > test1-1.7.1.yaml\n```\n\n查看產生的 YAML：\n\n```bash title=\"查看 YAML 內容\"\ncat test1-1.7.1.yaml\n```\n\n**YAML 內容**：\n\n```yaml title=\"test1-1.7.1.yaml\"\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  creationTimestamp: null\n  labels:\n    app: test1\n  name: test1\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: test1\n  strategy: {}\n  template:\n    metadata:\n      creationTimestamp: null\n      labels:\n        app: test1\n    spec:\n      containers:\n      - image: docker1.training.lab:5000/nginx:1.7.1\n        name: nginx\n        resources: {}\nstatus: {}\n```\n\n!!! tip \"dry-run 的用途\"\n    - **產生 YAML 模板**：快速產生標準格式的 YAML\n    - **版本管理**：將 YAML 存入 Git 進行版本控制\n    - **測試指令**：驗證指令語法正確但不實際執行\n\n---\n\n### 步驟 2：套用 YAML 建立 Deployment\n\n```bash title=\"套用 YAML\"\nkubectl apply -f test1-1.7.1.yaml\n```\n\n**預期結果**：\n\n```\ndeployment.apps/test1 created\n```\n\n---\n\n### 步驟 3：監控 Deployment 狀態\n\n使用 while 迴圈持續監控映像檔版本：\n\n```bash title=\"監控 Pod 映像檔版本\"\nwhile true; do \n  for i in $(kubectl get pods | tail -n +2 | awk '{ print $1 }'); do \n    kubectl get pod ${i} -o yaml | grep \"\\- image: .*nginx\"\n  done\n  echo\n  kubectl get deployments -o wide\n  echo\n  sleep 1\ndone\n```\n\n**預期結果**：\n\n```\n  - image: docker1.training.lab:5000/nginx:1.7.1\n  - image: docker1.training.lab:5000/nginx:1.7.1\n  - image: docker1.training.lab:5000/nginx:1.7.1\n\nNAME    READY   UP-TO-DATE   AVAILABLE   AGE     CONTAINERS   IMAGES                                  SELECTOR\ntest1   3/3     3            3           3m45s   nginx        docker1.training.lab:5000/nginx:1.7.1   app=test1\n```\n\n按 `Ctrl+C` 停止監控。\n\n---\n\n### 步驟 4：產生新版本 YAML\n\n產生 nginx 1.9.1 版本的 YAML：\n\n```bash title=\"產生 nginx 1.9.1 的 YAML\"\nkubectl create deployment test1 --image=docker1.training.lab:5000/nginx:1.9.1 --replicas=3 --dry-run=client -o yaml > test1-1.9.1.yaml\n```\n\n---\n\n### 步驟 5：執行 Rolling Update\n\n使用 `kubectl apply -f` 套用新版本 YAML，觸發滾動更新：\n\n```bash title=\"套用新版本進行滾動更新\"\nkubectl apply -f test1-1.9.1.yaml\n```\n\n!!! info \"apply vs create\"\n    - `kubectl create`：建立新資源，如果已存在會報錯\n    - `kubectl apply`：建立或更新資源，如果已存在會進行更新\n\n---\n\n### 步驟 6：查看 Rollout 歷史紀錄\n\n```bash title=\"查看部署歷史\"\nkubectl rollout history deployment test1\n```\n\n**預期結果**：\n\n```\ndeployment.apps/test1\nREVISION  CHANGE-CAUSE\n1         <none>\n2         <none>\n```\n\n| 欄位 | 說明 |\n|------|------|\n| **REVISION** | 版本號，每次更新遞增 |\n| **CHANGE-CAUSE** | 變更原因（可用 `--record` 記錄） |\n\n---\n\n### 步驟 7：回滾到先前版本\n\n```bash title=\"回滾 Deployment\"\nkubectl rollout undo deployment test1\n```\n\n**預期結果**：\n\n```\ndeployment.apps/test1 rolled back\n```\n\n查看回滾後的歷史：\n\n```bash title=\"查看回滾後的歷史\"\nkubectl rollout history deployment test1\n```\n\n**預期結果**：\n\n```\ndeployment.apps/test1\nREVISION  CHANGE-CAUSE\n2         <none>\n3         <none>\n```\n\n!!! note \"版本號說明\"\n    回滾後，REVISION 不會回到 1，而是產生新的版本號 3。這是因為回滾操作本身也算是一次部署。\n\n---\n\n### 步驟 8：從 URL 套用與刪除 YAML\n\n可以直接從 URL 套用 YAML 檔案：\n\n```bash title=\"從 URL 套用 YAML\"\nkubectl apply -f https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/controllers/nginx-deployment.yaml\n```\n\n**預期結果**：\n\n```\ndeployment.apps/nginx-deployment created\n```\n\n查看部署結果：\n\n```bash title=\"查看 Deployment\"\nkubectl get deployments.apps\nkubectl get pods\n```\n\n**預期結果**：\n\n```\nNAME               READY   UP-TO-DATE   AVAILABLE   AGE\nnginx-deployment   3/3     3            3           77s\ntest1              3/3     3            3           9m18s\n\nNAME                                READY   STATUS    RESTARTS   AGE\nnginx-deployment-647677fc66-2m6ww   1/1     Running   0          82s\nnginx-deployment-647677fc66-4zmqw   1/1     Running   0          82s\nnginx-deployment-647677fc66-8h9zg   1/1     Running   0          82s\n```\n\n從 URL 刪除資源：\n\n```bash title=\"從 URL 刪除 YAML 定義的資源\"\nkubectl delete -f https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/controllers/nginx-deployment.yaml\n```\n\n**預期結果**：\n\n```\ndeployment.apps \"nginx-deployment\" deleted\n```\n\n---\n\n## 常用指令對照表\n\n### Namespace 操作\n\n| 操作 | 指令 | 範例 |\n|------|------|------|\n| **建立 Namespace** | `kubectl create namespace` | `kubectl create namespace ns1` |\n| **查看 Namespace** | `kubectl get namespaces` | `kubectl get ns` |\n| **刪除 Namespace** | `kubectl delete namespace` | `kubectl delete namespace ns1` |\n| **指定 Namespace** | `--namespace=` 或 `-n` | `kubectl get pods -n ns1` |\n| **查看所有 Namespace** | `--all-namespaces` 或 `-A` | `kubectl get pods -A` |\n\n### Rolling Update 操作\n\n| 操作 | 指令 | 範例 |\n|------|------|------|\n| **產生 YAML** | `--dry-run=client -o yaml` | `kubectl create deploy test --image=nginx --dry-run=client -o yaml` |\n| **套用 YAML** | `kubectl apply -f` | `kubectl apply -f deployment.yaml` |\n| **查看歷史** | `kubectl rollout history` | `kubectl rollout history deployment test` |\n| **回滾版本** | `kubectl rollout undo` | `kubectl rollout undo deployment test` |\n| **回滾到指定版本** | `--to-revision` | `kubectl rollout undo deployment test --to-revision=1` |\n| **查看狀態** | `kubectl rollout status` | `kubectl rollout status deployment test` |\n\n---\n\n## 常見問題\n\n??? question \"Q1：Namespace 刪除一直卡在 Terminating 狀態？\"\n    **原因**：Namespace 中可能有無法正常刪除的資源。\n    \n    **解決方案**：\n    ```bash\n    # 查看卡住的資源\n    kubectl get all -n <namespace>\n    \n    # 強制刪除\n    kubectl delete namespace <namespace> --force --grace-period=0\n    ```\n\n??? question \"Q2：如何回滾到特定版本？\"\n    **解答**：使用 `--to-revision` 參數：\n    \n    ```bash\n    # 先查看版本歷史\n    kubectl rollout history deployment test1\n    \n    # 回滾到指定版本\n    kubectl rollout undo deployment test1 --to-revision=1\n    ```\n\n??? question \"Q3：--dry-run=client 和 --dry-run=server 的差別？\"\n    **解答**：\n    \n    - `--dry-run=client`：在客戶端執行，不與 API Server 通訊\n    - `--dry-run=server`：送到 API Server 驗證，但不實際建立資源\n    \n    一般產生 YAML 使用 `--dry-run=client` 即可。\n\n---\n\n## 小結\n\n本章節重點回顧：\n\n- ✅ **Namespace 管理**：使用 `kubectl create/delete namespace` 建立與刪除命名空間\n- ✅ **跨 Namespace 查詢**：使用 `--namespace=`、`-n`、`-A` 參數\n- ✅ **YAML 產生**：使用 `--dry-run=client -o yaml` 產生 YAML 模板\n- ✅ **Rolling Update**：使用 `kubectl apply -f` 進行滾動更新\n- ✅ **歷史紀錄**：使用 `kubectl rollout history` 查看部署歷史\n- ✅ **版本回滾**：使用 `kubectl rollout undo` 回滾到先前版本\n\n## 延伸閱讀\n\n- [Kubernetes Namespaces](https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/)\n- [Deployment 滾動更新](https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#updating-a-deployment)\n- [Rollback 部署回滾](https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#rolling-back-a-deployment)\n"
  },
  {
    "title": "1. 檢查節點狀態",
    "url": "https://caocharles.github.io/dcka-class-notes/lab15_service/",
    "content": "﻿# LAB 15 Kubernetes Service\n\n## 學習目標\n\n完成本章節後，你將能夠：\n\n- [ ] 理解 Kubernetes Service 的三種類型\n- [ ] 建立 ClusterIP 類型的 Service\n- [ ] 建立 NodePort 類型的 Service\n- [ ] 建立 LoadBalancer 類型的 Service\n- [ ] 使用 curl 驗證 Service 的負載均衡功能\n\n## 前置知識\n\n開始之前，請確保你已經：\n\n- 完成 LAB 14 Namespace 與 Rolling Update\n- 熟悉 Pod、Deployment 基本概念\n- 準備好 Kubernetes 叢集環境（k8s-master1）\n\n---\n\n## 核心概念說明\n\n### Service 是什麼？\n\n**Service（服務）** 是 Kubernetes 中用來**暴露應用程式的穩定網路端點**。由於 Pod 的 IP 是動態的，每次重建可能會改變，Service 提供了一個固定的 IP 和 DNS 名稱，讓其他應用程式可以穩定地存取 Pod。\n\n```mermaid\ngraph LR\n    Client[客戶端] --> Service[Service<br/>固定 IP]\n    Service --> Pod1[Pod 1<br/>動態 IP]\n    Service --> Pod2[Pod 2<br/>動態 IP]\n    Service --> Pod3[Pod 3<br/>動態 IP]\n```\n\n---\n\n### Service 類型比較\n\n| 類型 | 存取範圍 | 使用場景 |\n|------|----------|----------|\n| **ClusterIP** | 叢集內部 | 內部服務、微服務間通訊 |\n| **NodePort** | 叢集外部（透過 Node IP） | 開發測試、小型部署 |\n| **LoadBalancer** | 叢集外部（透過 LB IP） | 生產環境、雲端部署 |\n\n```mermaid\ngraph TB\n    subgraph \"ClusterIP (叢集內部)\"\n        CI[Service ClusterIP] --> P1[Pod]\n    end\n    \n    subgraph \"NodePort (節點 Port)\"\n        NP[Node:30000-32767] --> NPSVC[Service]\n        NPSVC --> P2[Pod]\n    end\n    \n    subgraph \"LoadBalancer (負載均衡器)\"\n        LB[External LB IP] --> LBSVC[Service]\n        LBSVC --> P3[Pod]\n    end\n```\n\n---\n\n### Port 對應關係\n\nService 涉及三種 Port：\n\n| Port 名稱 | 說明 | 範例 |\n|-----------|------|------|\n| **port** | Service 的 Port（ClusterIP 使用） | 8081 |\n| **targetPort** | Pod/Container 的 Port | 80 |\n| **nodePort** | Node 對外開放的 Port（30000-32767） | 30008 |\n\n```mermaid\ngraph LR\n    External[外部請求] -->|nodePort: 30008| Node[Node IP]\n    Node -->|port: 8082| Service[Service ClusterIP]\n    Service -->|targetPort: 80| Pod[Pod]\n```\n\n---\n\n## Lab 實作練習：ClusterIP Service\n\n### ClusterIP 概述\n\n**ClusterIP** 是 Service 的預設類型，只能從叢集**內部**存取。\n\n```mermaid\ngraph TB\n    subgraph \"Kubernetes Cluster\"\n        subgraph \"service-clusterip-2 namespace\"\n            SVC[svc-2-httpd<br/>ClusterIP: 172.30.24.63:8081]\n            SVC --> Pod1[httpd-2<br/>10.128.1.14:80]\n            SVC --> Pod2[httpd-2<br/>10.128.2.9:80]\n        end\n    end\n    External[外部網路] -.->|無法存取| SVC\n```\n\n---\n\n### 步驟 1：下載 ClusterIP YAML\n\n```bash title=\"下載 ClusterIP 範例\"\nwget http://10.0.1.249/k8s/yaml/service-clusterIP.yaml\n```\n\n查看 YAML 內容：\n\n```bash title=\"查看 YAML\"\ncat service-clusterIP.yaml\n```\n\n**YAML 內容**：\n\n```yaml title=\"service-clusterIP.yaml\"\n---\napiVersion: v1\nkind: Namespace\nmetadata:\n  name: service-clusterip-2\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: svc-2-httpd\n  labels:\n    app: svc-2-httpd\n  namespace: service-clusterip-2\nspec:\n  type: ClusterIP\n  ports:\n  - port: 8081        # Service Port\n    targetPort: 80    # Pod Port\n  selector:\n    app: httpd-2      # 選擇帶有此 Label 的 Pod\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: httpd-2\n  labels:\n    app: httpd-2\n  namespace: service-clusterip-2\nspec:\n  replicas: 2\n  selector:\n    matchLabels:\n      app: httpd-2\n  template:\n    metadata:\n      labels:\n        app: httpd-2\n    spec:\n      containers:\n      - image: docker1.training.lab:5000/httpd\n        name: httpd\n        ports:\n        - containerPort: 80\n```\n\n!!! info \"YAML 結構說明\"\n    此 YAML 包含三個資源：\n    \n    1. **Namespace**：建立 `service-clusterip-2` 命名空間\n    2. **Service**：建立 ClusterIP 類型的 Service\n    3. **Deployment**：建立 2 個 httpd Pod\n\n---\n\n### 步驟 2：套用 YAML\n\n```bash title=\"套用 YAML\"\nkubectl apply -f service-clusterIP.yaml\n```\n\n**預期結果**：\n\n```\nnamespace/service-clusterip-2 created\nservice/svc-2-httpd created\ndeployment.apps/httpd-2 created\n```\n\n---\n\n### 步驟 3：查看 Service\n\n```bash title=\"查看所有 Service\"\nkubectl get service -A\n```\n\n**預期結果**：\n\n```\nNAMESPACE             NAME          TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)                  AGE\ndefault               kubernetes    ClusterIP   172.30.0.1       <none>        443/TCP                  13m\nkube-system           antrea        ClusterIP   172.30.116.178   <none>        443/TCP                  105m\nkube-system           kube-dns      ClusterIP   172.30.0.10      <none>        53/UDP,53/TCP,9153/TCP   106m\nservice-clusterip-2   svc-2-httpd   ClusterIP   172.30.24.63     <none>        8081/TCP                 95s\n```\n\n---\n\n### 步驟 4：查看 Pod 並修改內容\n\n查看 Pod：\n\n```bash title=\"查看 Pod\"\nkubectl get pods --namespace=service-clusterip-2 -o wide\n```\n\n**預期結果**：\n\n```\nNAME                       READY   STATUS    RESTARTS   AGE     IP            NODE\nhttpd-2-68b85d46c7-t4v87   1/1     Running   0          5m16s   10.128.1.14   k8s-node1.training.lab\nhttpd-2-68b85d46c7-trhk5   1/1     Running   0          5m16s   10.128.2.9    k8s-node2.training.lab\n```\n\n進入第一個 Pod 修改首頁：\n\n```bash title=\"進入 Pod 1 修改內容\"\nkubectl exec httpd-2-68b85d46c7-t4v87 --namespace=service-clusterip-2 -it -- bash\n```\n\n```bash title=\"在容器內執行\"\ncd htdocs/\necho AAA > index.html\nexit\n```\n\n進入第二個 Pod 修改首頁：\n\n```bash title=\"進入 Pod 2 修改內容\"\nkubectl exec httpd-2-68b85d46c7-trhk5 --namespace=service-clusterip-2 -it -- bash\n```\n\n```bash title=\"在容器內執行\"\ncd htdocs/\necho BBB > index.html\nexit\n```\n\n---\n\n### 步驟 5：測試 ClusterIP 負載均衡\n\n直接存取 Pod IP：\n\n```bash title=\"直接存取 Pod IP\"\ncurl 10.128.1.14\ncurl 10.128.2.9\n```\n\n**預期結果**：\n\n```\nAAA\nBBB\n```\n\n透過 Service ClusterIP 存取（會自動負載均衡）：\n\n```bash title=\"存取 Service ClusterIP\"\ncurl 172.30.24.63:8081\ncurl 172.30.24.63:8081\n```\n\n**預期結果**（每次可能不同）：\n\n```\nBBB\nAAA\n```\n\n!!! success \"負載均衡驗證\"\n    多次存取 Service IP，會發現回應內容在 AAA 和 BBB 之間切換，這表示 Service 正在進行負載均衡。\n\n---\n\n## Lab 實作練習：NodePort Service\n\n### NodePort 概述\n\n**NodePort** 會在每個 Node 上開放一個固定的 Port（30000-32767），允許從叢集**外部**存取。\n\n```mermaid\ngraph TB\n    subgraph \"Kubernetes Cluster\"\n        subgraph \"k8s-node1\"\n            NP1[Port 30008]\n        end\n        subgraph \"k8s-node2\"\n            NP2[Port 30008]\n        end\n        subgraph \"k8s-master1\"\n            NP3[Port 30008]\n        end\n        SVC[Service NodePort<br/>172.30.21.179:8082]\n        NP1 --> SVC\n        NP2 --> SVC\n        NP3 --> SVC\n        SVC --> Pod1[httpd Pod 1]\n        SVC --> Pod2[httpd Pod 2]\n    end\n    External[外部網路] --> NP1\n    External --> NP2\n    External --> NP3\n```\n\n---\n\n### 步驟 1：下載 NodePort YAML\n\n```bash title=\"下載 NodePort 範例\"\nwget http://10.0.1.248/k8s/yaml/service-nodeport.yaml\n```\n\n查看 YAML 內容：\n\n```bash title=\"查看 YAML\"\ncat service-nodeport.yaml\n```\n\n**YAML 重點**：\n\n```yaml title=\"service-nodeport.yaml（摘錄）\"\napiVersion: v1\nkind: Service\nmetadata:\n  name: svc-2-httpd-nodeport\n  namespace: service-nodeport-2\nspec:\n  type: NodePort          # NodePort 類型\n  ports:\n  - port: 8082            # Service Port\n    targetPort: 80        # Pod Port\n    nodePort: 30008       # Node 對外 Port\n  selector:\n    app: httpd-2-nodeport\n```\n\n---\n\n### 步驟 2：套用 YAML\n\n```bash title=\"套用 YAML\"\nkubectl apply -f service-nodeport.yaml\n```\n\n**預期結果**：\n\n```\nnamespace/service-nodeport-2 created\nservice/svc-2-httpd-nodeport created\ndeployment.apps/httpd-2-nodeport created\n```\n\n---\n\n### 步驟 3：查看 Service\n\n```bash title=\"查看 Service\"\nkubectl get services -A\n```\n\n**預期結果**：\n\n```\nNAMESPACE             NAME                   TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)          AGE\nservice-clusterip-2   svc-2-httpd            ClusterIP   172.30.24.63     <none>        8081/TCP         9m25s\nservice-nodeport-2    svc-2-httpd-nodeport   NodePort    172.30.21.179    <none>        8082:30008/TCP   72s\n```\n\n!!! note \"Port 格式說明\"\n    `8082:30008/TCP` 表示：\n    \n    - **8082**：Service 的 ClusterIP Port\n    - **30008**：Node 對外的 NodePort\n\n---\n\n### 步驟 4：測試 NodePort 存取\n\n透過 Pod IP 存取：\n\n```bash title=\"存取 Pod IP\"\nkubectl get pods --namespace=service-nodeport-2 -o wide\ncurl 10.128.1.15\ncurl 10.128.2.10\n```\n\n透過 Service ClusterIP 存取：\n\n```bash title=\"存取 Service ClusterIP\"\ncurl 172.30.21.179:8082\n```\n\n**透過任意 Node 的 NodePort 存取**：\n\n```bash title=\"存取 NodePort\"\ncurl k8s-node1:30008\ncurl k8s-node2:30008\ncurl k8s-master1:30008\n```\n\n**預期結果**（三個都可以存取）：\n\n```\n<html><body><h1>It works!</h1></body></html>\n```\n\n!!! success \"NodePort 特性\"\n    NodePort 會在**所有 Node**（包含 Master 和 Worker）上開放相同的 Port，無論 Pod 實際運行在哪個 Node 上。\n\n---\n\n## Lab 實作練習：LoadBalancer Service\n\n### LoadBalancer 概述\n\n**LoadBalancer** 是最高級的 Service 類型，會向雲端供應商請求一個**外部負載均衡器 IP**。\n\n```mermaid\ngraph TB\n    subgraph \"Cloud Provider\"\n        LB[External Load Balancer<br/>公開 IP]\n    end\n    subgraph \"Kubernetes Cluster\"\n        SVC[Service LoadBalancer<br/>172.30.227.169:8083]\n        SVC --> Pod1[httpd Pod 1]\n        SVC --> Pod2[httpd Pod 2]\n    end\n    Internet[Internet] --> LB\n    LB --> SVC\n```\n\n---\n\n### 步驟 1：下載 LoadBalancer YAML\n\n```bash title=\"下載 LoadBalancer 範例\"\nwget http://192.168.66.248/k8s/yaml/service-loadbalancer.yaml\n```\n\n查看 YAML 內容：\n\n```bash title=\"查看 YAML\"\ncat service-loadbalancer.yaml\n```\n\n**YAML 重點**：\n\n```yaml title=\"service-loadbalancer.yaml（摘錄）\"\napiVersion: v1\nkind: Service\nmetadata:\n  name: svc-2-httpd-lb\n  namespace: service-loadbalancer-1\nspec:\n  type: LoadBalancer      # LoadBalancer 類型\n  ports:\n  - port: 8083            # Service Port\n    targetPort: 80        # Pod Port\n  selector:\n    app: httpd-2-lb\n```\n\n---\n\n### 步驟 2：套用 YAML\n\n```bash title=\"套用 YAML\"\nkubectl apply -f service-loadbalancer.yaml\n```\n\n**預期結果**：\n\n```\nnamespace/service-loadbalancer-1 created\nservice/svc-2-httpd-lb created\ndeployment.apps/httpd-2-lb created\n```\n\n---\n\n### 步驟 3：查看 Service\n\n```bash title=\"查看 Service\"\nkubectl get services --namespace=service-loadbalancer-1\n```\n\n**預期結果**：\n\n```\nNAME             TYPE           CLUSTER-IP       EXTERNAL-IP   PORT(S)          AGE\nsvc-2-httpd-lb   LoadBalancer   172.30.227.169   <pending>     8083:32254/TCP   60s\n```\n\n!!! warning \"EXTERNAL-IP 顯示 pending\"\n    在非雲端環境（如本地 VMware），沒有外部負載均衡器可用，所以 EXTERNAL-IP 會一直顯示 `<pending>`。\n    \n    在 AWS、GCP、Azure 等雲端環境中，會自動分配一個公開 IP。\n\n---\n\n### 步驟 4：測試 LoadBalancer 存取\n\n```bash title=\"查看 Pod\"\nkubectl get pods --namespace=service-loadbalancer-1 -o wide\n```\n\n透過 Pod IP 存取：\n\n```bash title=\"存取 Pod IP\"\ncurl 10.128.2.11\ncurl 10.128.1.16\n```\n\n透過 Service ClusterIP 存取：\n\n```bash title=\"存取 Service ClusterIP\"\ncurl 172.30.227.169:8083\n```\n\n透過 NodePort 存取（LoadBalancer 自動分配）：\n\n```bash title=\"存取自動分配的 NodePort\"\ncurl k8s-node1:32254\ncurl k8s-node2:32254\ncurl k8s-master1:32254\n```\n\n!!! info \"LoadBalancer 自動分配 NodePort\"\n    LoadBalancer 類型的 Service 會自動分配一個 NodePort（此例為 32254），所以也可以透過 Node IP:NodePort 存取。\n\n---\n\n## Service 類型總結\n\n| 特性 | ClusterIP | NodePort | LoadBalancer |\n|------|-----------|----------|--------------|\n| **存取範圍** | 叢集內部 | 叢集內外 | 叢集內外 |\n| **固定 IP** | ClusterIP | ClusterIP + NodePort | ClusterIP + NodePort + External IP |\n| **使用場景** | 微服務內部通訊 | 開發測試 | 生產環境 |\n| **Port 範圍** | 不限 | 30000-32767 | 不限 |\n| **需要雲端** | 否 | 否 | 是 |\n\n---\n\n## 常見問題\n\n??? question \"Q1：Service 如何找到對應的 Pod？\"\n    **解答**：透過 `selector` 標籤選擇器。Service 會將流量導向所有符合 selector 條件的 Pod。\n    \n    ```yaml\n    spec:\n      selector:\n        app: httpd-2  # 選擇帶有 app=httpd-2 標籤的 Pod\n    ```\n\n??? question \"Q2：LoadBalancer 的 EXTERNAL-IP 一直是 pending？\"\n    **原因**：在非雲端環境沒有外部負載均衡器。\n    \n    **解決方案**：\n    \n    - 使用 MetalLB 在本地環境模擬 LoadBalancer\n    - 或直接使用 NodePort 類型\n\n??? question \"Q3：NodePort 的 Port 範圍可以修改嗎？\"\n    **解答**：可以，修改 kube-apiserver 的 `--service-node-port-range` 參數。\n    \n    預設範圍：30000-32767\n\n??? question \"Q4：Pod 一直處於 Pending 狀態？\"\n    **原因**：通常是節點或 CNI 未就緒。\n    \n    **Debug 流程**：\n    \n    ```bash\n    # 1. 檢查節點狀態\n    kubectl get nodes\n    \n    # 2. 檢查 CNI Pod（Antrea）\n    kubectl get pods -n kube-system | grep antrea\n    \n    # 3. 查看 Pod 事件\n    kubectl describe pod <pod-name> -n <namespace>\n    \n    # 4. 查看容器日誌\n    kubectl logs <pod-name> -n kube-system -c <container-name> --tail=50\n    ```\n    \n    詳細 Debug 流程請參考 [LAB 18 Debug 實戰](lab18_rbac_event_log.md#lab-實作練習debug-實戰流程)。\n\n---\n\n## 小結\n\n本章節重點回顧：\n\n- ✅ **Service 概念**：提供穩定的網路端點存取 Pod\n- ✅ **ClusterIP**：預設類型，僅叢集內部存取\n- ✅ **NodePort**：透過 Node IP:Port 從外部存取（30000-32767）\n- ✅ **LoadBalancer**：透過外部負載均衡器存取（需雲端環境）\n- ✅ **Port 對應**：port（Service）→ targetPort（Pod）→ nodePort（Node）\n- ✅ **負載均衡**：Service 自動將流量分散到多個 Pod\n\n## 延伸閱讀\n\n- [Kubernetes Service](https://kubernetes.io/docs/concepts/services-networking/service/)\n- [Service Types](https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types)\n- [MetalLB - LoadBalancer for Bare Metal](https://metallb.io/)\n\n## YAML 實用工具\n\n| 工具 | 用途 | 連結 |\n|------|------|------|\n| **YAMLint** | 驗證 YAML 語法 | [www.yamllint.com](http://www.yamllint.com/) |\n| **YAML to JSON** | 將 YAML 轉換為 JSON | [www.convertjson.com](https://www.convertjson.com/yaml-to-json.htm) |\n| **YAML to JSON/XML/CSV** | 多格式轉換 | [codebeautify.org](https://codebeautify.org/yaml-to-json-xml-csv) |\n\n!!! tip \"YAML 驗證技巧\"\n    在套用 YAML 檔案之前，建議先使用線上工具驗證語法是否正確，避免因縮排或格式錯誤導致部署失敗。\n\n"
  },
  {
    "title": "Lab16 Pv Pvc",
    "url": "https://caocharles.github.io/dcka-class-notes/lab16_pv_pvc/",
    "content": "﻿# LAB 16 Persistent Volume（PV）與 Persistent Volume Claim（PVC）\n\n## 學習目標\n\n完成本章節後，你將能夠：\n\n- [ ] 理解 PV 與 PVC 的概念與關係\n- [ ] 使用 hostPath 建立本地儲存的 PV\n- [ ] 建立 PVC 並綁定 PV\n- [ ] 在 Pod 中掛載 PVC\n- [ ] 設定 NFS Server 提供網路儲存\n- [ ] 使用 NFS 類型的 PV 實現跨節點共享儲存\n\n## 前置知識\n\n開始之前，請確保你已經：\n\n- 完成 LAB 15 Service\n- 熟悉 Pod、Deployment 基本概念\n- 準備好 Kubernetes 叢集環境（k8s-master1、k8s-node1、k8s-node2）\n\n---\n\n## 核心概念說明\n\n### 為什麼需要 PV/PVC？\n\nPod 的儲存是**臨時性的**，當 Pod 被刪除或重新調度時，容器內的資料也會消失。PV/PVC 提供了**持久化儲存**的解決方案。\n\n```mermaid\ngraph TB\n    subgraph \"沒有 PV/PVC\"\n        Pod1[Pod] --> Data1[容器內資料]\n        Data1 -.->|Pod 刪除| Lost[資料遺失]\n    end\n    \n    subgraph \"使用 PV/PVC\"\n        Pod2[Pod] --> PVC[PVC]\n        PVC --> PV[PV]\n        PV --> Storage[(儲存空間)]\n        Pod2 -.->|Pod 刪除| Storage\n    end\n```\n\n---\n\n### PV 與 PVC 的關係\n\n| 概念 | 說明 | 誰管理 |\n|------|------|--------|\n| **PV（Persistent Volume）** | 叢集中的儲存資源，類似 Node | 管理員 |\n| **PVC（Persistent Volume Claim）** | 使用者對儲存的請求，類似 Pod | 開發者 |\n\n```mermaid\ngraph LR\n    Admin[管理員] -->|建立| PV[PV<br/>10Gi Storage]\n    Dev[開發者] -->|建立| PVC[PVC<br/>請求 3Gi]\n    PVC -->|自動綁定| PV\n    Pod[Pod] -->|掛載| PVC\n```\n\n---\n\n### PV 的生命週期\n\n```mermaid\nstateDiagram-v2\n    [*] --> Available: 建立 PV\n    Available --> Bound: PVC 綁定\n    Bound --> Released: PVC 刪除\n    Released --> Available: 回收\n    Released --> [*]: 刪除\n```\n\n| 狀態 | 說明 |\n|------|------|\n| **Available** | 可用，尚未被 PVC 綁定 |\n| **Bound** | 已綁定，被某個 PVC 使用中 |\n| **Released** | PVC 已刪除，但資源尚未回收 |\n| **Failed** | 自動回收失敗 |\n\n---\n\n### 儲存類型比較\n\n| 類型 | 說明 | 優點 | 缺點 |\n|------|------|------|------|\n| **hostPath** | 節點本地路徑 | 簡單、快速 | Pod 只能在特定節點運行 |\n| **NFS** | 網路檔案系統 | 跨節點共享 | 需要 NFS Server |\n| **CSI** | 容器儲存介面 | 支援各種雲端儲存 | 設定較複雜 |\n\n---\n\n## Lab 實作練習：hostPath 本地儲存\n\n### 架構說明\n\n使用 hostPath 時，Pod 會使用節點上的本地目錄作為儲存空間。\n\n```mermaid\ngraph TB\n    subgraph \"k8s-node1\"\n        Pod1[pv1-pod-local]\n        Path1[/mnt/data<br/>index.html: node1...AAA]\n        Pod1 --> Path1\n    end\n    \n    subgraph \"k8s-node2\"\n        Path2[/mnt/data<br/>index.html: node2...BBB]\n    end\n```\n\n!!! warning \"hostPath 限制\"\n    使用 hostPath 時，Pod 只能運行在有該路徑的節點上。如果 Pod 被調度到其他節點，可能會找不到資料或看到不同的資料。\n\n---\n\n### 步驟 1：在 Worker Node 準備本地目錄\n\n**在 k8s-node1 上執行**：\n\n```bash title=\"在 node1 建立目錄和測試檔案\"\nmkdir -p /mnt/data\necho \"node1...AAA\" > /mnt/data/index.html\ncat /mnt/data/index.html\n```\n\n**預期結果**：\n\n```\nnode1...AAA\n```\n\n**在 k8s-node2 上執行**：\n\n```bash title=\"在 node2 建立目錄和測試檔案\"\nmkdir -p /mnt/data\necho \"node2...BBB\" > /mnt/data/index.html\ncat /mnt/data/index.html\n```\n\n**預期結果**：\n\n```\nnode2...BBB\n```\n\n---\n\n### 步驟 2：建立 PV（Persistent Volume）\n\n回到 k8s-master1，下載並查看 PV YAML：\n\n```bash title=\"下載 PV YAML\"\nwget http://10.0.1.248/k8s/yaml/pv1-local.yaml\n```\n\n**PV YAML 內容**：\n\n```yaml title=\"pv1-local.yaml\"\napiVersion: v1\nkind: PersistentVolume\nmetadata:\n  name: pv1-local\nspec:\n  capacity:\n    storage: 10Gi            # 儲存容量\n  accessModes:\n    - ReadWriteOnce          # 存取模式\n  persistentVolumeReclaimPolicy: Retain  # 回收策略\n  storageClassName: manual   # 儲存類別\n  hostPath:\n    path: \"/mnt/data\"        # 節點本地路徑\n```\n\n| 欄位 | 說明 |\n|------|------|\n| **capacity** | 儲存容量（10Gi = 10 GiB） |\n| **accessModes** | RWO（單節點讀寫）、ROX（多節點唯讀）、RWX（多節點讀寫） |\n| **persistentVolumeReclaimPolicy** | Retain（保留）、Delete（刪除）、Recycle（回收） |\n| **storageClassName** | 用於 PVC 配對的類別名稱 |\n| **hostPath** | 節點本地路徑 |\n\n套用 PV：\n\n```bash title=\"建立 PV\"\nkubectl apply -f pv1-local.yaml\n```\n\n查看 PV 狀態：\n\n```bash title=\"查看 PV\"\nkubectl get pv\n```\n\n**預期結果**：\n\n```\nNAME        CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM   STORAGECLASS   AGE\npv1-local   10Gi       RWO            Retain           Available           manual         3s\n```\n\n!!! success \"PV 狀態\"\n    狀態顯示 `Available`，表示 PV 可用，尚未被 PVC 綁定。\n\n---\n\n### 步驟 3：建立 PVC（Persistent Volume Claim）\n\n```bash title=\"下載 PVC YAML\"\nwget http://10.0.1.248/k8s/yaml/pvc1-local.yaml\n```\n\n**PVC YAML 內容**：\n\n```yaml title=\"pvc1-local.yaml\"\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: pvc1-local\nspec:\n  accessModes:\n    - ReadWriteOnce          # 必須與 PV 相容\n  resources:\n    requests:\n      storage: 3Gi           # 請求的容量\n  storageClassName: manual   # 必須與 PV 相同\n```\n\n套用 PVC：\n\n```bash title=\"建立 PVC\"\nkubectl apply -f pvc1-local.yaml\n```\n\n查看 PV 和 PVC 狀態：\n\n```bash title=\"查看 PV 狀態\"\nkubectl get pv\n```\n\n**預期結果**：\n\n```\nNAME        CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM                STORAGECLASS   AGE\npv1-local   10Gi       RWO            Retain           Bound    default/pvc1-local   manual         95s\n```\n\n```bash title=\"查看 PVC 狀態\"\nkubectl get pvc\n```\n\n**預期結果**：\n\n```\nNAME         STATUS   VOLUME      CAPACITY   ACCESS MODES   STORAGECLASS   AGE\npvc1-local   Bound    pv1-local   10Gi       RWO            manual         5s\n```\n\n!!! success \"綁定成功\"\n    PV 和 PVC 的狀態都變成 `Bound`，表示綁定成功。CLAIM 欄位顯示 `default/pvc1-local`，表示被哪個 Namespace 的 PVC 綁定。\n\n---\n\n### 步驟 4：建立使用 PVC 的 Pod\n\n```bash title=\"下載 Pod YAML\"\nwget http://10.0.1.248/k8s/yaml/pv1-pod-local.yaml\n```\n\n**Pod YAML 內容**：\n\n```yaml title=\"pv1-pod-local.yaml\"\napiVersion: v1\nkind: Pod\nmetadata:\n  name: pv1-pod-local\nspec:\n  containers:\n  - name: nginx\n    image: docker1.training.lab:5000/nginx\n    ports:\n    - containerPort: 80\n    volumeMounts:\n    - mountPath: \"/usr/share/nginx/html\"  # 容器內掛載路徑\n      name: pv1-storage\n  volumes:\n  - name: pv1-storage\n    persistentVolumeClaim:\n      claimName: pvc1-local                # 使用的 PVC 名稱\n```\n\n套用 Pod：\n\n```bash title=\"建立 Pod\"\nkubectl apply -f pv1-pod-local.yaml\n```\n\n查看 Pod 狀態：\n\n```bash title=\"查看 Pod\"\nkubectl get pods -o wide\n```\n\n**預期結果**：\n\n```\nNAME            READY   STATUS    RESTARTS   AGE   IP            NODE\npv1-pod-local   1/1     Running   0          21s   10.128.1.17   k8s-node1.training.lab\n```\n\n測試存取：\n\n```bash title=\"測試存取\"\ncurl 10.128.1.17\n```\n\n**預期結果**：\n\n```\nnode1...AAA\n```\n\n!!! info \"hostPath 的侷限\"\n    Pod 被調度到 node1，所以看到的是 node1 上的 `/mnt/data/index.html` 內容（node1...AAA）。如果 Pod 被調度到 node2，會看到不同的內容（node2...BBB）。\n\n---\n\n## Lab 實作練習：NFS 網路儲存\n\n### 架構說明\n\n使用 NFS 時，所有節點都可以存取相同的共享儲存空間。\n\n```mermaid\ngraph TB\n    subgraph \"k8s-master1 (NFS Server)\"\n        NFS[NFS 服務]\n        Data[/data<br/>index.html: master...CCC]\n        NFS --> Data\n    end\n    \n    subgraph \"k8s-node1\"\n        Pod1[pv2-pod-nfs]\n        Pod1 -.->|NFS 掛載| NFS\n    end\n    \n    subgraph \"k8s-node2\"\n        Pod2[Pod]\n        Pod2 -.->|NFS 掛載| NFS\n    end\n```\n\n---\n\n### 步驟 1：安裝 NFS 工具\n\n**在所有節點（master1、node1、node2）安裝 nfs-utils**：\n\n```bash title=\"安裝 nfs-utils\"\nyum install nfs-utils -y\n```\n\n---\n\n### 步驟 2：設定 NFS Server（k8s-master1）\n\n**在 k8s-master1 上執行**：\n\n建立共享目錄：\n\n```bash title=\"建立共享目錄\"\nmkdir -p /data\necho \"master...CCC\" > /data/index.html\n```\n\n設定 NFS 匯出：\n\n```bash title=\"編輯 /etc/exports\"\nvi /etc/exports\n```\n\n加入以下內容：\n\n```title=\"/etc/exports\"\n/data *(rw,no_root_squash)\n```\n\n| 選項 | 說明 |\n|------|------|\n| `*` | 允許所有主機存取 |\n| `rw` | 讀寫權限 |\n| `no_root_squash` | root 使用者保持 root 權限 |\n\n啟動 NFS 服務：\n\n```bash title=\"啟動並啟用 NFS\"\nsystemctl start nfs-server.service\nsystemctl enable nfs-server.service\nsystemctl status nfs-server.service\n```\n\n**預期結果**：\n\n```\n● nfs-server.service - NFS server and services\n     Loaded: loaded (/usr/lib/systemd/system/nfs-server.service; enabled)\n     Active: active (exited)\n```\n\n---\n\n### 步驟 3：測試 NFS 掛載（k8s-node1）\n\n**在 k8s-node1 上執行**：\n\n```bash title=\"建立掛載點並掛載 NFS\"\nmkdir -p /mnt/nfs\nmount -t nfs k8s-master1:/data /mnt/nfs\n```\n\n驗證掛載：\n\n```bash title=\"驗證掛載\"\ndf -Th | grep nfs\ncat /mnt/nfs/index.html\n```\n\n**預期結果**：\n\n```\nk8s-master1:/data   nfs4   70G  7.4G  63G  11% /mnt/nfs\nmaster...CCC\n```\n\n卸載（測試完成後）：\n\n```bash title=\"卸載 NFS\"\numount /mnt/nfs\n```\n\n---\n\n### 步驟 4：建立 NFS PV\n\n**回到 k8s-master1**：\n\n```bash title=\"下載 NFS PV YAML\"\nwget http://10.0.1.248/k8s/yaml/pv2-nfs.yaml\n```\n\n**NFS PV YAML 內容**：\n\n```yaml title=\"pv2-nfs.yaml\"\napiVersion: v1\nkind: PersistentVolume\nmetadata:\n  name: pv2-nfs\nspec:\n  capacity:\n    storage: 10Gi\n  accessModes:\n    - ReadWriteOnce\n  persistentVolumeReclaimPolicy: Retain\n  storageClassName: manual\n  nfs:\n    server: k8s-master1              # NFS Server 主機名稱\n    path: \"/data\"                    # NFS 共享路徑\n```\n\n套用 PV：\n\n```bash title=\"建立 NFS PV\"\nkubectl apply -f pv2-nfs.yaml\nkubectl get pv\n```\n\n**預期結果**：\n\n```\nNAME        CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM                STORAGECLASS   AGE\npv1-local   10Gi       RWO            Retain           Bound       default/pvc1-local   manual         19m\npv2-nfs     10Gi       RWO            Retain           Available                        manual         3s\n```\n\n---\n\n### 步驟 5：建立 NFS PVC\n\n```bash title=\"下載 NFS PVC YAML\"\nwget http://10.0.1.248/k8s/yaml/pvc2-nfs.yaml\n```\n\n**NFS PVC YAML 內容**：\n\n```yaml title=\"pvc2-nfs.yaml\"\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: pvc2-nfs\nspec:\n  accessModes:\n    - ReadWriteOnce\n  resources:\n    requests:\n      storage: 3Gi\n  storageClassName: manual\n```\n\n套用 PVC：\n\n```bash title=\"建立 NFS PVC\"\nkubectl apply -f pvc2-nfs.yaml\nkubectl get pv\nkubectl get pvc\n```\n\n**預期結果**：\n\n```\nNAME        CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM                STORAGECLASS   AGE\npv1-local   10Gi       RWO            Retain           Bound    default/pvc1-local   manual         20m\npv2-nfs     10Gi       RWO            Retain           Bound    default/pvc2-nfs     manual         91s\n\nNAME         STATUS   VOLUME      CAPACITY   ACCESS MODES   STORAGECLASS   AGE\npvc1-local   Bound    pv1-local   10Gi       RWO            manual         19m\npvc2-nfs     Bound    pv2-nfs     10Gi       RWO            manual         5s\n```\n\n---\n\n### 步驟 6：建立使用 NFS PVC 的 Pod\n\n```bash title=\"下載 NFS Pod YAML\"\nwget http://10.0.1.248/k8s/yaml/pv2-pod-nfs.yaml\n```\n\n**NFS Pod YAML 內容**：\n\n```yaml title=\"pv2-pod-nfs.yaml\"\napiVersion: v1\nkind: Pod\nmetadata:\n  name: pv2-pod-nfs\nspec:\n  containers:\n  - name: nginx\n    image: docker1.training.lab:5000/nginx\n    ports:\n    - containerPort: 80\n    volumeMounts:\n    - mountPath: \"/usr/share/nginx/html\"\n      name: pv2-storage\n  volumes:\n  - name: pv2-storage\n    persistentVolumeClaim:\n      claimName: pvc2-nfs              # 使用 NFS PVC\n```\n\n套用 Pod：\n\n```bash title=\"建立 NFS Pod\"\nkubectl apply -f pv2-pod-nfs.yaml\nkubectl get pods -o wide\n```\n\n**預期結果**：\n\n```\nNAME            READY   STATUS    RESTARTS   AGE   IP            NODE\npv1-pod-local   1/1     Running   0          19m   10.128.1.17   k8s-node1.training.lab\npv2-pod-nfs     1/1     Running   0          18s   10.128.1.18   k8s-node1.training.lab\n```\n\n測試存取：\n\n```bash title=\"測試 NFS Pod\"\ncurl 10.128.1.18\n```\n\n**預期結果**：\n\n```\nmaster...CCC\n```\n\n!!! success \"NFS 共享儲存\"\n    無論 Pod 運行在哪個節點，都會看到相同的內容（master...CCC），因為資料來自共享的 NFS Server。\n\n---\n\n## hostPath vs NFS 比較\n\n| 特性 | hostPath | NFS |\n|------|----------|-----|\n| **資料位置** | 節點本地 | 網路共享 |\n| **跨節點存取** | ❌ 不支援 | ✅ 支援 |\n| **Pod 調度** | 限制在特定節點 | 可調度到任意節點 |\n| **設定複雜度** | 簡單 | 需要設定 NFS Server |\n| **使用場景** | 測試、單節點 | 生產環境、多節點共享 |\n\n---\n\n## 常見問題\n\n??? question \"Q1：PVC 一直處於 Pending 狀態？\"\n    **原因**：找不到符合條件的 PV。\n    \n    **檢查項目**：\n    \n    - storageClassName 是否相同\n    - accessModes 是否相容\n    - 請求的 storage 是否超過 PV 容量\n\n??? question \"Q2：NFS 掛載失敗？\"\n    **解決方案**：\n    \n    1. 確認 NFS Server 有啟動：`systemctl status nfs-server`\n    2. 確認所有節點都安裝了 nfs-utils\n    3. 確認防火牆沒有阻擋 NFS 連線\n    4. 使用 `showmount -e k8s-master1` 查看匯出的目錄\n\n??? question \"Q3：PV 刪除後如何重新使用？\"\n    **解答**：當 persistentVolumeReclaimPolicy 設為 Retain 時：\n    \n    1. 手動清除 PV 上的資料\n    2. 刪除舊的 PV\n    3. 重新建立 PV\n\n---\n\n## 小結\n\n本章節重點回顧：\n\n- ✅ **PV/PVC 概念**：PV 是儲存資源，PVC 是使用請求，兩者透過 storageClassName 配對\n- ✅ **hostPath**：使用節點本地目錄，簡單但無法跨節點\n- ✅ **NFS**：提供網路共享儲存，支援跨節點存取\n- ✅ **綁定流程**：建立 PV → 建立 PVC → 自動綁定 → Pod 掛載 PVC\n- ✅ **存取模式**：RWO（單節點讀寫）、ROX（多節點唯讀）、RWX（多節點讀寫）\n- ✅ **回收策略**：Retain（保留）、Delete（刪除）\n\n## 延伸閱讀\n\n- [Kubernetes Persistent Volumes](https://kubernetes.io/docs/concepts/storage/persistent-volumes/)\n- [Configure a Pod to Use a PersistentVolume](https://kubernetes.io/docs/tasks/configure-pod-container/configure-persistent-volume-storage/)\n- [NFS 儲存設定](https://kubernetes.io/docs/concepts/storage/volumes/#nfs)\n"
  },
  {
    "title": "解碼 base64",
    "url": "https://caocharles.github.io/dcka-class-notes/lab17_secret/",
    "content": "﻿# LAB 17 Kubernetes Secret\n\n## 學習目標\n\n完成本章節後，你將能夠：\n\n- [ ] 理解 Secret 的用途與類型\n- [ ] 使用三種方式建立 Secret（從檔案、從指令、從 YAML）\n- [ ] 透過環境變數將 Secret 傳遞給 Pod\n- [ ] 透過 Volume 掛載將 Secret 傳遞給 Pod\n- [ ] 理解 base64 編碼在 Secret 中的作用\n\n## 前置知識\n\n開始之前，請確保你已經：\n\n- 完成 LAB 16 PV/PVC\n- 熟悉 Pod、Volume 基本概念\n- 準備好 Kubernetes 叢集環境（k8s-master1）\n\n---\n\n## 核心概念說明\n\n### Secret 是什麼？\n\n**Secret** 是 Kubernetes 中用來儲存**敏感資訊**的資源，例如密碼、API 金鑰、憑證等。Secret 會以 base64 編碼儲存，避免明文暴露在 YAML 檔案中。\n\n```mermaid\ngraph LR\n    Admin[管理員] -->|建立| Secret[Secret<br/>username: root<br/>password: ****]\n    Secret -->|環境變數| Pod1[Pod]\n    Secret -->|掛載 Volume| Pod2[Pod]\n```\n\n---\n\n### Secret 建立與存取的組合\n\nSecret 有 **3 種建立方式** 和 **2 種存取方式**，共 **6 種組合**：\n\n| 建立方式 | 說明 | base64 編碼 |\n|----------|------|-------------|\n| **從檔案**（--from-file） | 將檔案內容匯入成 Secret | 自動處理 |\n| **從指令**（--from-literal） | 直接在指令中指定值 | 自動處理 |\n| **從 YAML** | 使用 YAML 檔案定義 | ⚠️ 需手動編碼 |\n\n| 存取方式 | 說明 |\n|----------|------|\n| **環境變數** | Secret 值注入為環境變數 |\n| **Volume 掛載** | Secret 掛載為檔案 |\n\n```mermaid\ngraph TB\n    subgraph \"建立 Secret（3 種）\"\n        File[從檔案<br/>--from-file]\n        Literal[從指令<br/>--from-literal]\n        YAML[從 YAML<br/>需 base64]\n    end\n    \n    subgraph \"存取 Secret（2 種）\"\n        Env[環境變數<br/>env]\n        Mount[Volume 掛載<br/>volumeMounts]\n    end\n    \n    File --> Env\n    File --> Mount\n    Literal --> Env\n    Literal --> Mount\n    YAML --> Env\n    YAML --> Mount\n```\n\n---\n\n## Lab 實作練習：建立 Secret\n\n### 方式一：從檔案建立 Secret\n\n#### 步驟 1：建立包含敏感資料的檔案\n\n```bash title=\"建立 username 和 password 檔案\"\necho -n \"root\" > ./username.txt\necho -n \"pass1234\" > ./password.txt\n```\n\n!!! warning \"注意 -n 參數\"\n    使用 `echo -n` 避免在檔案末尾加入換行符號，否則密碼會包含多餘的換行。\n\n驗證檔案內容：\n\n```bash title=\"查看檔案內容\"\ncat username.txt\ncat password.txt\n```\n\n**預期結果**（注意沒有換行）：\n\n```\nroot[root@k8s-master1 ~]#\npass1234[root@k8s-master1 ~]#\n```\n\n#### 步驟 2：從檔案建立 Secret\n\n```bash title=\"從檔案建立 Secret\"\nkubectl create secret generic demo-secret-from-file \\\n  --from-file=./username.txt \\\n  --from-file=./password.txt\n```\n\n**預期結果**：\n\n```\nsecret/demo-secret-from-file created\n```\n\n查看 Secret：\n\n```bash title=\"查看 Secret 列表\"\nkubectl get secrets\n```\n\n**預期結果**：\n\n```\nNAME                    TYPE     DATA   AGE\ndemo-secret-from-file   Opaque   2      7s\n```\n\n```bash title=\"查看 Secret 詳細資訊\"\nkubectl describe secrets demo-secret-from-file\n```\n\n**預期結果**：\n\n```\nName:         demo-secret-from-file\nNamespace:    default\nType:  Opaque\n\nData\n====\npassword.txt:  8 bytes\nusername.txt:  4 bytes\n```\n\n!!! info \"檔名作為 Key\"\n    使用 `--from-file` 時，**檔名會成為 Secret 的 Key**（如 `password.txt`、`username.txt`）。\n\n---\n\n### 方式二：從指令建立 Secret（--from-literal）\n\n```bash title=\"從指令建立 Secret\"\nkubectl create secret generic demo-secret-from-literal \\\n  --from-literal=username=root \\\n  --from-literal=password=pass1234\n```\n\n**預期結果**：\n\n```\nsecret/demo-secret-from-literal created\n```\n\n查看 Secret：\n\n```bash title=\"查看 Secret\"\nkubectl describe secrets demo-secret-from-literal\n```\n\n**預期結果**：\n\n```\nName:         demo-secret-from-literal\nNamespace:    default\nType:  Opaque\n\nData\n====\npassword:  8 bytes\nusername:  4 bytes\n```\n\n!!! tip \"自訂 Key 名稱\"\n    使用 `--from-literal` 時，可以直接指定 Key 名稱（如 `username`、`password`），比 `--from-file` 更靈活。\n\n---\n\n### 方式三：從 YAML 建立 Secret\n\n#### 步驟 1：使用 base64 編碼資料\n\n```bash title=\"base64 編碼\"\necho -n \"root\" | base64\necho -n \"pass1234\" | base64\n```\n\n**預期結果**：\n\n```\ncm9vdA==\ncGFzczEyMzQ=\n```\n\n!!! warning \"YAML 方式需要手動 base64 編碼\"\n    只有使用 YAML 建立 Secret 時，需要先將資料進行 base64 編碼。`--from-file` 和 `--from-literal` 會自動處理。\n\n#### 步驟 2：下載並查看 YAML\n\n```bash title=\"下載 Secret YAML\"\nwget http://10.0.1.248/k8s/yaml/my-secret.yaml\ncat my-secret.yaml\n```\n\n**YAML 內容**：\n\n```yaml title=\"my-secret.yaml\"\napiVersion: v1\nkind: Secret\nmetadata:\n  name: demo-secret-from-yaml\ntype: Opaque\ndata:\n  username: cm9vdA==          # base64 編碼的 \"root\"\n  password: cGFzczEyMzQ=      # base64 編碼的 \"pass1234\"\n```\n\n| 欄位 | 說明 |\n|------|------|\n| **type: Opaque** | 通用型 Secret |\n| **data** | 存放 base64 編碼的資料 |\n\n#### 步驟 3：套用 YAML\n\n```bash title=\"建立 Secret\"\nkubectl apply -f my-secret.yaml\n```\n\n查看所有 Secret：\n\n```bash title=\"查看所有 Secret\"\nkubectl get secrets\n```\n\n**預期結果**：\n\n```\nNAME                       TYPE     DATA   AGE\ndemo-secret-from-file      Opaque   2      3m32s\ndemo-secret-from-literal   Opaque   2      2m13s\ndemo-secret-from-yaml      Opaque   2      5s\n```\n\n---\n\n## Lab 實作練習：Pod 存取 Secret\n\n### 方式一：透過環境變數存取\n\n```bash title=\"下載 Pod YAML\"\nwget http://10.0.1.248/k8s/yaml/my-pod.yaml\n```\n\n**Pod YAML 內容**：\n\n```yaml title=\"my-pod.yaml\"\napiVersion: v1\nkind: Pod\nmetadata:\n  name: my-pod\nspec:\n  containers:\n  - name: my-container\n    image: docker1.training.lab:5000/nginx\n    env:\n    - name: SECRET_USERNAME           # 環境變數名稱\n      valueFrom:\n        secretKeyRef:\n          name: demo-secret-from-yaml # Secret 名稱\n          key: username               # Secret 中的 Key\n    - name: SECRET_PASSWORD\n      valueFrom:\n        secretKeyRef:\n          name: demo-secret-from-yaml\n          key: password\n```\n\n套用 Pod：\n\n```bash title=\"建立 Pod\"\nkubectl apply -f my-pod.yaml\nkubectl get pods\n```\n\n**預期結果**：\n\n```\nNAME     READY   STATUS    RESTARTS   AGE\nmy-pod   1/1     Running   0          16s\n```\n\n進入 Pod 驗證環境變數：\n\n```bash title=\"驗證環境變數\"\nkubectl exec my-pod -it -- bash\n```\n\n```bash title=\"在容器內執行\"\nenv | grep SEC\n```\n\n**預期結果**：\n\n```\nSECRET_USERNAME=root\nSECRET_PASSWORD=pass1234\n```\n\n!!! success \"自動解碼\"\n    Pod 存取 Secret 時，Kubernetes 會**自動將 base64 解碼**，應用程式直接取得原始值。\n\n---\n\n### 方式二：透過 Volume 掛載存取\n\n```bash title=\"下載 Pod YAML\"\nwget http://192.168.66.248/k8s/yaml/my-pod-with-mounting-secret.yaml\n```\n\n**Pod YAML 內容**：\n\n```yaml title=\"my-pod-with-mounting-secret.yaml\"\napiVersion: v1\nkind: Pod\nmetadata:\n  name: my-pod-with-mounting-secret\nspec:\n  containers:\n  - name: my-container\n    image: docker1.training.lab:5000/nginx\n    volumeMounts:\n    - name: secret-volume\n      mountPath: \"/etc/creds\"         # 掛載路徑\n      readOnly: true\n  volumes:\n  - name: secret-volume\n    secret:\n      secretName: demo-secret-from-yaml  # Secret 名稱\n```\n\n套用 Pod：\n\n```bash title=\"建立 Pod\"\nkubectl apply -f my-pod-with-mounting-secret.yaml\nkubectl get pods\n```\n\n**預期結果**：\n\n```\nNAME                          READY   STATUS    RESTARTS   AGE\nmy-pod                        1/1     Running   0          22m\nmy-pod-with-mounting-secret   1/1     Running   0          7s\n```\n\n進入 Pod 驗證掛載的檔案：\n\n```bash title=\"驗證掛載\"\nkubectl exec my-pod-with-mounting-secret -it -- bash\n```\n\n```bash title=\"在容器內執行\"\nls -l /etc/creds\ncat /etc/creds/username\ncat /etc/creds/password\n```\n\n**預期結果**：\n\n```\ntotal 0\nlrwxrwxrwx 1 root root 15 Feb  4 08:06 password -> ..data/password\nlrwxrwxrwx 1 root root 15 Feb  4 08:06 username -> ..data/username\n\nroot\npass1234\n```\n\n!!! info \"掛載方式的特點\"\n    - Secret 的每個 Key 會變成一個檔案\n    - 檔案內容是解碼後的原始值\n    - 適合需要以檔案形式讀取的場景（如憑證、設定檔）\n\n---\n\n## 環境變數 vs Volume 掛載\n\n| 特性 | 環境變數 | Volume 掛載 |\n|------|----------|-------------|\n| **存取方式** | `$ENV_NAME` | 讀取檔案 |\n| **更新行為** | Pod 重啟才更新 | 自動更新（kubelet 同步） |\n| **資料格式** | 字串 | 檔案 |\n| **適用場景** | 簡單的 key-value | 憑證、設定檔 |\n\n---\n\n## 三種建立方式比較\n\n| 特性 | --from-file | --from-literal | YAML |\n|------|-------------|----------------|------|\n| **base64 編碼** | 自動 | 自動 | ⚠️ 手動 |\n| **Key 名稱** | 檔名 | 自訂 | 自訂 |\n| **版本控制** | 需額外管理檔案 | 不易版控 | ✅ 易於版控 |\n| **適用場景** | 現有檔案 | 快速測試 | 生產環境 |\n\n---\n\n## 常見問題\n\n??? question \"Q1：如何查看 Secret 的實際內容？\"\n    **解答**：使用 `kubectl get secret -o yaml` 並解碼：\n    \n    ```bash\n    kubectl get secret demo-secret-from-yaml -o yaml\n    # 解碼 base64\n    echo \"cm9vdA==\" | base64 -d\n    ```\n\n??? question \"Q2：Secret 和 ConfigMap 有什麼差別？\"\n    **解答**：\n    \n    | 特性 | Secret | ConfigMap |\n    |------|--------|-----------|\n    | **用途** | 敏感資料 | 一般設定 |\n    | **編碼** | base64 | 明文 |\n    | **儲存** | 記憶體（tmpfs） | 一般儲存 |\n\n??? question \"Q3：忘記加 -n 導致密碼包含換行怎麼辦？\"\n    **解答**：重新建立檔案或使用 `tr` 移除換行：\n    \n    ```bash\n    echo \"pass1234\" | tr -d '\\n' > password.txt\n    ```\n\n---\n\n## 小結\n\n本章節重點回顧：\n\n- ✅ **Secret 用途**：儲存敏感資訊（密碼、金鑰、憑證）\n- ✅ **三種建立方式**：\n  - `--from-file`：從檔案建立，自動 base64\n  - `--from-literal`：從指令建立，自動 base64\n  - YAML：需手動 base64 編碼\n- ✅ **兩種存取方式**：\n  - 環境變數（env + secretKeyRef）\n  - Volume 掛載（volumes + volumeMounts）\n- ✅ **自動解碼**：Pod 存取時自動將 base64 解碼為原始值\n\n## 延伸閱讀\n\n- [Kubernetes Secrets](https://kubernetes.io/docs/concepts/configuration/secret/)\n- [Distribute Credentials Securely Using Secrets](https://kubernetes.io/docs/tasks/inject-data-application/distribute-credentials-secure/)\n- [Secret Types](https://kubernetes.io/docs/concepts/configuration/secret/#secret-types)\n"
  },
  {
    "title": "Lab18 Rbac Event Log",
    "url": "https://caocharles.github.io/dcka-class-notes/lab18_rbac_event_log/",
    "content": "﻿# LAB 18 RBAC 與 Event/Log\n\n## 學習目標\n\n完成本章節後，你將能夠：\n\n- [ ] 理解 RBAC（Role-Based Access Control）的概念\n- [ ] 使用 ClusterRoleBinding 設定叢集層級的權限\n- [ ] 使用 kubectl get events 查看叢集事件\n- [ ] 使用 kubectl logs 查看 Pod 日誌\n\n## 前置知識\n\n開始之前，請確保你已經：\n\n- 完成 LAB 17 Secret\n- 熟悉 Pod、Deployment 基本概念\n- 準備好 Kubernetes 叢集環境（k8s-master1）\n\n---\n\n## 核心概念說明\n\n### RBAC 是什麼？\n\n**RBAC（Role-Based Access Control）** 是 Kubernetes 的**權限控制機制**，用來控制「誰」可以對「什麼資源」執行「什麼操作」。\n\n```mermaid\ngraph LR\n    User[使用者/ServiceAccount] -->|綁定| RB[RoleBinding]\n    RB -->|參照| Role[Role]\n    Role -->|允許| Actions[操作權限<br/>get/list/create/delete]\n    Actions -->|對象| Resources[資源<br/>pods/deployments/secrets]\n```\n\n---\n\n### RBAC 四種資源\n\n| 資源 | 作用範圍 | 說明 |\n|------|----------|------|\n| **Role** | Namespace | 定義單一 Namespace 內的權限 |\n| **RoleBinding** | Namespace | 將 Role 綁定給使用者 |\n| **ClusterRole** | 叢集 | 定義叢集層級的權限 |\n| **ClusterRoleBinding** | 叢集 | 將 ClusterRole 綁定給使用者 |\n\n```mermaid\ngraph TB\n    subgraph \"Namespace 層級\"\n        Role[Role] --> RB[RoleBinding]\n        RB --> User1[User/ServiceAccount]\n    end\n    \n    subgraph \"Cluster 層級\"\n        CR[ClusterRole] --> CRB[ClusterRoleBinding]\n        CRB --> User2[User/ServiceAccount]\n    end\n```\n\n---\n\n### 內建 ClusterRole\n\nKubernetes 預設提供多個內建的 ClusterRole：\n\n| ClusterRole | 權限 |\n|-------------|------|\n| **view** | 唯讀權限（get、list、watch） |\n| **edit** | 讀寫權限（不含 RBAC 設定） |\n| **admin** | 完整管理權限（含 RBAC 相關） |\n| **cluster-admin** | 超級管理員（所有權限） |\n\n---\n\n## Lab 實作練習：RBAC ClusterRoleBinding\n\n### 步驟 1：套用 ClusterRoleBinding\n\n```bash title=\"套用 RBAC YAML\"\nkubectl apply -f http://192.168.66.248/k8s/yaml/rbac3.yaml\n```\n\n**預期結果**：\n\n```\nclusterrolebinding.rbac.authorization.k8s.io/my-global-access created\n```\n\n**rbac3.yaml 內容範例**：\n\n```yaml title=\"rbac3.yaml（範例）\"\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: my-global-access\nsubjects:\n- kind: User\n  name: my-user              # 或 ServiceAccount\n  apiGroup: rbac.authorization.k8s.io\nroleRef:\n  kind: ClusterRole\n  name: view                 # 使用內建的 view ClusterRole\n  apiGroup: rbac.authorization.k8s.io\n```\n\n| 欄位 | 說明 |\n|------|------|\n| **subjects** | 權限授予的對象（User、Group、ServiceAccount） |\n| **roleRef** | 參照的 Role 或 ClusterRole |\n\n---\n\n### 步驟 2：查看 ClusterRoleBinding\n\n```bash title=\"查看 ClusterRoleBinding\"\nkubectl get clusterrolebindings.rbac.authorization.k8s.io | grep my-global\n```\n\n**預期結果**：\n\n```\nmy-global-access   ClusterRole/view   21s\n```\n\n!!! info \"綁定說明\"\n    此 ClusterRoleBinding 將 `view` ClusterRole 綁定給指定的使用者，讓該使用者擁有叢集的唯讀權限。\n\n---\n\n### 步驟 3：刪除 ClusterRoleBinding\n\n```bash title=\"刪除 ClusterRoleBinding\"\nkubectl delete -f http://192.168.66.248/k8s/yaml/rbac3.yaml\n```\n\n**預期結果**：\n\n```\nclusterrolebinding.rbac.authorization.k8s.io \"my-global-access\" deleted\n```\n\n---\n\n## Lab 實作練習：Event 事件監控\n\n### Event 是什麼？\n\n**Event（事件）** 是 Kubernetes 記錄叢集中發生的重要事件，例如 Pod 調度、映像檔拉取、容器啟動等。\n\n---\n\n### 步驟 1：建立測試 Pod\n\n```bash title=\"建立測試 Pod\"\nkubectl apply -f http://192.168.66.248/k8s/yaml/log1.yaml\n```\n\n**預期結果**：\n\n```\npod/log1 created\n```\n\n**log1.yaml 內容範例**：\n\n```yaml title=\"log1.yaml（範例）\"\napiVersion: v1\nkind: Pod\nmetadata:\n  name: log1\nspec:\n  containers:\n  - name: count\n    image: docker1.training.lab:5000/nginx\n    command: [\"/bin/sh\", \"-c\"]\n    args:\n    - i=0; while true; do echo \"$i: $(date)\"; i=$((i+1)); sleep 1; done\n```\n\n---\n\n### 步驟 2：查看事件\n\n```bash title=\"查看叢集事件\"\nkubectl get events\n```\n\n**預期結果**：\n\n```\nLAST SEEN   TYPE     REASON      OBJECT     MESSAGE\n13s         Normal   Scheduled   pod/log1   Successfully assigned default/log1 to k8s-node1.training.lab\n13s         Normal   Pulling     pod/log1   Pulling image \"docker1.training.lab:5000/nginx\"\n13s         Normal   Pulled      pod/log1   Successfully pulled image \"docker1.training.lab:5000/nginx\" in 177ms\n13s         Normal   Created     pod/log1   Created container: count\n13s         Normal   Started     pod/log1   Started container count\n```\n\n| 欄位 | 說明 |\n|------|------|\n| **LAST SEEN** | 事件發生時間 |\n| **TYPE** | 事件類型（Normal、Warning） |\n| **REASON** | 事件原因（Scheduled、Pulling、Started 等） |\n| **OBJECT** | 相關的資源 |\n| **MESSAGE** | 詳細訊息 |\n\n---\n\n### Event 生命週期\n\n```mermaid\nsequenceDiagram\n    participant Scheduler\n    participant Node\n    participant Container\n    \n    Scheduler->>Node: Scheduled (調度到節點)\n    Node->>Container: Pulling (拉取映像檔)\n    Node->>Container: Pulled (拉取完成)\n    Node->>Container: Created (建立容器)\n    Node->>Container: Started (啟動容器)\n```\n\n---\n\n## Lab 實作練習：Log 日誌查看\n\n### 步驟 1：查看 Pod 日誌\n\n```bash title=\"查看 Pod 日誌\"\nkubectl logs pod/log1\n```\n\n**預期結果**：\n\n```\n0: Tue Feb  4 08:17:29 UTC 2025\n1: Tue Feb  4 08:17:30 UTC 2025\n2: Tue Feb  4 08:17:31 UTC 2025\n3: Tue Feb  4 08:17:32 UTC 2025\n4: Tue Feb  4 08:17:33 UTC 2025\n...\n```\n\n---\n\n### 常用 logs 參數\n\n```bash title=\"即時追蹤日誌（類似 tail -f）\"\nkubectl logs pod/log1 -f\n```\n\n```bash title=\"顯示最近 10 行\"\nkubectl logs pod/log1 --tail=10\n```\n\n```bash title=\"顯示最近 1 小時的日誌\"\nkubectl logs pod/log1 --since=1h\n```\n\n```bash title=\"顯示時間戳記\"\nkubectl logs pod/log1 --timestamps\n```\n\n```bash title=\"指定容器（多容器 Pod）\"\nkubectl logs pod/log1 -c count\n```\n\n| 參數 | 說明 |\n|------|------|\n| `-f` | 即時追蹤（follow） |\n| `--tail=N` | 顯示最後 N 行 |\n| `--since=時間` | 顯示指定時間內的日誌 |\n| `--timestamps` | 顯示時間戳記 |\n| `-c 容器名` | 指定容器 |\n| `--previous` | 顯示前一個容器的日誌（重啟後） |\n\n---\n\n### 步驟 2：清理資源\n\n```bash title=\"刪除測試 Pod\"\nkubectl delete -f http://192.168.66.248/k8s/yaml/log1.yaml\n```\n\n**預期結果**：\n\n```\npod \"log1\" deleted\n```\n\n---\n\n## Event vs Log 比較\n\n| 特性 | Event | Log |\n|------|-------|-----|\n| **內容** | 叢集事件（調度、拉取映像檔） | 容器輸出（stdout/stderr） |\n| **來源** | Kubernetes 元件 | 應用程式 |\n| **用途** | 排查調度問題 | 排查應用程式問題 |\n| **保留時間** | 約 1 小時 | 取決於日誌輪替設定 |\n| **指令** | `kubectl get events` | `kubectl logs` |\n\n---\n\n## Lab 實作練習：Debug 實戰流程\n\n當 Pod 無法正常運行時，可以按照以下流程進行故障排除：\n\n```mermaid\ngraph TD\n    Start[Pod 異常] --> Step1[檢查節點狀態]\n    Step1 --> Step2[檢查 CNI Pod]\n    Step2 --> Step3[查看 Pod 事件]\n    Step3 --> Step4[查看容器日誌]\n    Step4 --> Fix[找到問題並修復]\n```\n\n---\n\n### 步驟 1：檢查節點狀態\n\n```bash title=\"檢查節點狀態\"\nkubectl get nodes\n```\n\n**預期結果**：\n\n```\nNAME                       STATUS     ROLES           AGE   VERSION\nk8s-master1.training.lab   Ready      control-plane   21h   v1.32.11\nk8s-node1.training.lab     NotReady   <none>          21h   v1.32.11\nk8s-node2.training.lab     Ready      <none>          21h   v1.32.11\n```\n\n!!! warning \"NotReady 狀態\"\n    如果節點顯示 `NotReady`，通常是 CNI（Container Network Interface）或 kubelet 有問題。\n\n---\n\n### 步驟 2：檢查 CNI Pod 狀態\n\n```bash title=\"檢查 Antrea CNI Pod\"\nkubectl get pods -n kube-system | grep antrea\n```\n\n**預期結果**：\n\n```\nantrea-agent-7zn4h                                 2/2     Running   0          2m33s\nantrea-agent-mdw2f                                 2/2     Running   0          2m34s\nantrea-agent-sbv79                                 2/2     Running   0          2m34s\nantrea-controller-57964d858f-bqwf8                 1/1     Running   0          37s\n```\n\n!!! tip \"其他 CNI\"\n    如果使用的是 Calico 或 Flannel，請改用：\n    \n    - Calico：`kubectl get pods -n kube-system | grep calico`\n    - Flannel：`kubectl get pods -n kube-system | grep flannel`\n\n---\n\n### 步驟 3：查看 Pod 詳細事件\n\n```bash title=\"查看 Pod 事件（底部會顯示 Events）\"\nkubectl describe pod <pod-name> -n <namespace>\n```\n\n**範例**：\n\n```bash\nkubectl describe pod antrea-agent-mdw2f -n kube-system | tail -20\n```\n\n**預期結果**：\n\n```\nEvents:\n  Type     Reason     Age   From               Message\n  ----     ------     ----  ----               -------\n  Normal   Scheduled  82s   default-scheduler  Successfully assigned kube-system/antrea-agent-mdw2f to k8s-node1.training.lab\n  Normal   Pulling    82s   kubelet            Pulling image \"antrea/antrea-agent-ubuntu:v2.2.0\"\n  Normal   Pulled     57s   kubelet            Successfully pulled image\n  Normal   Created    57s   kubelet            Created container: install-cni\n  Normal   Started    57s   kubelet            Started container install-cni\n  Warning  Unhealthy  43s   kubelet            Readiness probe failed: HTTP probe failed with statuscode: 500\n```\n\n---\n\n### 步驟 4：查看容器日誌\n\n```bash title=\"查看特定容器的日誌\"\nkubectl logs <pod-name> -n <namespace> -c <container-name> --tail=50\n```\n\n**範例**：\n\n```bash\nkubectl logs antrea-agent-mdw2f -n kube-system -c antrea-agent --tail=50\n```\n\n---\n\n### 完整狀態檢查腳本\n\n```bash title=\"一次檢查所有關鍵狀態\"\necho \"=== 節點狀態 ===\"\nkubectl get nodes\n\necho -e \"\\n=== CNI Pods ===\"\nkubectl get pods -n kube-system | grep antrea\n\necho -e \"\\n=== 應用 Pods ===\"\nkubectl get pods -A -o wide\n\necho -e \"\\n=== 系統核心 Pods ===\"\nkubectl get pods -n kube-system | grep -E 'coredns|kube-proxy'\n```\n\n---\n\n## Debug 常見問題對照表\n\n| 症狀 | 可能原因 | 檢查指令 |\n|------|----------|----------|\n| Node `NotReady` | CNI 未就緒 | `kubectl get pods -n kube-system` |\n| Pod `Pending` | 無可用節點 | `kubectl describe pod <name>` |\n| Pod `ImagePullBackOff` | 映像檔拉取失敗 | `kubectl describe pod <name>` |\n| Pod `CrashLoopBackOff` | 容器持續崩潰 | `kubectl logs <pod> --previous` |\n| Service 無法存取 | Endpoint 未綁定 | `kubectl get endpoints` |\n\n---\n\n## 常見問題\n\n??? question \"Q1：如何查看特定 Pod 的事件？\"\n    **解答**：使用 `kubectl describe pod` 會在底部顯示相關事件：\n    \n    ```bash\n    kubectl describe pod log1\n    ```\n\n??? question \"Q2：Pod 重啟後日誌消失了怎麼辦？\"\n    **解答**：使用 `--previous` 參數查看前一個容器的日誌：\n    \n    ```bash\n    kubectl logs pod/log1 --previous\n    ```\n\n??? question \"Q3：如何將日誌導出到檔案？\"\n    **解答**：使用 shell 重導向：\n    \n    ```bash\n    kubectl logs pod/log1 > pod-log.txt\n    ```\n\n---\n\n## 小結\n\n本章節重點回顧：\n\n- ✅ **RBAC 概念**：Role-Based Access Control 控制資源存取權限\n- ✅ **四種 RBAC 資源**：Role、RoleBinding（Namespace 層級）、ClusterRole、ClusterRoleBinding（叢集層級）\n- ✅ **內建 ClusterRole**：view（唯讀）、edit（讀寫）、admin（管理）、cluster-admin（超級管理員）\n- ✅ **Event 監控**：`kubectl get events` 查看叢集事件\n- ✅ **Log 查看**：`kubectl logs` 查看容器輸出，支援 `-f`、`--tail`、`--since` 等參數\n\n## 延伸閱讀\n\n- [Kubernetes RBAC](https://kubernetes.io/docs/reference/access-authn-authz/rbac/)\n- [Using RBAC Authorization](https://kubernetes.io/docs/reference/access-authn-authz/rbac/)\n- [Kubectl Logs](https://kubernetes.io/docs/reference/kubectl/generated/kubectl_logs/)\n"
  },
  {
    "title": "Lab19 K8S Wordpress Mysql",
    "url": "https://caocharles.github.io/dcka-class-notes/lab19_k8s_wordpress_mysql/",
    "content": "﻿# LAB 19 Kubernetes + WordPress + MySQL 部署\n\n## 學習目標\n\n完成本章節後，你將能夠：\n\n- [ ] 設定 NFS Server 提供共享儲存\n- [ ] 設定 Worker Node 開機自動掛載 NFS\n- [ ] 建立 ConfigMap 和 Secret\n- [ ] 建立 PV/PVC 持久化儲存\n- [ ] 部署 MySQL 資料庫和 WordPress\n\n## 前置知識\n\n開始之前，請確保你已經：\n\n- 完成 LAB 16 PV/PVC\n- 完成 LAB 17 Secret\n- 熟悉 Service、Deployment 基本概念\n\n---\n\n## 核心概念說明\n\n### 整體架構\n\n```mermaid\ngraph TB\n    subgraph \"k8s-master1 (NFS Server)\"\n        NFS[NFS 服務]\n        Data[/data]\n    end\n    \n    subgraph \"Kubernetes Cluster\"\n        subgraph \"WordPress\"\n            WP[WordPress Pod]\n            WP-SVC[WordPress Service<br/>LoadBalancer]\n        end\n        \n        subgraph \"MySQL\"\n            MySQL[MySQL Pod]\n            MySQL-SVC[MySQL Service<br/>ClusterIP: None]\n        end\n        \n        PV1[local-pv-1]\n        PV2[local-pv-2]\n    end\n    \n    User[使用者] -->|NodePort| WP-SVC\n    WP-SVC --> WP\n    WP -->|連接 3306| MySQL-SVC\n    MySQL-SVC --> MySQL\n    PV1 -.->|NFS| NFS\n    PV2 -.->|NFS| NFS\n```\n\n---\n\n## Lab 實作練習\n\n!!! info \"操作環境\"\n    本 Lab **所有操作都在 k8s-master1** 上執行，不需要切換到其他虛擬機的 Console。\n\n---\n\n### 步驟 1：確認 Kubernetes 環境正常\n\n```bash title=\"檢查節點狀態\"\nkubectl get nodes\n```\n\n**預期結果**：\n\n```\nNAME                       STATUS   ROLES           AGE   VERSION\nk8s-master1.training.lab   Ready    control-plane   22h   v1.32.11\nk8s-node1.training.lab     Ready    <none>          22h   v1.32.11\nk8s-node2.training.lab     Ready    <none>          22h   v1.32.11\n```\n\n!!! warning \"節點必須 Ready\"\n    確保所有節點都是 `Ready` 狀態再繼續。\n\n---\n\n### 步驟 2：建立 NFS 共享目錄\n\n在 Master 建立資料目錄：\n\n```bash title=\"在 k8s-master1 建立目錄\"\nmkdir -p /data/db\nmkdir -p /data/wordpress\n```\n\n在 Worker Node 建立掛載點：\n\n```bash title=\"透過 SSH 在 Worker Node 建立目錄\"\nsshpass -p container ssh -p 22 root@k8s-node1 \"mkdir -p /data\"\nsshpass -p container ssh -p 22 root@k8s-node2 \"mkdir -p /data\"\n```\n\n---\n\n### 步驟 3：安裝 NFS 套件\n\n**在 k8s-master1（NFS Server）安裝**：\n\n```bash title=\"安裝 NFS Server\"\nyum install nfs-utils -y\n```\n\n**在 Worker Node（NFS Client）安裝**：\n\n```bash title=\"透過 SSH 安裝 NFS Client\"\nsshpass -p container ssh -p 22 root@k8s-node1 \"yum install nfs-utils -y\"\nsshpass -p container ssh -p 22 root@k8s-node2 \"yum install nfs-utils -y\"\n```\n\n---\n\n### 步驟 4：設定 NFS Server\n\n編輯 /etc/exports：\n\n```bash title=\"編輯 NFS 匯出設定\"\nvi /etc/exports\n```\n\n加入以下內容：\n\n```title=\"/etc/exports\"\n/data *(rw,no_root_squash)\n```\n\n啟動並啟用 NFS 服務：\n\n```bash title=\"啟動 NFS Server\"\nsystemctl start nfs-server.service\nsystemctl enable nfs-server.service\n```\n\n**預期結果**：\n\n```\nCreated symlink /etc/systemd/system/multi-user.target.wants/nfs-server.service → /usr/lib/systemd/system/nfs-server.service.\n```\n\n---\n\n### 步驟 5：掛載 NFS 並驗證\n\n在 Worker Node 掛載 NFS：\n\n```bash title=\"掛載 NFS\"\nsshpass -p container ssh -p 22 root@k8s-node1 \"mount -t nfs k8s-master1:/data /data\"\nsshpass -p container ssh -p 22 root@k8s-node2 \"mount -t nfs k8s-master1:/data /data\"\n```\n\n!!! warning \"主機名稱很重要\"\n    必須使用 `k8s-master1:/data`，使用 `master:/data` 會卡住無回應！\n\n驗證掛載成功：\n\n```bash title=\"驗證 NFS 掛載\"\nsshpass -p container ssh -p 22 root@k8s-node1 \"df -Th | grep nfs\"\nsshpass -p container ssh -p 22 root@k8s-node2 \"df -Th | grep nfs\"\n```\n\n**預期結果**：\n\n```\nk8s-master1:/data   nfs4       70G  8.0G   62G  12% /data\n```\n\n---\n\n### 步驟 6：設定開機自動掛載\n\n修改 fstab 並複製到 Worker Node：\n\n```bash title=\"建立修改後的 fstab\"\ncp /etc/fstab /tmp/fstab\necho \"k8s-master1:/data /data nfs defaults 0 0\" >> /tmp/fstab\n```\n\n查看修改內容：\n\n```bash title=\"確認 fstab 內容\"\ncat /tmp/fstab\n```\n\n**預期結果**（最後一行）：\n\n```\nk8s-master1:/data /data nfs defaults 0 0\n```\n\n複製到 Worker Node：\n\n```bash title=\"複製 fstab 到 Worker Node\"\nsshpass -p container scp /tmp/fstab root@k8s-node1:/etc/fstab\nsshpass -p container scp /tmp/fstab root@k8s-node2:/etc/fstab\n```\n\n---\n\n### 步驟 7：建立 ConfigMap\n\n```bash title=\"建立 ConfigMap\"\nkubectl create configmap mydb-env \\\n  --from-literal=MYSQL_ROOT_PASSWORD=container \\\n  --from-literal=TZ=\"Asia/Taipei\"\n```\n\n驗證：\n\n```bash title=\"查看 ConfigMap\"\nkubectl get configmaps\nkubectl describe configmaps mydb-env\n```\n\n**預期結果**：\n\n```\nData\n====\nMYSQL_ROOT_PASSWORD:\n----\ncontainer\n\nTZ:\n----\nAsia/Taipei\n```\n\n---\n\n### 步驟 8：建立 Secret\n\n```bash title=\"建立 Secret\"\nkubectl create secret generic mysql-pass \\\n  --from-literal=password=container\n```\n\n驗證：\n\n```bash title=\"查看 Secret\"\nkubectl get secrets\nkubectl describe secrets mysql-pass\n```\n\n**預期結果**：\n\n```\nData\n====\npassword:  9 bytes\n```\n\n---\n\n### 步驟 9：建立 PV\n\n```bash title=\"建立 PV\"\nkubectl apply -f http://10.0.1.249/k8s/yaml/volumes.yaml\nkubectl get pv\n```\n\n**預期結果**：\n\n```\nNAME         CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM   STORAGECLASS   AGE\nlocal-pv-1   20Gi       RWO            Retain           Available                          8s\nlocal-pv-2   20Gi       RWO            Retain           Available                          8s\n```\n\n---\n\n### 步驟 10：部署 MySQL\n\n```bash title=\"部署 MySQL\"\nkubectl apply -f http://10.0.1.249/k8s/yaml/mysql-deployment.yaml\n```\n\n驗證：\n\n```bash title=\"查看 MySQL 資源\"\nkubectl get services\nkubectl get deployments.apps\nkubectl get pods\n```\n\n**預期結果**：\n\n```\nNAME              TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)    AGE\nwordpress-mysql   ClusterIP   None         <none>        3306/TCP   13s\n\nNAME              READY   UP-TO-DATE   AVAILABLE   AGE\nwordpress-mysql   1/1     1            1           28s\n\nNAME                               READY   STATUS    RESTARTS   AGE\nwordpress-mysql-57444c5587-kkwq4   1/1     Running   0          36s\n```\n\n!!! info \"Headless Service\"\n    `wordpress-mysql` Service 的 ClusterIP 是 `None`，這是 Headless Service，WordPress 會透過 DNS 名稱直接連接 MySQL Pod。\n\n---\n\n### 步驟 11：部署 WordPress\n\n```bash title=\"部署 WordPress\"\nkubectl apply -f http://10.0.1.249/k8s/yaml/wordpress-deployment.yaml\n```\n\n驗證：\n\n```bash title=\"查看 WordPress 資源\"\nkubectl get deployments.apps\nkubectl get services\nkubectl get pods\n```\n\n**預期結果**：\n\n```\nNAME              READY   UP-TO-DATE   AVAILABLE   AGE\nwordpress         1/1     1            1           14s\nwordpress-mysql   1/1     1            1           101s\n\nNAME              TYPE           CLUSTER-IP      EXTERNAL-IP   PORT(S)        AGE\nwordpress         LoadBalancer   172.30.184.40   <pending>     80:31294/TCP   23s\nwordpress-mysql   ClusterIP      None            <none>        3306/TCP       110s\n```\n\n!!! note \"LoadBalancer 類型\"\n    WordPress Service 是 `LoadBalancer` 類型，在本地環境 EXTERNAL-IP 會顯示 `<pending>`，但可以透過 NodePort（如 31294）或 ClusterIP 存取。\n\n---\n\n### 步驟 12：初始化 WordPress\n\n使用瀏覽器開啟 WordPress（使用 ClusterIP）：\n\n```bash title=\"開啟 WordPress\"\nfirefox http://172.30.184.40\n```\n\n或使用 Node IP + NodePort：\n\n```bash title=\"使用 NodePort 存取\"\nfirefox http://k8s-node1:31294\nfirefox http://k8s-node2:31294\n```\n\n!!! success \"WordPress 安裝頁面\"\n    如果看到 WordPress 安裝頁面（語言選擇），表示部署成功！選擇語言後依照畫面指示完成設定。\n\n**WordPress 安裝成功畫面**：\n\n![WordPress 安裝頁面 - 語言選擇](assets/images/wordpress_install_page.png)\n\n---\n\n## 資源總覽\n\n```bash title=\"查看所有資源\"\nkubectl get all\nkubectl get pv,pvc\nkubectl get configmaps,secrets\n```\n\n---\n\n## 清理資源\n\n```bash title=\"清理所有資源\"\nkubectl delete -f http://10.0.1.249/k8s/yaml/wordpress-deployment.yaml\nkubectl delete -f http://10.0.1.249/k8s/yaml/mysql-deployment.yaml\nkubectl delete -f http://10.0.1.249/k8s/yaml/volumes.yaml\nkubectl delete secret mysql-pass\nkubectl delete configmap mydb-env\n```\n\n---\n\n## 常見問題\n\n??? question \"Q1：NFS 掛載卡住無回應？\"\n    **原因**：使用了錯誤的主機名稱。\n    \n    **解決方案**：使用完整主機名稱 `k8s-master1:/data`，不要用簡寫 `master:/data`。\n\n??? question \"Q2：WordPress 無法連接 MySQL？\"\n    **檢查項目**：\n    \n    1. MySQL Pod 是否 Running：`kubectl get pods -l app=wordpress`\n    2. Secret 是否存在：`kubectl get secret mysql-pass`\n    3. 查看 WordPress 日誌：`kubectl logs -l app=wordpress,tier=frontend`\n\n??? question \"Q3：PVC 處於 Pending 狀態？\"\n    **原因**：找不到符合條件的 PV。\n    \n    **檢查**：確認 PV 已建立且狀態是 Available。\n\n---\n\n## 小結\n\n本章節重點回顧：\n\n- ✅ **NFS Server 設定**：`/data *(rw,no_root_squash)`\n- ✅ **NFS Client 掛載**：使用 `k8s-master1:/data`（不是 `master:/data`）\n- ✅ **fstab 自動掛載**：透過 scp 複製到 Worker Node\n- ✅ **ConfigMap**：儲存 MySQL 環境變數\n- ✅ **Secret**：儲存 MySQL 密碼\n- ✅ **PV/PVC**：NFS 持久化儲存\n- ✅ **Headless Service**：MySQL 使用 `clusterIP: None`\n- ✅ **LoadBalancer Service**：WordPress 對外暴露\n\n## 延伸閱讀\n\n- [Kubernetes WordPress + MySQL Example](https://kubernetes.io/docs/tutorials/stateful-application/mysql-wordpress-persistent-volume/)\n- [NFS Persistent Volumes](https://kubernetes.io/docs/concepts/storage/volumes/#nfs)\n"
  },
  {
    "title": "Lab20 Dashboard",
    "url": "https://caocharles.github.io/dcka-class-notes/lab20_dashboard/",
    "content": "﻿# LAB 20 圖形管理工具 Kubernetes Dashboard\n\n## 學習目標\n\n- [ ] 待補\n\n## 實作步驟\n\n*(本章節內容待補)*\n\n"
  }
]